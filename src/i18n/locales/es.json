{
  "questions": [
    {
      "title": "Se busca encontrar el camino más corto entre dos ciudades utilizando una tabla con distancias entre parejas de ciudades, donde -1 indica ausencia de vía. Para llegar desde la ciudad inicial hasta la final puede necesitarse recorrer varias ciudades. Conocidos son también los datos geográficos de cada ciudad permitiendo calcular la distancia geográfica directa entre ellas. Se propone acelerar la búsqueda mediante un algoritmo de ramificación y poda priorizando primero a aquellas ciudades situadas a menor distancia geográfica respecto a la destino.",
      "choices": [
        "No garantiza siempre ser más rápido",
        "No asegura obtener el camino más corto",
        "Solo será más rápido en determinadas instancias del problema"
      ],
      "solution": 2
    },
    {
      "title": "Tratándose de un problema de optimización, en la lista de nodos vivos de ramificación y poda...",
      "choices": [
        "Sólo se introducen nodos prometedores, es decir, nodos que pueden mejorar la mejor solución que se tiene en ese momento",
        "Puede haber nodos que no son prometedores",
        "Las otras dos opciones son ciertas"
      ],
      "solution": 2
    },
    {
      "title": "Se desea obtener todas las permutaciones de una lista compuesta por n elementos, ¿qué esquema es el más adecuado?",
      "choices": [
        "Divide y vencerás, puesto que la división en sublistas se podría hacer en tiempo constante",
        "Ramificación y poda, puesto que con buenas funciones de cota es más eficiente para este problema que vuelta atrás",
        "Vuelta atrás, para este problema no hay un esquema más eficiente"
      ],
      "solution": 2
    },
    {
      "title": "Al resolver el problema del viajante de comercio mediante vuelta atrás y asumiendo un grafo de n vértices totalmente conexo, ¿cuál de estas es una buena cota pesimista al iniciar la búsqueda?",
      "choices": [
        "Se ordenan las aristas restantes de menor a mayor distancia y se calcula la suma de las n aristas más cortas",
        "Se resuelve el problema usando un algoritmo voraz que añade cada vez al camino el vértice más cercano al último añadido",
        "Se multiplica n por la distancia de la arista más corta que nos queda por considerar"
      ],
      "solution": 1
    },
    {
      "title": "Si utilizamos un algoritmo de ramificación y poda y lo adaptamos ligeramente para transformarlo en un algoritmo de vuelta atrás, qué cambiamos realmente?:",
      "choices": [
        "Provocamos que las cotas optimistas pierden efectividad",
        "Cambiamos la función dada a la cota pesimista",
        "Sería necesario verificar si las soluciones son factibles o no, ya que ramificación y poda sólo generan nodos factibles."
      ],
      "solution": 0
    },
    {
      "title": "¿Cuál es la diferencia principal entre una solución de vuelta atrás y una solución de ramificación y poda para el problema de la mochila?",
      "choices": [
        "El orden de exploración de las soluciones",
        "El hecho que la solución de ramificación y poda puede empezar con una solución subóptima voraz y la de vuelta atrás no",
        "El coste asintótico en el caso peor"
      ],
      "solution": 0
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades.\nPara ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela (por ejemplo, -1) si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. Como también se conocen las coordenadas geográficas de cada ciudad se quiere usar la distancia geográfica (en línea recta) entre cada par de ciudades para como cota para limitar la búsqueda en un algoritmo de vuelta atrás.\n¿Qué tipo de cota sería?",
      "choices": [
        "Una cota pesimista",
        "Una cota optimista",
        "No se trataría de ninguna poda puesta que es posible que esa heurística no encuentre una solución factible"
      ],
      "solution": 1
    },
    {
      "title": "La ventaja de la estrategia ramificación y poda frente a vuelta atrás es que la primera genera las soluciones posibles al problema mediante...",
      "choices": [
        "Un recorrido guiado por una cola de prioridad de donde se extraen primero los nodos que representan los subárboles más prometedores del espacio de soluciones",
        "Las otras dos opciones son verdaderas",
        "Un recorrido guiado por estimaciones de las mejores ramas del árbol que representa el espacio de soluciones"
      ],
      "solution": 1
    },
    {
      "title": "La estrategia de vuelta atrás es aplicable a problemas de selección y optimización en los que:",
      "choices": [
        "El espacio de soluciones es un conjunto infinito",
        "El espacio de soluciones es un conjunto finito",
        "El espacio de soluciones puede ser tanto finito como infinito pero en este último caso debe ser al menos numerable"
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades.\nPara ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela (por ejemplo, -1) si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades También se conocen las coordenadas geográficas de cada ciudad y por tanto la distancia geográfica (en línea recta) entre cada par de ciudades Para limitar la búsqueda en un algoritmo de vuelta atrás se utiliza la solución de un algoritmo voraz basado en moverse en cada paso a la ciudad de entre las posibles según el mapa de carreteras que esté más cercana al destino según su distancia geográfica.\nEste algoritmo voraz ¿serviría como cota pesimista?",
      "choices": [
        "No ya que no asegura que se encuentre una solución factible",
        "No ya que en algunos casos puede dar distancias menores que la óptima",
        "Sí puesto que la distancia geográfica asegura que otra solución mejor no es posible"
      ],
      "solution": 0
    },
    {
      "title": "Cuando resolvemos un problema mediante un esquema de ramificación y poda...",
      "choices": [
        "Las decisiones sólo pueden ser binarias",
        "Los valores entre los cuales se elige en cada una de las decisiones pueden formar un conjunto infinito",
        "Los valores entre los cuales se elige en cada una de las decisiones tienen que formar un conjunto finit"
      ],
      "solution": 2
    },
    {
      "title": "Cuando se resuelve un algoritmo de vuelta atrás un problema de n decisiones, en el que siempre hay como mínimo dos opciones para cada decisión, ¿cuál de las siguientes complejidades en el caso peor es la mejor que nos podemos encontrar?",
      "choices": ["\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)", "\\(\\Omicron(n!)\\)"],
      "solution": 0
    },
    {
      "title": "La complejidad en el peor de los casos de un algoritmo de ramificación y poda:",
      "choices": [
        "Puede ser exponencial con el número de alternativas por cada decisión",
        "Es exponencial con el número de decisiones a tomar",
        "Puede ser polinómica con el número de decisiones a tomar"
      ],
      "solution": 1
    },
    {
      "title": "En ausencia de cotas optimista y pesimistas, la estrategia de vuelta atrás...",
      "choices": [
        "No se puede usar para resolver problemas de optimización",
        "No recorre todo el árbol si hay manera de descartar subárboles que representan conjuntos de soluciones no factibles",
        "Debe recorrer siempre todo el árbol"
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades.\nPara ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela (por ejemplo, -1) si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. Para limitar la búsqueda en un algoritmo de vuelta atrás, se utiliza la solución de un algoritmo voraz basado en moverse en cada paso a la ciudad, de entre las posibles según el mapa de carreteras, que esté más cercana al destino en línea recta.\n¿Qué tipo de cota sería?",
      "choices": [
        "Sería una cota pesimista siempre que se tenga la certeza de que esa aproximación encuentra la solución factible",
        "Sería una cota optimista siempre que se tenga la certeza de que esa aproximación encuentra una solución factible",
        "Ninguna de las otras dos opciones"
      ],
      "solution": 0
    },
    {
      "title": "Decide cuál de estas tres no sirve como cota optimista para obtener el valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de la mochila discreta que se obtiene usando un algoritmo voraz basado en el valor específico de los objetos",
        "El valor de la mochila continua correspondiente",
        "El valor de una mochila que contiene todos los objetos aunque se pase del peso máximo permitido"
      ],
      "solution": 0
    },
    {
      "title": "La complejidad en el menor de los casos de un algoritmo de ramificación y poda...",
      "choices": [
        "Suele ser polinómica con el número de alternativas por cada decisión",
        "Es siempre exponencial con el número de decisiones a tomar",
        "Puede ser polinómica con el número de decisiones a tomar"
      ],
      "solution": 2
    },
    {
      "title": "¿Para qué sirven las cotas pesimistas en ramificación y poda?",
      "choices": [
        "Para descartar nodos basándose en la preferencia por algún otro nodo ya completado",
        "Para tener la certeza de que la cota optimista está bien calculada",
        "Para descartar nodos basándose en el beneficio esperado"
      ],
      "solution": 2
    },
    {
      "title": "En los algoritmos de ramificación y poda, ¿el valor de una cota pesimista es menor que el valor de una cota optimista?",
      "choices": [
        "Sí, siempre es así",
        "En general sí, si se trata de un problema de maximización, aunque en ocasiones ambos valores pueden coincidir",
        "En general sí, si se trata de un problema de minimización, aunque en ocasiones ambos valores pueden coincidir"
      ],
      "solution": 1
    },
    {
      "title": "La estrategia de ramificación y poda...",
      "choices": [
        "Necesita cotas pesimistas para decidir el orden de visita de los nodos del árbol de soluciones",
        "Para determinar si una solución es factible",
        "Sólo si se usa para resolver problemas de optimización"
      ],
      "solution": 2
    },
    {
      "title": "En el esquema de vuelta atrás, los mecanismos de poda basados en la mejor solución hasta el momento...",
      "choices": [
        "Las dos anteriores son verdaderas",
        "Garantizan que no se va a explorar nunca todo el espacio de soluciones posibles",
        "Pueden eliminar soluciones parciales que son factibles"
      ],
      "solution": 2
    },
    {
      "title": "El uso de funciones de cota en ramificación y poda...",
      "choices": [
        "Garantiza que el algoritmo va a ser más eficiente ante cualquier instancia del problema",
        "Puede reducir el número de instancias del problema que pertenecen al caso peor",
        "Transforma en polinómicas complejidades que antes eran exponenciales"
      ],
      "solution": 1
    },
    {
      "title": "Decid cuál de estas tres es la cota pesimista más ajustada al valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de la mochila continua correspondiente",
        "El valor de una mochila que contiene todos los objetos aunque se pase del peso máximo permitido",
        "El valor de la mochila discreta que se obtiene usando un algoritmo voraz basado en el valor específico de los objetos"
      ],
      "solution": 2
    },
    {
      "title": "En la estrategia ramificación y poda...",
      "choices": [
        "Cada nodo tiene su propia cota optimista, la cota pesimista sin embargo, es común para todos los nodos",
        "Cada nodo tiene su propia cota pesimista y también su propia cota optimista",
        "Cada nodo tiene su propia cota pesimista, la cota optimista sin embargo, es común para todos los nodos"
      ],
      "solution": 1
    },
    {
      "title": "En algoritmos de ramificación y poda:",
      "choices": [
        "Una cota optimista es necesariamente un valor insuperable, pero si no lo fuera, se podría podar el nodo que conduce a la solución óptima",
        "Una cota optimista es necesariamente un valor alcanzable, pero si no lo fuera, no está garantizado que se encuentre la solución óptima",
        "El uso de cotas pesimistas solo resulta eficaz cuando se dispone de una posible solución de partida"
      ],
      "solution": 1
    },
    {
      "title": "Decide cual de estas tres es la cotas optimista cuando se utiliza la estrategia de vuelta atrás para resolver el problema de la mochila:",
      "choices": [
        "Valor de una mochila",
        "Valor óptimo de la mochila continuo correspondiente",
        "Valor de la mochila discreta obtenido con un algoritmo voraz basado en el valor específico del objeto"
      ],
      "solution": 1
    },
    {
      "title": "En los algoritmos de ramificación y poda, ¿el valor de una cota pesimista es mayor que el valor de una cota optimista? (Entendiendo que ambas cotas se aplican sobre el mismo nodo)",
      "choices": [
        "No, nunca es así",
        "En general sí, si se trata de un problema de maximización, aunque en ocasiones ambos valores pueden coincidir",
        "En general sí, si se trata de un problema de minimización, aunque en ocasiones ambos valores pueden coincidir"
      ],
      "solution": 2
    },
    {
      "title": "Dado un problema de optimización cualquiera, ¿la estrategia de vuelta atrás garantiza la solución óptima?",
      "choices": [
        "Es condición necesaria que el dominio de las decisiones sea discreto o discretizable y que el número de decisiones a tomar esté acotado",
        "Sí, siempre que el dominio de las decisiones sea discreto o discretizable y además se empleen mecanismos de poda basados en la mejor solución hasta el momento",
        "Sí, puesto que ese método analiza todas las posibilidades"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la asignación de turnos tiene solución:\nEl problema de la asignación de turnos. Estamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": [
        "Optima mediante backtracking",
        "Aproximada (sub-óptima) mediante voraz",
        "Ambas"
      ],
      "solution": 2
    },
    {
      "title": "El tiempo de ejecución de un algoritmo de ramificación y poda depende de:",
      "choices": [
        "La instancia del problema",
        "La función de selección de nodos para su expansión",
        "De ambos"
      ],
      "solution": 2
    },
    {
      "title": "Es un problema de optimización, si el dominio de las decisiones es un conjunto infinito",
      "choices": [
        "Podemos aplicar el esquema vuelta atrás siempre que se trate de un conjunto infinito numerable",
        "Una estrategia voraz puede ser la única alternativa",
        "Es probable que a través de programación dinámica se obtenga un algoritmo eficaz que lo solucione"
      ],
      "solution": 1
    },
    {
      "title": "Backtracking es aplicable a problemas de selección y optimización en los que:",
      "choices": [
        "El espacio de soluciones es un conjunto finito",
        "En cualquiera de los casos",
        "El espacio de soluciones es un conjunto infinito"
      ],
      "solution": 0
    },
    {
      "title": "Backtracking es una técnica de resolución general de problemas basada en:",
      "choices": [
        "La búsqueda sistemática de soluciones",
        "La construcción directa de la solución",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "Voraz siempre da solución óptima:",
      "choices": [
        "A los dos",
        "Al problema de la mochila sin fraccionamiento",
        "Al problema de la mochila con fraccionamiento"
      ],
      "solution": 2
    },
    {
      "title": "El problema de la mochila, ¿encuentra su solución óptima empleando la estrategia voraz?:",
      "choices": [
        "Sólo para el caso de la mochila sin fraccionamiento",
        "En cualquiera de los casos anteriores",
        "Sólo para el caso de la mochila con fraccionamiento"
      ],
      "solution": 2
    },
    {
      "title": "El problema del viajante de comercio puede resolverse correctamente empleando estos esquemas de programación:",
      "choices": [
        "Sólo programación dinámica",
        "Empleando cualquiera de estos: Voraz y backtracking",
        "Solo backtracking"
      ],
      "solution": 2
    },
    {
      "title": "En el método voraz, aunque las decisiones son irreversibles, podemos asegurar que:",
      "choices": [
        "Siempre obtendremos una solución factible",
        "Siempre obtendremos la solución óptima",
        "Sólo obtendremos la solución óptima para algunos problemas"
      ],
      "solution": 2
    },
    {
      "title": "Al aplicar backtracking obtenemos la solución óptima a un problema:",
      "choices": [
        "Siempre",
        "Solo cuando el problema cumple el principio de optimalidad",
        "En algunos casos"
      ],
      "solution": 2
    },
    {
      "title": "Dado un problema resuelto mediante backtracking y mediante ramificación y poda, el coste computacional de la solución por Ramificación y Poda, en comparación con la de Backtracking es:",
      "choices": ["Menor", "Igual", "Mayor"],
      "solution": 1
    },
    {
      "title": "El problema de la asignación de turnos tiene solución óptima empleando:\nEl problema de la asignación de turnos. Estamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": ["Backtracking", "Voraz", "Ambos"],
      "solution": 0
    },
    {
      "title": "Al aplicar vuelta atrás a la solución de problemas, obtenemos algoritmos con costes computacionales:",
      "choices": ["Exponenciales", "Polinómicos", "Los dos son correctos. Depende del problema"],
      "solution": 0
    },
    {
      "title": "Vuelta atrás se emplea en la resolución de problemas de optimización en los que se pretende encontrar:",
      "choices": [
        "Las dos respuestas anteriores son correctas",
        "Una solución que satisfaga unas restricciones y optimice una cierta función objetivo",
        "Todas las soluciones que satisfagan unas restricciones"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la asignación de turnos tiene solución óptima voraz aplicando la siguiente estrategia:\nEl problema de la asignación de turnos. Estamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": [
        "El problema no tiene solución óptima voraz",
        "Seleccionamos los alumnos en orden descendente de preferencia respetando las restricciones de cabida de cada turno.",
        "Seleccionamos los alumnos en orden ascendente de preferencia respetando las restricciones de cabida de cada turno"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la mochila, ¿puede solucionarse empleando vuelta atrás?:",
      "choices": [
        "Sólo para el caso de la mochila con fraccionamiento",
        "Sólo para el caso de la mochila sin fraccionamiento",
        "Se puede aplicar para ambos casos"
      ],
      "solution": 2
    },
    {
      "title": "Dado un problema de optimización y un algoritmo voraz que lo soluciona, ¿cuándo podemos estar seguros de que la solución obtenida será óptima?:",
      "choices": [
        "Voraz siempre encuentra solución óptima",
        "En ambos casos. Las dos son correctas",
        "Cuando demostremos formalmente que el criterio conduce a una solución óptima para cualquier instancia del problema"
      ],
      "solution": 2
    },
    {
      "title": "El problema de la asignación de turnos resuelto mediante backtracking tiene una complejidad:\nEl problema de la asignación de turnos. Estamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": ["Exponencial", "Polinómica", "Ninguna de las dos"],
      "solution": 0
    },
    {
      "title": "Backtracking busca obtener la solución a un problema de optimización mediante la siguiente estrategia:",
      "choices": [
        "Genera todas las combinaciones de la solución y selecciona la que optimiza la función objetivo",
        "Genera todas las soluciones factibles y selecciona la que optimiza la función objetivo",
        "Genera una solución factible empleando un criterio óptimo"
      ],
      "solution": 1
    },
    {
      "title": "Dado un grafo G que representa las poblaciones de la provincia de Alicante de más de 20.000 habitantes junto con todas las carreteras de conexión entre ellas. Queremos obtener el recorrido que nos permita pasar por todas estas ciudades una única vez y volver al punto de origen recorriendo el mínimo número de kilómetros. Si aplicamos una estrategia voraz sobre este grafo obtendremos...",
      "choices": [
        "Puede que no encuentre ninguna solución aunque ésta exista",
        "Una solución factible",
        "La solución óptima"
      ],
      "solution": 1
    },
    {
      "title": "Si aplicamos un algoritmo voraz que no nos garantiza la solución óptima sobre un problema entonces...",
      "choices": [
        "Si el problema tiene solución óptima, el esquema voraz nos garantiza que la encuentra",
        "Obtendremos una solución factible",
        "Puede que no encuentre ninguna solución aunque ésta exista"
      ],
      "solution": 2
    },
    {
      "title": "El método voraz se emplea en la resolución de problemas de selección y optimización en los que se pretende encontrar:",
      "choices": [
        "Las dos respuestas anteriores son correctas",
        "Todas las soluciones que satisfagan unas restricciones",
        "Una solución que satisfaga unas restricciones y optimice una cierta función objetivo"
      ],
      "solution": 2
    },
    {
      "title": "Si aplicamos un esquema backtracking que no nos garantiza la solución óptima sobre un problema entonces",
      "choices": [
        "Obtendremos una solución factible",
        "Puede que no encuentre ninguna solución aunque ésta exista",
        "Ninguna de las anteriores"
      ],
      "solution": 2
    },
    {
      "title": "La estrategia de ramificación y poda genera las soluciones posibles al problema mediante:",
      "choices": [
        "Un recorrido en profundidad del árbol que representa el espacio de soluciones",
        "Un recorrido en anchura que representa el espacio de soluciones",
        "Un recorrido guiado por estimaciones de las mejores ramas del árbol que representa el espacio de soluciones"
      ],
      "solution": 2
    },
    {
      "title": "Dado el problema de asignación de turnos mediante vuelta atrás recursiva, cada llamada recursiva genera cuantas nuevas llamadas recursivas?:\nEl problema de la asignación de turnos. Estamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": ["Una o dos", "Una o ninguna", "Ninguna de las anteriores"],
      "solution": 2
    },
    {
      "title": "¿Cuál de estas afirmaciones es falsa?",
      "choices": [
        "La complejidad en el peor caso de las soluciones Backtracking y ramificación y poda a un mismo problema es la misma",
        "Para un mismo problema, ramificación y poda explora siempre un número de nodos menor o igual que backtracking",
        "Backtracking inspecciona todo el espacio de soluciones de un problema mientras que Ramificación y poda no"
      ],
      "solution": 2
    },
    {
      "title": "Si para resolver un mismo problema usamos un algoritmo de vuelta atrás y lo modificamos mínimamente para convertirlo en un algoritmo de ramificación y poda, ¿qué cambiamos realmente?",
      "choices": [
        "Cambiamos la función que damos a la cota pesimista",
        "La comprobación de las soluciones factibles: en ramificación y poda no es necesario puesto que sólo genera nodos factibles",
        "Aprovechamos mejor las cotas optimistas"
      ],
      "solution": 2
    },
    {
      "title": "Backtracking genera las soluciones posibles al problema:",
      "choices": [
        "Mediante el recorrido en profundidad del árbol que representa el espacio de soluciones",
        "Mediante el recorrido en anchura del árbol que representa el espacio de soluciones",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "En un problema resuelto por backtracking, el conjunto de valores que pueden tomar las componentes de la tupla solución, ha de ser:",
      "choices": ["Infinito", "Continuo", "Finito"],
      "solution": 2
    },
    {
      "title": "Cuando la descomposición recursiva de un problema da lugar a subproblemas de tamaño similar, ¿qué esquema promete ser más apropiado?",
      "choices": [
        "Programación dinámica",
        "Divide y vencerás, siempre que se garantice que los subproblemas no son del mismo tamaño",
        "El método voraz"
      ],
      "solution": 0
    },
    {
      "title": "El uso de funciones de cota en ramificación y poda...",
      "choices": [
        "Puede reducir el número de instancias del problema que pertenecen al caso peor",
        "Garantiza que el algoritmo va a ser más eficiente ante cualquier instancia del problema",
        "Transforma en polinómicas complejidades que antes eran exponenciales"
      ],
      "solution": 0
    },
    {
      "title": "Si un problema de optimización lo es para una función que toma valores continuos",
      "choices": [
        "La programación dinámica iterativa siempre es mucho más eficiente que la programación dinámica recursiva en cuanto al uso de memoria",
        "El uso de memoria de la programación dinámica iterativa y de la programación dinámica recursiva es el mismo independientemente de si el dominio es discreto o continuo",
        "La programación dinámica recursiva puede resultar mucho más eficiente que la programación dinámica iterativa en cuanto al uso de memoria"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(f(n)\\in\\Omicron(n^3)\\), ¿puede pasar que \\(f(n)\\in\\Omicron(n^2)\\)?",
      "choices": [
        "No, porque \\(n^3\\) no \\(\\in\\Omicron(n^2)\\)",
        "Es perfectamente posible, ya que \\(\\Omicron(n^2)\\sube\\Omicron(n^3)\\)",
        "Sólo para valores bajos de \\(n\\)"
      ],
      "solution": 1
    },
    {
      "title": "Sea la siguiente relación de recurrencia\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nSi \\(T(n)\\in\\Omicron(n^2)\\), ¿en cuál de estos tres casos nos podemos encontrar?",
      "choices": ["\\(g(n)=1\\)", "\\(g(n)=n^2\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "La solución recursiva ingenua (pero correcta) a un problema de optimización llama más de una vez a la función con los mismos parámetros. Una de las siguientes tres afirmaciones es falsa.",
      "choices": [
        "Se puede mejorar la eficiencia del algoritmo guardando en una tabla el valor devuelto para cada conjunto de parámetros de cada llamada cuando ésta se produce por primera vez",
        "Se puede mejorar la eficiencia del algoritmo convirtiendo el algoritmo recursivo directamente en iterativo sin cambiar su funcionamiento básico",
        "Se puede mejorar la eficiencia del algoritmo definiendo de antemano el orden en el que se deben calcular las soluciones a los subproblemas y llenando una tabla en ese orden"
      ],
      "solution": 1
    },
    {
      "title": "Un problema de tamaño n puede transformarse en tiempo \\(\\Omicron(n^2)\\) en otro de tamaño \\(n-1\\). Por otro lado, la solución al problema cuando la talla es 1 requiere un tiempo constante. ¿Cuál de estas clases de coste temporal asintótico es la más ajustada?",
      "choices": ["\\(\\Omicron(n^3)\\)", "\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Cuando se usa un algoritmo voraz para abordar la resolución de un problema de optimización por selección discreta (es decir, un problema para el cual la solución consiste en encontrar un subconjunto del conjunto de elementos que optimiza una determinada función), ¿cuál de estas tres cosas es imposible que ocurra?",
      "choices": [
        "Que la solución no sea la óptima",
        "Que el algoritmo no encuentre ninguna solución",
        "Que se reconsidere la decisión ya tomada anteriormente respecto a la selección de un elemento a la vista de la decisión que se debe tomar en el instante actual"
      ],
      "solution": 2
    },
    {
      "title": "Uno de estos tres problemas no tiene una solución eficiente que siga el esquema de programación dinámica",
      "choices": [
        "El problema de la mochila discreta",
        "El problema de las torres de Hanoi",
        "El problema de cortar un tubo de longitud n en segmentos de longitud entera entre 1 y n de manera que se maximice el precio de acuerdo con una tabla que da el precio para cada longitud"
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál de estos tres problemas de optimización no tiene, o no se le conoce, una solución voraz (greedy) que es óptima?",
      "choices": [
        "El problema de la mochila discreta",
        "El árbol de cobertura de coste mínimo de un grafo conexo",
        "El problema de la mochila continua o con fraccionamiento"
      ],
      "solution": 0
    },
    {
      "title": "Cuál de los siguientes algoritmos proveería una cota pesimista para el problema de encontrar el camino más corto entre dos ciudades (se supone que el grafo es conexo)",
      "choices": [
        "Calcular la distancia geométrica (en línea recta) entre la ciudad origen y destino",
        "Para todas las ciudades que son alcanzables en un paso desde la ciudad inicial, sumar la distancia a dicha ciudad y la distancia geométrica hasta la ciudad destino",
        "Calcular la distancia recorrida moviéndose al azar por el grafo hasta llegar (por azar) a la ciudad destino"
      ],
      "solution": 2
    },
    {
      "title": "Dado un problema de optimización cualquiera, ¿la estrategia de vuelta atrás garantiza la solución óptima?",
      "choices": [
        "Sí, siempre que el dominio de las decisiones sea discreto o discretizable y además se empleen mecanismos de poda basados en la mejor solución hasta el momento",
        "Sí, puesto que ese método analiza todas las posibilidades",
        "Es condición necesaria que el dominio de las decisiones sea discreto o discretizable y que el número de decisiones a tomar esté acotado"
      ],
      "solution": 2
    },
    {
      "title": "¿Para cuál de estos problemas de optimización existe una solución voraz?",
      "choices": [
        "El árbol de recubrimiento mínimo para un grafo no dirigido con pesos",
        "El problema de la mochila discreta",
        "El problema de la asignación de coste mínimo de n tareas a trabajadores cuando el coste de asignar la tarea \\(i\\) al trabajador \\(j\\), \\(C_{'{'}ij{'}'}\\) está tabulado en una matriz"
      ],
      "solution": 0
    },
    {
      "title": "La complejidad temporal en el mejor de los casos",
      "choices": [
        "Es el tiempo que tarda el algoritmo en resolver el problema de tamaño o talla más pequeña que se le puede presentar",
        "Es una función del tamaño o talla del problema que tiene que estar definida para todos los posibles valores de ésta",
        "Las otras dos opciones son ciertas"
      ],
      "solution": 1
    },
    {
      "title": "Garantiza el uso de una estrategia “divide y vencerás\" la existencia de una solución de complejidad temporal polinómica a cualquier problema?",
      "choices": [
        "Sí, pero siempre que la complejidad temporal conjunta de las operaciones de descomposición del problema y la combinación de las soluciones sea polinómica",
        "No",
        "Sí, en cualquier caso"
      ],
      "solution": 1
    },
    {
      "title": "Decide cuál de estas tres es la cota pesimista más ajustada al valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de la mochila discreta que se obtiene usando un algoritmo voraz basado en el valor específico de los objetos",
        "El valor de una mochila que contiene todos los objetos aunque se pase del peso máximo permitido",
        "El valor de la mochila continua correspondiente"
      ],
      "solution": 0
    },
    {
      "title": "Al resolver el problema del viajante de comercio mediante vuelta atrás, ¿cuál de estas cotas optimistas se espera que pueda mejorar el árbol de búsqueda?",
      "choices": [
        "Se resuelve el resto del problema usando un algoritmo voraz que añade cada vez al camino el vértice más cercano al último añadido.",
        "Se ordenan las aristas restantes de menor a mayor distancia y se calcula la suma de las k aristas más cortas, donde k es el número de saltos que nos quedan por dar.",
        "Se multiplica k por la distancia de la arista más corta que nos queda por considerar, donde k es el número de saltos que nos quedan por dar."
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades. Para ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela [por ejemplo, -1] si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. También se conocen las coordenadas geográficas de cada ciudad y por tanto la distancia geométrica (en línea recta) entre cada par de ciudades. Se pretende acelerar la búsqueda de un algoritmo de ramificación y poda priorizando los nodos vivos (ciudades) que estén a menor distancia geográfica de la ciudad objetivo.",
      "choices": [
        "El nuevo algoritmo no garantiza que vaya a ser más rápido para todas las instancias del problema posibles.",
        "Esta estrategia no asegura que se obtenga el camino más corto.",
        "El nuevo algoritmo siempre será más rápido"
      ],
      "solution": 0
    },
    {
      "title": "En algoritmos de ramificación y poda:",
      "choices": [
        "Una cota optimista no es necesariamente un valor insuperable; si no lo fuera, se podría podar el nodo que conduce a la solución óptima.",
        "Una cota optimista es necesariamente un valor alcanzable; sin embargo, si no lo fuera, no estaría garantizado que se encuentre la solución óptima.",
        "Una cota pesimista es el máximo valor que puede alcanzarse por cualquier nodo factible que no sea el óptimo."
      ],
      "solution": 0
    },
    {
      "title": "La complejidad en el mejor de los casos de un algoritmo de ramificación y poda",
      "choices": [
        "Es siempre exponencial con el número de decisiones a tomar",
        "Suele ser polinómica con el número de alternativas por cada decisión",
        "Puede ser polinómica con el número de decisiones a tomar"
      ],
      "solution": 2
    },
    {
      "title": "El valor que se obtiene con el método voraz para el problema de la mochila discreta es...",
      "choices": [
        "Una cota superior para el valor óptimo",
        "Una cota inferior para el valor óptimo, pero que nunca coincide con este",
        "Una cota inferior para el valor óptimo que a veces puede ser igual a este"
      ],
      "solution": 2
    },
    {
      "title": "En el esquema de vuelta atrás el orden en el que se van asignando los distintos valores a las componentes del vector que contendrá la solución",
      "choices": [
        "Las otras dos opciones son ciertas",
        "Puede ser relevante si se utilizan mecanismos de poda basados en estimaciones optimistas",
        "Es irrelevante si no se utilizan mecanismos de poda basados en la mejor solución hasta el momento"
      ],
      "solution": 0
    },
    {
      "title": "La mejor solución que se conoce para el problema de la mochila continua sigue el esquema",
      "choices": ["Divide y vencerás", "Voraz", "Ramificación y poda"],
      "solution": 1
    },
    {
      "title": "Sea A una matriz cuadrada \\(n\\times n\\). Se trata de buscar una permutación de las columnas tal que la suma de los elementos de la diagonal de la matriz resultante sea mínima. Indicad cuál de las siguientes afirmaciones es falsa.",
      "choices": [
        "Si se construye una solución al problema basada en el esquema de ramificación y poda, una buena elección de cotas optimistas y pesimistas podría evitar la exploración de todas las permutaciones posibles.",
        "La complejidad temporal de la mejor solución posible al problema es \\(\\Omicron(n^2)\\)",
        "La complejidad temporal de la mejor solución posible al problema es \\(\\Omicron(n!)\\)"
      ],
      "solution": 1
    },
    {
      "title": "En una cuadrícula se quiere dibujar el contorno de un cuadrado de n casillas de lado. ¿Cuál será la complejidad temporal del mejor algoritmo que pueda existir?",
      "choices": [
        "\\(\\Omicron(\\sqrt{'{'}n{'}'})\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Dado un problema de optimización, el método voraz...",
      "choices": [
        "Siempre obtiene la solución óptima",
        "Siempre obtiene una solución factible",
        "Garantiza la solución óptima solo para determinados problemas"
      ],
      "solution": 2
    },
    {
      "title": "Di cuál de estos tres algoritmos no es un algoritmo de \"divide y vencerás\":",
      "choices": ["Quicksort", "Mergesort", "El algoritmo de Prim"],
      "solution": 2
    },
    {
      "title": "Cuando se resuelve el problema de la mochila discreta usando la estrategia de vuelta atrás, ¿puede ocurrir que se tarde menos en encontrar la solución óptima si se prueba primero a meter cada objeto antes de no meterlo?",
      "choices": [
        "No, ya que en cualquier caso se deben explorar todas las soluciones factibles",
        "Sí, pero sólo si se usan cotas optimistas para podar el árbol de búsqueda",
        "Sí, tanto si se usan cotas optimistas para podar el árbol de búsqueda como si no"
      ],
      "solution": 1
    },
    {
      "title": "Dadas las siguientes funciones, se quiere reducir la complejidad temporal de la función \\(g\\) usando programación dinámica iterativa. ¿Cuál sería la complejidad espacial?<pre><code>// Precondición: {'{'} 0 <= i < v.size(); i < j <= v.size() {'}'}\nunsigned f(const vector<unsigned> &v, unsigned i, unsigned j) {'{'}\n\tif(i == j+1)\n\t\treturn v[i];\n\tunsigned sum = 0;\n\tfor(unsigned k = 0; k < j-i; k++)\n\t\tsum += f(v, i, i+k+1) + f(v, i+k+1, j);\n\treturn sum;\n{'}'}\n\nunsigned g(const vector<unsigned> &v) {'{'}\n\treturn f(v, v.begin(), v.end());\n{'}'}</code></pre>",
      "choices": ["Cuadrática", "Exponencial", "Cúbica"],
      "solution": 0
    },
    {
      "title": "En un problema de optimización, si el dominio de las decisiones es un conjunto infinito,",
      "choices": [
        "Es probable que a través de programación dinámica se obtenga un algoritmo eficaz que lo solucione",
        "Una estrategia voraz puede ser la única alternativa",
        "Podremos aplicar el esquema vuelta atrás siempre que se trate de un conjunto infinito numerable"
      ],
      "solution": 1
    },
    {
      "title": "Si para resolver un mismo problema usamos un algoritmo de vuelta atrás y lo modificamos minimamente para convertirlo en un algoritmo de ramificación y poda, ¿qué cambiamos realmente?",
      "choices": [
        "El algoritmo puede aprovechar mejor las cotas optimistas",
        "Cambiamos la función que damos a la cota pesimista",
        "La comprobación de las soluciones factibles: en ramificación y poda no es necesario puesto que sólo genera nodos factibles"
      ],
      "solution": 0
    },
    {
      "title": "¿Cual de estos problemas tiene una solución eficiente utilizando programación dinámica?",
      "choices": [
        "La mochila discreta sin restricciones adicionales",
        "El problema del cambio",
        "El problema de la asignación de tareas"
      ],
      "solution": 1
    },
    {
      "title": "El siguiente programa resuelve el problema de cortar un tubo de longitud n en segmentos de longitud entera entre 1 y n de manera que se maximice el precio de acuerdo con una tabla que da el precio para cada longitud, pero falta un trozo. ¿Qué debería ir en lugar de XXXXXXX?<pre><code>void fill(price r[]) {'{'}\n\tfor (index i=0; i <= n; i++) r[i] = -1;\n{'}'}\n\nprice cutrod(price p[], r[], length n) {'{'}\nprice q;\nif (r[n]>=0) return r[n];\nif (n==0) q=0;\nelse {'{'}\n\tq=-1;\n\tfor (index i=1; i<=n; i++)\n\tq=max(q,p[i]+cutrod(XXXXXXX));\n{'}'}\nr[n]=q;\nreturn q;\n{'}'}</code></pre>",
      "choices": ["p,r.n-r[n]", "p,r-1,1", "p,r,n-i"],
      "solution": 2
    },
    {
      "title": "En los algoritmos de ramificación y poda, ¿el valor de una cota pesimista es mayor que el valor de una cota optimista? (Se entiende que ambas cotas se aplican sobre el mismo nodo)",
      "choices": [
        "No, nunca es así",
        "En general sí, si se trata de un problema de maximización, aunque en ocasiones ambos valores pueden coincidir",
        "En general sí, si se trata de un problema de minimización, aunque en ocasiones ambos valores pueden coincidir"
      ],
      "solution": 2
    },
    {
      "title": "Una de estas tres situaciones no es posible:",
      "choices": [
        "\\(f(n)\\in\\Omicron(n)\\) y \\(f(n)\\in\\Omega(1)\\)",
        "\\(f(n)\\in\\Omega(n^2)\\) y \\(f(n)\\in\\Omicron(n)\\)",
        "\\(f(n)\\in\\Omicron(n)\\) y \\(f(n)\\in\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "La mejora que en general aporta la programación dinámica frente a la solución ingenua se consigue gracias al hecho de que",
      "choices": [
        "En la solución ingenua se resuelve pocas veces un número relativamente grande de subproblemas distintos",
        "El número de veces que se resuelven los subproblemas no tiene nada que ver con la eficiencia de los problemas resueltos mediante programación dinámica",
        "En la solución ingenua se resuelve muchas veces un número relativamente pequeño de subproblemas distintos"
      ],
      "solution": 2
    },
    {
      "title": "La versión de Quicksort que utiliza como pivote el elemento del vector que ocupa la primera posición...",
      "choices": [
        "Se comporta mejor cuando el vector ya está ordenado",
        "No presenta caso mejor y peor para instancias del mismo tamaño",
        "Se comporta peor cuando el vector ya está ordenado"
      ],
      "solution": 2
    },
    {
      "title": "En el esquema de vuelta atrás, los mecanismos de poda basados en la mejor solución hasta el momento...",
      "choices": [
        "Las otras dos opciones son ciertas",
        "Garantizan que no se va a explorar nunca todo el espacio de soluciones posibles",
        "Pueden eliminar soluciones parciales que son factibles"
      ],
      "solution": 2
    },
    {
      "title": "Un algoritmo recursivo basado en el esquema divide y vencerás...",
      "choices": [
        "Nunca tenderá una complejidad exponencial.",
        "Las dos anteriores son ciertas.",
        "Será más eficiente cuanto más equitativa sea la división en subproblemas."
      ],
      "solution": 2
    },
    {
      "title": "Se quieren ordenar números distintos comprendidos entre 1 y \\(n\\). Para ello se usa un array de \\(n\\) booleanos que se inicializan primero a false. A continuación se recorren los d números cambiando los valores del elemento del vector de booleanos correspondiente a su número a true. Por último se recorre el vector de booleanos escribiendo los índices de los elementos del vector de booleanos que son true. ¿Es este algoritmo más rápido (asintóticamente) que el mergesort?",
      "choices": [
        "Sí, ya que el mergesort es \\(\\Omicron(n\\log(n))\\) y este es \\(\\Omicron(n)\\)",
        "No, ya que este algoritmo ha de recorrer varias veces el vector de booleanos",
        "Sólo si \\(d\\log(d)>kn\\) (donde \\(k\\) es una constante que depende de la implementación)"
      ],
      "solution": 2
    },
    {
      "title": "¿En ramificación y poda, tiene sentido utilizar la cota optimista de los nodos como criterio para ordenar la lista de nodos vivos?",
      "choices": [
        "No, la cota optimista sólo se utiliza para determinar si una n-tupla es prometedora",
        "Sí, aunque no es una garantía de que sea una buena estrategia de búsqueda",
        "Sí, en el caso de que se ordene la lista de nodos vivos, siempre debe hacerse según el criterio de la cota optimista"
      ],
      "solution": 1
    },
    {
      "title": "En el esquema de vuelta atrás, los mecanismos de poda basados en la mejor solución hasta el momento:",
      "choices": [
        "Pueden eliminar vectores que representan posibles soluciones factibles",
        "Garantizan que no se va a explorar todo el espacio de soluciones posibles",
        "Las otras dos opciones son ambas verdaderas"
      ],
      "solution": 0
    },
    {
      "title": "Se desea obtener todas las permutaciones de una lista compuesta por n elementos. ¿Qué esquema es el más adecuado?",
      "choices": [
        "Divide y vencerás, puesto que la división en sublistas se podría hacer en tiempo constante",
        "Vuelta atrás, es el esquema más eficiente para este problema",
        "Ramificación y poda, puesto que con buenas funciones de cota es más eficiente que vuelta atrás"
      ],
      "solution": 1
    },
    {
      "title": "En ausencia de cotas optimistas y pesimistas, la estrategia de vuelta atrás...",
      "choices": [
        "No recorre todo el árbol si hay manera de descartar subárboles que representan conjuntos de soluciones no factibles",
        "Debe recorrer siempre todo el árbol",
        "No se puede usar para resolver problemas de optimización"
      ],
      "solution": 0
    },
    {
      "title": "El esquema voraz...",
      "choices": [
        "Garantiza encontrar una solución a cualquier problema, aunque puede que no sea óptima",
        "Puede que no encuentre una solución pero si lo hace se garantiza que es óptima",
        "Las otras dos opciones son ambas falsas"
      ],
      "solution": 2
    },
    {
      "title": "Un algoritmo recursivo basado en el esquema divide y vencerás",
      "choices": [
        "Las otras dos opciones son ambas verdaderas",
        "Alcanza su máxima eficiencia cuando el problema de tamaño n se divide en a problemas de tamaño \\(\\frac{'{'}n{'}'}{'{'}a{'}'}\\)",
        "Nunca tendrá un coste temporal asintótico (0 complejidad temporal) exponencial"
      ],
      "solution": 1
    },
    {
      "title": "Cuando la descomposición de un problema de lugar a subproblemas de tamaño similar al original, muchos de los cuales se repiten, ¿qué esquema es a priori más apropiado?",
      "choices": ["Programación dinámica", "Divide y vencerás", "Ramificación y poda"],
      "solution": 0
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, ¿se puede aplicar un esquema de programación dinámica para obtener un camino de salida?",
      "choices": [
        "No, para garantizar que se encuentra un camino de salida hay que aplicar métodos de búsqueda exhaustiva como vuelta atrás o ramificación y poda",
        "Sí, en caso de existir con este esquema siempre se puede encontrar un camino de salida",
        "No, con este esquema se puede conocer el número total de caminos distintos que conducen a la salida pero no se puede saber la composición de ninguno de ellos"
      ],
      "solution": 1
    },
    {
      "title": "Se desea resolver el problema de la potencia enésima (\\(x^n\\)), asumiendo que \\(n\\) es par y que se utilizará la siguiente recurrencia:\n\\(pot(x, n) = pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'}) * pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'})\\) ¿Qué esquema resulta ser más eficiente en cuanto al coste temporal?",
      "choices": [
        "En este caso tanto programación dinámica como divide y vencerás resultan ser equivalentes en cuanto a la complejidad temporal",
        "Programación dinámica",
        "Divide y vencerás"
      ],
      "solution": 1
    },
    {
      "title": "Decide cuál de estas tres es la cota optimista más ajustada al valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de una mochila que contiene todos los objetos aunque se pase del peso máximo permitido",
        "El valor de la mochila continua correspondiente",
        "El valor de la mochila discreta que se obtiene usando un algoritmo voraz basado en el valor específico de los objetos"
      ],
      "solution": 1
    },
    {
      "title": "Una de las prácticas de laboratorio consistió en el cálculo empírico de la complejidad temporal promedio del algoritmo de ordenación de vectores Quicksort tomando como centinela el elemento del vector que ocupa la posición central. ¿Cuál es el orden de complejidad que se obtuvo?",
      "choices": ["\\(n^2\\)", "\\(n\\log(n)\\)", "\\(n\\log^2(n)\\)"],
      "solution": 1
    },
    {
      "title": "¿Qué se deduce de \\(f(n)\\) y \\(g(n)\\) si se cumple \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=k\\)?",
      "choices": [
        "\\(g(n)\\in\\Omicron(f(n))\\) pero \\(f(n)\\notin\\Omicron(g(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) y \\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) pero \\(g(n)\\notin\\Omicron(f(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, se desea saber el número de caminos distintos desde la casilla inicial \\((1, 1)\\) hasta la casilla \\((n, m)\\) y para ello se aplica un esquema de divide y vencerás. ¿Cuál sería la recurrencia apropiada para el caso general?",
      "choices": [
        "\\(nc(n, m) = nc(n - 1, m) + nc(n, m - 1) + nc(n - 1, m - 1)\\)",
        "\\(nc(n, m) = nc(n - 1, m) + nc(m - 1, n) + nc(n - 1, m - 1)\\)",
        "Ninguna de las otras dos recurrencias se corresponde con un esquema de divide y vencerás"
      ],
      "solution": 0
    },
    {
      "title": "Sea la siguiente relación de recurrencia:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nSi \\(T(n)\\in\\Omicron(n)\\), ¿en cuál de estos tres casos nos podemos encontrar?",
      "choices": [
        "\\(g(n)=\\sqrt{'{'}n{'}'}\\)",
        "\\(g(n)=\\log(n)\\)",
        "Las otras dos opciones son ambas ciertas"
      ],
      "solution": 2
    },
    {
      "title": "El esquema de vuelta atrás...",
      "choices": [
        "Garantiza que encuentra la solución óptima a cualquier problema de selección discreta",
        "Las otras dos opciones son ambas verdaderas",
        "Se puede aplicar a cualquier tipo de problema aunque el coste temporal es elevado"
      ],
      "solution": 0
    },
    {
      "title": "¿Qué ocurre si la cota pesimista de un nodo se corresponde con una solución que no es factible?",
      "choices": [
        "Que el algoritmo sería más lento pues se explorarían más nodos de los necesarios",
        "Nada especial, las cotas pesimistas no tienen por qué corresponderse con soluciones factibles",
        "Que el algoritmo sería incorrecto pues podría descartarse un nodo que conduce a la solución óptima"
      ],
      "solution": 2
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, se desea saber el número de caminos distintos desde la casilla inicial (1, 1) hasta la casilla (n, m) y para ello se aplica un esquema de programación dinámica. En cuanto a la complejidad temporal, ¿cuál es la mejora de la versión recursiva con memoización frente a la recursiva ingenua que se obtiene a partir del esquema divide y vencerás?",
      "choices": [
        "La mejora no está garantizada puesto que la versión recursiva con memoización podría ser peor que la obtenida a partir del esquema divide y vencerás.",
        "De una complejidad cuadrática que se obtendría con la ingenua se reduciría a lineal con la de memoización.",
        "De una complejidad exponencial que se obtendría con la ingenua se reduciría a polinómica con la de memoización"
      ],
      "solution": 2
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, se pretende conocer la longitud del camino de salida más corto. Para ella se aplica el esquema voraz con un criterio de selección que consiste en elegir primero el movimiento \"Este\" siempre que la casilla sea accesible. Si no lo es se descarta ese movimiento y se prueba con \"Sureste\" y por último, si este tampoco es posible, se escoge el movimiento \"Sur\". ¿Qué se puede decir del algoritmo obtenido?",
      "choices": [
        "Que en realidad no es un algoritmo voraz pues el criterio de selección no lo es",
        "Que es un algoritmo voraz pero sin garantía de solucionar el problema",
        "Que en realidad no es un algoritmo voraz pues las decisiones que se toman no deberían reconsiderarse"
      ],
      "solution": 0
    },
    {
      "title": "Dada la siguiente función:<pre><code>int exa(vector<int> &v) {'{'}\n\tint j, i=1, n=v.size();\n\n\tif (n>1) do {'{'}\n\t\tint x = v[i];\n\t\tfor(j=i; j>0 && v[j-1] > x; j++)\n\t\t\tv[j]=v[j-1];\n\t\tv[j]=x;\n\t\ti++;\n\t{'}'} while(i<n);\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(n)\\)",
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(1)\\)",
        "La complejidad temporal exacta es \\(\\Theta(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "¿Qué estrategia de búsqueda es a priori más apropiada en un esquema de vuelta atrás?",
      "choices": [
        "Explorar primero los nodos con mejor cota optimista",
        "Explorar primero los nodos que están más completados",
        "En el esquema de vuelta atrás no se pueden definir estrategias de búsqueda"
      ],
      "solution": 2
    },
    {
      "title": "Dado el problema de las torres de Hanoi resuelto mediante divide y vencerás, ¿cuál de las siguientes relaciones de recurrencia expresa mejor su complejidad temporal para el caso general, siendo n el número de discos?",
      "choices": ["\\(T(n)=T(n-1)+n\\)", "\\(T(n)=2T(n-1)+1\\)", "\\(T(n)=2T(n-1)+n\\)"],
      "solution": 1
    },
    {
      "title": "Si el coste temporal de un algoritmo es \\(T(n)\\), ¿cuál de las siguiente situaciones es imposible?",
      "choices": [
        "\\(T(n)\\in\\Omicron(n)\\) y \\(T(n)\\in\\Theta(n)\\)",
        "\\(T(n)\\in\\Theta(n)\\) y \\(T(n)\\in\\Omega(n^2)\\)",
        "\\(T(n)\\in\\Omega(n)\\) y \\(T(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Un tubo de n centímetros de largo se puede cortar en segmentos de 1 centímetro, 2 centímetros, etc. Existe una lista de los precios a los que se venden los segmentos de cada longitud. Una de las maneras de cortar el tubo es la que más ingresos nos producirá. Se quiere resolver el problema mediante vuelta atrás. ¿Cuál sería la forma más adecuada de representar las posibles soluciones?",
      "choices": [
        "Un vector de booleanos",
        "Una tabla que indique, para cada posición donde se va a cortar, cada uno de los posibles valores acumulados",
        "Un par de enteros que indiquen los cortes realizados y el valor acumulado"
      ],
      "solution": 0
    },
    {
      "title": "¿Cuál sería la complejidad temporal de la siguiente función tras aplicar programación dinámica?<pre><code>double f(int n, int m) {'{'}\n\tif(n == 0) return 1;\n\treturn m * f(n-1,m) * f(n-2,m);\n{'}'}</code></pre>",
      "choices": ["\\(\\Theta(n^2)\\)", "\\(\\Theta(n\\times m)\\)", "\\(\\Theta(n)\\)"],
      "solution": 2
    },
    {
      "title": "Dada la siguiente función: <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\tif (n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j;i<n;i++)\n\t\t\t\tsum+=v[i];\n\t\t\tif(j==0) sum=100;\n\t\t{'}'}\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>",
      "choices": [
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(n)\\)",
        "La complejidad temporal en el peor de los casos es \\(\\Omega(1)\\)",
        "La complejidad temporal en el peor de los casos es \\(\\Omega(n\\log(n))\\)"
      ],
      "solution": 0
    },
    {
      "title": "El coste temporal asintótico de insertar un elemento en un vector ordenado de forma que continue ordenado es:",
      "choices": ["\\(\\Omicron(\\log(n))\\)", "\\(\\Omega(n^2)\\)", "\\(\\Omicron(n)\\)"],
      "solution": 2
    },
    {
      "title": "Dado un problema de maximización resuelto mediante un esquema de ramificación y poda, ¿qué ocurre si la cota optimista resulta ser un valor excesivamente elevado?",
      "choices": [
        "Que se podría explorar menos nodos de los necesarios",
        "Que se podría podar el nodo que conduce a la solución óptima",
        "Que se podría explorar más nodos de los necesarios"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(f\\in\\Omega(g1)\\) y \\(f\\in\\Omega(g2)\\) entonces:",
      "choices": [
        "\\(f\\in\\Omega(g1*g2)\\)",
        "\\(f\\notin\\Omega(\\min(g1*g2))\\)",
        "\\(f\\in\\Omega(g1+g2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "¿Qué complejidad se obtiene a partir de la relación de recurrencia \\(T(n)=8T(\\frac{'{'}n{'}'}{'{'}2{'}'})+n^3\\) con \\(T(1)=\\Omicron(1)\\)?",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(n^3\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "En el problema del viajante de comercio queremos listar todas las soluciones factibles.",
      "choices": [
        "Lo más importante es conseguir una cota pesimista adecuada",
        "El orden en el que se exploran las soluciones parciales no es relevante; por ello, la técnica ramificación y poda no aporta nada con respecto a vuelta atrás",
        "La más adecuado sería usar una técnica de ramificación y poda ya que es muy importante el orden en el que se explorar las soluciones parciales"
      ],
      "solution": 1
    },
    {
      "title": "Dada la siguiente función donde \\(\\max(a,b)\\in\\Theta(1)\\):<pre><code>float exa(vector<float> &v, vector<int> &p, int P, int i) {'{'}\n\tfloat a, b;\n\tif (i>=0) {'{'}\n\t\tif (p[i] <= P)\n\t\t\ta = v[i]*exa(v,p,P-p[i],i-1);\n\t\telse a=0;\n\t\tb=exa(v,p,P,i-1);\n\t\treturn max(a,b);\n\t{'}'}\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(n^2)\\)",
        "La complejidad temporal en el peor de los casos es \\(\\Omicron(n^2)\\)",
        "La complejidad temporal en el mejor de los casos es \\(\\Omicron(2^n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "En el esquema de ramificación y poda, ¿qué estructura es la más adecuada si queremos realizar una exploración por niveles?",
      "choices": ["Cola de prioridad", "Cola", "Pila"],
      "solution": 1
    },
    {
      "title": "Dada la siguiente función:<pre><code>int exa(string &cad, int pri, int ult) {'{'}\n\tif(pri>=ult)\n\t\treturn 1;\n\telse\n\t\tif (cad[pri]==cad[ult])\n\t\t\treturn exa(cad, pri+1, ult-1);\n\t\telse\n\t\t\treturn 0;\n{'}'}</code></pre>¿Cuál es su complejidad temporal asintótica?",
      "choices": ["\\(\\Omicron(n)\\)", "\\(\\Omicron(\\log(n))\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, ¿cuál de las estrategias siguientes proveería de una cota optimista para ramificación y poda?",
      "choices": [
        "Suponer que en adelante todas las casillas del laberinto son accesibles",
        "Suponer que ya no se van a realizar más movimientos",
        "Las otras dos estrategias son ambas válidas"
      ],
      "solution": 2
    },
    {
      "title": "De las siguientes expresiones, o bien dos son verdaderas y una es falsa, o bien dos son falsas y una es verdadera. Marca la que (en este sentido) es distinta a las otras dos.",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(\\Omicron(2^{\\log(n)}\\sub\\Omicron(n^2))\\)",
        "\\(\\Theta(n)\\sub\\Theta(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "¿Qué nos proporciona la media entre el coste temporal asintótico en el peor caso y el coste temporal asintótico en el mejor caso?",
      "choices": [
        "El coste temporal promedio",
        "El coste temporal asintótico en el caso medio",
        "Nada de interés"
      ],
      "solution": 2
    },
    {
      "title": "Se desea ordenar una lista enlazada de n elementos haciendo uso del algoritmo Mergesort. En este caso, al tratarse de una lista, la complejidad temporal asintótica de realizar la división en subproblemas resulta ser lineal con el tamaño de esa lista. ¿Cuál sería entonces el coste temporal de realizar dicha ordenación?",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "Ninguna de las otras dos opciones es cierta"
      ],
      "solution": 1
    },
    {
      "title": "Dado el problema del laberinto con tres movimientos, se desea saber el número de caminos distintos desde la casilla inicial (1,1) hasta la casilla (n, m) y para ello se aplica el esquema programación dinámica para obtener un algoritmo lo más eficiente posible en cuanto a complejidad temporal y espacial. ¿Cuáles serían ambas complejidades?",
      "choices": [
        "Temporal \\(\\Theta(n\\times m)\\) y espacial \\(\\Theta(n\\times m)\\)",
        "Temporal \\(\\Theta(\\max{n}{m})\\) y espacial \\(\\Theta(\\max{n}{m})\\)",
        "Temporal \\(\\Theta(n\\times m)\\) y espacial \\(\\Theta(\\min{'{'}n{'}'}{'{'}m{'}'})\\)"
      ],
      "solution": 2
    },
    {
      "title": "De las siguientes afirmaciones marca la que es verdadera.",
      "choices": [
        "Las cotas pesimistas no son compatibles con un esquema de vuelta atrás",
        "En un esquema de vuelta atrás, las cotas pesimistas no tienen sentido si lo que se pretende es obtener todas las soluciones factibles",
        "El esquema de vuelta atrás no es compatible con el uso conjunto de cotas pesimistas y optimistas"
      ],
      "solution": 1
    },
    {
      "title": "Dado un problema de minimización resuelto mediante un esquema de ramificación y poda, ¿qué propiedad cumple una cota optimista?",
      "choices": [
        "Siempre es mayor o igual que la mejor solución posible alcanzada",
        "Asegura un ahorro en la comprobación de todas las soluciones factibles",
        "Las otras dos opciones son ambas falsas"
      ],
      "solution": 2
    },
    {
      "title": "Dada la siguiente función <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\t if(n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j; i<n; i++)\n\t\t\t\tsum=v[i];\n\t\t\tif (j==0) sum=100;\n\t\t{'}'};\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>Marca la respuesta correcta:",
      "choices": [
        "La complejidad temporal exacta es \\(\\Theta(n\\log(n))\\)",
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(n)\\)",
        "La complejidad temporal en el mejor de los casos es \\(\\Omega(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "¿Se puede reducir el coste temporal de un algoritmo recursivo almacenando los resultados devueltos por las llamadas recursivas?",
      "choices": [
        "No, sólo se puede reducir el coste convirtiendo el algoritmo recursivo en iterativo",
        "Sí, si se repiten llamadas a la función con los mismos argumentos",
        "No, ello no reduce el coste temporal ya que las llamadas recursivas se deben realizar de cualquier manera"
      ],
      "solution": 1
    },
    {
      "title": "De las siguientes expresiones, o bien dos son verdaderas y una es falsa, o bien dos son falsas y una es verdadera. Marca la que (en este sentido) es distinta a las otras dos.",
      "choices": [
        "\\(\\Theta(f)=\\Omicron(f)\\cap\\Omega(f)\\)",
        "\\(\\Omega(f)=\\Theta(f)\\cap\\Omicron(f)\\)",
        "\\(\\Omicron(f)=\\Omega(f)\\cap\\Theta(f)\\)"
      ],
      "solution": 0
    },
    {
      "title": "El algoritmo Quicksort divide el problema en dos subproblemas. ¿Cuál es la complejidad temporal asintótica de realizar esa división?",
      "choices": [
        "\\(\\Omega(n)\\) y \\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "La complejidad temporal de la solución de vuelta atrás al problema de la mochila discreta es:",
      "choices": [
        "Exponencial en el caso peor",
        "Cuadrática en el caso peor",
        "Exponencial en cualquier caso"
      ],
      "solution": 0
    },
    {
      "title": "En el problema del coloreado de grafos (mínimo número de colores necesarios para colorear todos los vértices de un grafo de manera que no queden dos adyacentes con el mismo color) resuelto mediante ramificación y poda, una cota optimista es el resultado de asumir que:",
      "choices": [
        "Se van a utilizar tantos colores distintos a los ya utilizados como vértices quedan por colorear",
        "Solo va a ser necesario un color más",
        "No se van a utilizar colores distintos a los ya utilizados"
      ],
      "solution": 2
    },
    {
      "title": "La versión Quicksort que utiliza como pivote el elemento del vector que ocupa la posición central",
      "choices": [
        "No presenta caso mejor y peor para instancias del mismo tamaño",
        "Se comporta peor cuando el vector ya está ordenado",
        "Se comporta mejor cuando el vector está ordenado"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) y \\(k\\ne0\\) ¿cuál de estas tres afirmaciones es falsa?",
      "choices": [
        "\\(f(n)\\in\\Omicron(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Tenemos un conjunto de n enteros positivos y queremos encontrar el subconjunto de tamaño m de suma mínima",
      "choices": [
        "Una técnica voraz daría una solución óptima",
        "Lo más adecuado sería usar una técnica de ramificación y poda, aunque en el peor caso el coste temporal asintótico (0 complejidad temporal) sería exponencial",
        "Para encontrar la solución habría que probar con todas las combinaciones posibles de m enteros, con lo que la técnica de ramificación y poda no aporta nada con respecto a vuelta atrás"
      ],
      "solution": 0
    },
    {
      "title": "¿Qué algoritmo es asintóticamente más rápido, Quicksort o Mergesort?",
      "choices": [
        "Son los dos igual de rápidos, ya que el coste temporal asintótico de ambos es \\(\\Omicron(n\\log(n))\\)",
        "Como su nombre indica, el Quicksort",
        "El Mergesort es siempre más rápido o igual (salvo una constante) que el Quicksort"
      ],
      "solution": 0
    },
    {
      "title": "Sea \\(f(n)\\) la solución de la relación de recurrencia \\(f(n)=2f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\) Indicad cuál de estas tres expresiones es cierta:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál de estas afirmaciones es cierta?",
      "choices": [
        "La memoización evita que un algoritmo recursivo resuelva repetidamente el mismo problema",
        "La ventaja de la solución de programación dinámica iterativa al problema de la mochila discreta es que nunca se realizan cálculos innecesarios",
        "Los algoritmos iterativos de programación dinámica utilizan memoización para evitar resolver de nuevo los mismos subproblemas que se vuelven a presentar"
      ],
      "solution": 0
    },
    {
      "title": "Sea \\(g(n)= \\sum_{'{'}i=0{'}'}^{'{'}K{'}'}a_in^i\\). ¿Cuál de las siguientes afirmaciones es falsa?",
      "choices": [
        "\\(g(n)\\in\\Omega(n^k)\\)",
        "Las otras dos afirmaciones son falsas",
        "\\(g(n)\\in\\Theta(n^k)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Indicad cuál de estas tres expresiones es falsa:",
      "choices": [
        "\\(\\Theta(n)\\cap\\Theta(n^2)\\)",
        "\\(\\Theta(n)\\cap\\Omicron(n)\\)",
        "\\(\\Theta(\\frac{'{'}n{'}'}{'{'}2{'}'})=\\Theta(n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Indica cual es el coste temporal asintótico (o complejidad temporal), en función de n, del programa siguiente: <pre><code>s=0; for(i=0; i<n; i++) for(j=i; j<n; j++) s+=n*i*j;</code></pre>",
      "choices": [
        "Es \\(\\Theta(n^2)\\)",
        "Es \\(\\Theta(n)\\)",
        "Es \\(\\Omicron(n^2)\\) pero no \\(\\Omega(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "¿Pertenece \\(3n^2\\) \\(\\Omicron(n^3)\\)?",
      "choices": ["No", "Sí", "Sólo para c = 1 y n = 5"],
      "solution": 1
    },
    {
      "title": "Los algoritmos de vuelta atrás que hacen uso de cotas optimistas generan soluciones posibles al problema mediante...",
      "choices": [
        "Un recorrido guiado por estimaciones de las mejores ramas del árbol que representan el espacio de soluciones",
        "Un recorrido guiado por una cola de prioridad de donde se extraen primero los nodos que representan los subárboles más prometedores del espacio de soluciones",
        "Un recorrido en profundidad del árbol que representa el espacio de soluciones"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=0\\)",
      "choices": [
        "\\(f(n)\\in\\Theta(g(n))\\)",
        "\\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(f\\in\\Theta(g1)\\) y \\(f\\in\\Theta(g2)\\)",
      "choices": [
        "\\(f\\in\\Theta(g1*g2)\\)",
        "\\(f\\in\\Theta(g1+g2)\\)",
        "\\(f\\notin\\Theta(\\max{g1,g2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "Se quiere reducir la complejidad temporal de la siguiente función haciendo uso de programación dinámica. ¿Cuál sería la complejidad temporal resultante?<pre><code>unsigned g(unsigned n, unsigned r) {'{'}\n\tif (r==0 || r==n)\n\t\treturn 1;\n\treturn g(n-1, r-1) + g(n-1, r);\n{'}'}</code></pre>",
      "choices": [
        "Se puede reducir hasta lineal",
        "Cuadrática",
        "La función no cumple con los requisitos necesarios para poder aplicar programación dinámica"
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál de estas afirmaciones es falsa?",
      "choices": [
        "Hay problemas de optimización en los cuales el método voraz sólo obtiene la solución óptima para algunas instancias y un subóptimo para muchas otras instancias",
        "Todos los problemas de optimización tienen una solución voraz que es óptima sea cual sea la instancia a resolver",
        "Hay problemas de optimización para los cuales se puede obtener siempre la solución óptima utilizando una estrategia voraz"
      ],
      "solution": 1
    },
    {
      "title": "Dada la relación de recurrencia:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rhoT(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(donde \\(p\\) y \\(a\\) son enteros mayores que 1 y \\(g(n)=n^k\\), ¿qué tiene qué ocurrir para que se cumpla \\(T(n)\\in\\Theta(n^k)\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p<a^k\\)", "\\(p=a^k\\)"],
      "solution": 1
    },
    {
      "title": "¿Cuál es la diferencia principal entre una solución de vuelta atrás y una solución de ramificación y poda para el problema de la mochila?",
      "choices": [
        "El orden de exploración de las soluciones",
        "El coste asintótico en el caso peor",
        "El hecho que la solución de ramificación y poda puede empezar con una solución subóptima voraz y la de vuelta atrás no"
      ],
      "solution": 0
    },
    {
      "title": "La complejidad temporal (o coste temporal asintótico) en el mejor de los casos...",
      "choices": [
        "Es una función de la talla, o tamaño del problema, que tiene que estar definida para todos los posibles valores de ésta",
        "S es el tiempo que tarda el algoritmo en resolver la talla más pequeña que se le puede presentar",
        "Las dos anteriores son verdaderas"
      ],
      "solution": 0
    },
    {
      "title": "Dado un problema de optimización, ¿cuándo se puede aplicar el método de vuelta atrás?",
      "choices": [
        "Es condición necesaria (aunque no suficiente) que el dominio de las decisiones sea discreto o discretizable",
        "Es condición necesaria y suficiente que el dominio de las decisiones sea discreto o discretizable",
        "No sólo es condición necesaria que el dominio de las decisiones sea discreto a discretizable; además, debe cumplirse que se puedan emplear mecanismos de poda basados en la mejor solución hasta el momento"
      ],
      "solution": 0
    },
    {
      "title": "La siguiente relación de recurrencia expresa la complejidad de un algoritmo recursivo, donde g(n) es una función polinómica:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nDi cuál de las siguientes afirmaciones es cierta:",
      "choices": [
        "Si \\(g(n)\\in\\Theta(n)\\) la relación de recurrencia representa la complejidad temporal en el caso mejor del algoritmo de ordenación Quicksort",
        "Si \\(g(n)\\in\\Theta(n)\\) la relación de recurrencia representa la complejidad temporal en el caso peor del algoritmo de ordenación Quicksort",
        "Si \\(g(n)\\in\\Theta(1)\\) la relación de recurrencia representa la complejidad temporal en el caso mejor del algoritmo de ordenación Quicksort"
      ],
      "solution": 0
    },
    {
      "title": "Un algoritmo recursivo basado en el esquema divide y vencerás...",
      "choices": [
        "Nunca tendrá una complejidad exponencial",
        "Será más eficiente cuanto más equitativa sea la división en subproblemas",
        "Las demás opciones son verdaderas"
      ],
      "solution": 1
    },
    {
      "title": "El coste temporal de un algoritmo se ajusta a la siguiente ecuación de recurrencia:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &n=0 \\\\ n+\\sum_{'{'}j=0{'}'}^{'{'}n-1{'}'}T(j) &n>1\\end{'{'}cases{'}'}\\)\n\n¿Qué coste temporal asintótico (o complejidad temporal) tendrá el algoritmo?",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 1
    },
    {
      "title": "Estudiad la relación de recurrencia:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rhoT(\\frac{'{'}n{'}'}{'{'}q{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(donde \\(p\\) y \\(q\\) son enteros mayores que 1). Di cuál de los siguientes esquemas algorítmicos produce de manera natural relaciones de recurrencia así.",
      "choices": ["Programación dinámica", "Divide y vencerás", "Ramificación y poda"],
      "solution": 1
    },
    {
      "title": "Cogemos el algoritmo de Mergesort y en lugar de dividir el vector en dos partes, lo dividimos en tres. Posteriormente combinamos las soluciones parciales. ¿Cuál sería la complejidad temporal asintótica de la combinación de las soluciones parciales?",
      "choices": [
        "\\(\\Theta(\\log n)\\)",
        "\\(\\Theta(n)\\)",
        "Ninguna de las otras dos opciones es cierta"
      ],
      "solution": 1
    },
    {
      "title": "Uno de estos tres problemas no tiene una solución trivial y eficiente que siga el esquema voraz",
      "choices": [
        "El problema de la mochila continua",
        "El problema de la mochila discreta sin limitación en la carga máxima de la mochila",
        "El problema del cambio"
      ],
      "solution": 2
    },
    {
      "title": "¿Qué se entiende por “tamaño del problema”?",
      "choices": [
        "El valor máximo que puede tomar una instancia cualquiera de ese problema",
        "El número de parámetros que componen el problema",
        "La cantidad de espacio en memoria que se necesita para codificar una instancia de ese problema"
      ],
      "solution": 2
    },
    {
      "title": "Si \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) y \\(k\\neq0\\), ¿cuál de estas tres afirmaciones es cierta?",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Omega(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Las relaciones de recurrencia...",
      "choices": [
        "Sirven para reducir el coste temporal de una solución cuando es prohibitivo",
        "Expresan recursivamente el coste temporal de un algoritmo",
        "Aparecen sólo cuando la solución sea del tipo divide y vencerás"
      ],
      "solution": 2
    },
    {
      "title": "Los algoritmos de ordenación Quicksort y Mergesort tienen en común:",
      "choices": [
        "Que se ejecutan en tiempo \\(\\Omicron(n)\\)",
        "Que aplican la estrategia de divide y vencerás",
        "Que ordenan el vector sin usar espacio adicional"
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál de estas tres expresiones es cierta?",
      "choices": [
        "\\(\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{\\log(n)})\\sube\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{\\log(n)})\\sub\\Omicron(2^n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "El coste temporal del algoritmo de ordenación por inserción es",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(n^2)\\)", "\\(\\Omicron(n)\\)"],
      "solution": 1
    },
    {
      "title": "Tenemos n sustancias diferentes en polvo y deseamos generar todas las distintas formas de mezclarlas con un peso total que no exceda un gramo, ya que nuestra balanza sólo cuenta hasta 0.1 gramos de precisión. ¿Puedo utilizar retroalimentación (vuelta atrás)?",
      "choices": [
        "No se puede debido a que las decisiones no son valores discretos.",
        "Sí se puede sin problemas.",
        "No se puede debido al número infinito de combinaciones."
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál es la complejidad temporal en el mejor de los casos de la siguiente función?<pre><code>void examen(vector<int> &v) {'{'}\n\tint i=0,j,x,n=v.size();\n\tbool permuta = 1;\n\twhile(n>0 && permuta) {'{'}\n\t\ti=i+1;\n\t\tpermuta=0;\n\t\tfor(j=n-1; j>=i; j--)\n\t\t\tif(v[j] < v[j-1]) {'{'}\n\t\t\t\tx=v[j];\n\t\t\t\tpermuta=1;\n\t\t\t\tv[j]=v[j-1];\n\t\t\t\tv[j-1]=x;\n\t\t\t{'}'}\n\t{'}'}\n{'}'}</code></pre>",
      "choices": ["Esta función no tiene caso mejor", "\\(\\Theta(n)\\)", "\\(\\Theta(1)\\)"],
      "solution": 1
    },
    {
      "title": "¿Cuál de estas afirmaciones es falsa?",
      "choices": [
        "Los algoritmos iterativos de programación dinámica utilizan memoización para evitar resolver de nuevo los mismos subproblemas que se vuelven a presentar",
        "La solución de programación dinámica iterativa al problema de la mochila discreta realiza cálculos innecesarios",
        "La memoización evita que un algoritmo recursivo ingenuo resuelva repetidamente el mismo problema"
      ],
      "solution": 0
    },
    {
      "title": "Sea la siguiente relación de recurrencia\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nSi \\(T(n)\\in\\Omicron(n)\\), ¿en cuál de estos tres casos nos podemos encontrar?",
      "choices": ["\\(g(n)=n^2\\)", "\\(g(n)=1\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "De las siguientes expresiones, o bien dos son verdaderas y una es falsa, o bien dos son falsas y una es verdadera. Marca la que (en este sentido) es distinta a las otras dos.",
      "choices": [
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log_2(n){'}'})\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(4^{\\log_2(n)})\\sube\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(2^{\\log_2(n)})\\sub\\Omicron(n^2)\\sub\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Si \\(f\\in\\Theta(g_1)\\) y \\(f\\in\\Theta(g_2)\\)",
      "choices": [
        "\\(f^2\\in\\Theta(g_1\\cdot g_2)\\)",
        "Las otras dos opciones son ambas ciertas",
        "\\(f\\in\\Theta(\\max{g_1,g_2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "La complejidad en el mejor de los casos de un algoritmo de ramificación y poda",
      "choices": [
        "Es siempre exponencial con el número de decisiones a tomar",
        "Puede ser polinómica con el número de decisiones a tomar",
        "Suele ser polinómica con el número de alternativas por cada decisión"
      ],
      "solution": 1
    },
    {
      "title": "El problema de la función compuesta mínima consiste en encontrar, a partir de un conjunto de funciones dadas, la secuencia mínima de composiciones de éstas que permita transformar un número n en otro m. Se quiere resolver mediante ramificación y poda. ¿Cuál sería la forma más adecuada de representar las posibles soluciones?",
      "choices": [
        "Mediante un vector de booleanos",
        "Mediante un vector de reales",
        "Este problema no se puede resolver usando ramificación y poda si no se fija una cota superior al número total de aplicaciones de funciones"
      ],
      "solution": 2
    },
    {
      "title": "La función \\(\\gamma\\) de un número semientero positivo (un número es semientero si al restarle 0.5 es entero) se define como<pre><code>double gamma(double n) {'{'}\n\tif(n == 0.5)\n\t\treturn sqrt(PI);\n\treturn n * gamma(n-1);\n{'}'}</code></pre>¿Se puede calcular usando programación dinámica iterativa?",
      "choices": [
        "No, ya que el índice del almacén sería un número real y no entero",
        "Sí, pero la complejidad temporal no mejora",
        "No, ya que no podríamos almacenar los resultados intermedios en el almacén"
      ],
      "solution": 1
    },
    {
      "title": "¿Cual de estas expresiones es falsa?",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(2n^2+3n+1\\in\\Omicron(n^3)\\)",
        "\\(n+n\\log(n)\\in\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Dada la relación de recurrencia:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ pT(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(donde \\(p\\) y \\(a\\) son enteros mayores que 1 y \\(g(n)=n^k\\)), ¿qué tiene que ocurrir para que se cumpla \\(T(n)\\in\\Theta(n^k\\log(n))\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p=a^k\\)", "\\(p < a^k\\)"],
      "solution": 1
    },
    {
      "title": "Ante un problema de optimización resuelto mediante backtracking, ¿Puede ocurrir que el uso de las cotas pesimistas y optimistas sea inútil, incluso perjudicial?",
      "choices": [
        "Según el tipo de cota, las pesimistas puede que no descarten ningún nodo pero el uso de cotas optimistas garantiza la reducción del espacio de búsqueda",
        "No, las cotas tanto optimistas como pesimistas garantizan la reducción del espacio de soluciones y por tanto la eficiencia del algoritmo",
        "Sí, puesto que es posible que a pesar de utilizar dichas cotas no se descarte ningún nodo"
      ],
      "solution": 2
    },
    {
      "title": "Di cuál de estos resultados de coste temporal asintótico es falsa:",
      "choices": [
        "La búsqueda binaria en un vector ordenado requiere en el peor caso un tiempo en \\(\\Omicron(\\log(n))\\)",
        "La ordenación de un vector usando el algoritmo Quicksort requiere en el peor caso un tiempo en \\(\\Omega(n^2)\\)",
        "La ordenación de un vector usando el algoritmo Mergesort requiere en el peor caso un tiempo en \\(\\Omega(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Un problema se puede resolver por Divide y Vencerás siempre que:",
      "choices": [
        "Cumpla el principio de optimalidad",
        "Cumpla el teorema de reducción",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "¿Con qué esquema de programación obtenemos algoritmos que calculan la distancia de edición entre dos cadenas?",
      "choices": ["Programación Dinámica", "Divide y Vencerás", "Ambos"],
      "solution": 0
    },
    {
      "title": "¿Qué esquema de programación es el adecuado para resolver el problema de la búsqueda binaria?",
      "choices": ["Divide y Vencerás", "Programación Dinámica", "Ninguno de los dos"],
      "solution": 0
    },
    {
      "title": "¿Cuándo utilizaremos programación dinámica en lugar de divide y vencerás?",
      "choices": [
        "Cuando se reduce el coste espacial",
        "Cuando se incrementa la eficiencia",
        "Cuando se incrementa la eficacia"
      ],
      "solution": 1
    },
    {
      "title": "Si n es el número de elementos del vector, el coste del algoritmo Mergesort es:",
      "choices": [
        "\\(\\Omicron(n^2)\\) y \\(\\Omega(n\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "\\(\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Dado el algoritmo de búsqueda binaria, supongamos que, en vez de dividir la lista de elementos en dos mitades del mismo tamaño, la dividamos en dos partes de tamaños 1/3 y 2/3. El coste de este algoritmo:",
      "choices": [
        "Es menor que el del original",
        "Es mayor que el del original",
        "Es el mismo que el original"
      ],
      "solution": 1
    },
    {
      "title": "Para que un problema de optimización se pueda resolver mediante programación dinámica es necesario que:",
      "choices": [
        "Cumpla el principio de optimalidad",
        "Cumpla el teorema de reducción",
        "Cumpla las dos anteriores"
      ],
      "solution": 0
    },
    {
      "title": "La serie de números de Fibonacci se define de la siguiente forma:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\n¿Qué implementación de entre las siguientes supone el menor coste?",
      "choices": [
        "Divide y vencerás",
        "Programación dinámica",
        "Ambas tienen el mismo coste asintótico"
      ],
      "solution": 1
    },
    {
      "title": "En programación dinámica, dónde almacenaremos los valores de los problemas resueltos?",
      "choices": [
        "En un vector bidimensional",
        "Depende del problema",
        "En un vector unidimensional"
      ],
      "solution": 1
    },
    {
      "title": "¿Qué esquema de programación es el adecuado para resolver el problema k-ésimo mínimo en un vector?",
      "choices": ["Programación dinámica", "Divide y vencerás", "Ninguno de los dos"],
      "solution": 1
    },
    {
      "title": "¿Qué esquema algorítmico utiliza el algoritmo de ordenación Quicksort?",
      "choices": ["Programación Dinámica", "Divide y Vencerás", "Backtracking"],
      "solution": 1
    },
    {
      "title": "Dada la solución recursiva al problema de encontrar el k-ésimo mínimo de un vector. Cada llamada recursiva, ¿cuántas nuevas llamadas recursivas genera?",
      "choices": ["Dos o ninguna", "Una o dos", "Una o ninguna"],
      "solution": 2
    },
    {
      "title": "Si aplicamos programación dinámica a un problema que también tiene solución por divide y vencerás podemos asegurar que:",
      "choices": [
        "El coste temporal se reduce y el espacial aumenta con respecto a la solución por DyV",
        "El coste temporal aumenta y el espacial se reduce con respecto a la solución por DyV",
        "Ninguna de las anteriores"
      ],
      "solution": 2
    },
    {
      "title": "Ante un problema que presenta una solución recursiva siempre podemos aplicar:",
      "choices": ["Divide y vencerás", "Programación Dinámica", "Cualquiera de las dos anteriores"],
      "solution": 0
    },
    {
      "title": "La serie de números de Fibonacci se define de la siguiente forma:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\nPara implementar esta función podemos emplear...",
      "choices": ["Divide y vencerás", "Programación dinámica", "Cualquiera de las dos anteriores"],
      "solution": 2
    },
    {
      "title": "La solución al problema de encontrar el k-ésimo mínimo de un vector pone en práctica la siguiente estrategia:",
      "choices": [
        "No ordena ningún elemento del vector",
        "Ordena parcialmente el vector",
        "Ordenar totalmente el vector"
      ],
      "solution": 1
    },
    {
      "title": "En cuál de los siguientes casos no se puede aplicar el esquema Divide y Vencerás:",
      "choices": [
        "Cuando los subproblemas son de tamaños muy diferentes",
        "Cuando el problema no cumple el principio de optimalidad",
        "Se puede aplicar en ambos casos"
      ],
      "solution": 2
    },
    {
      "title": "La programación dinámica, para resolver un problema, aplica la estrategia:",
      "choices": [
        "Se resuelven los problemas más pequeños y, combinando las soluciones, se obtienen las soluciones de problemas sucesivamente más grandes hasta llegar al problema original",
        "Se descompone el problema a resolver en subproblemas más pequeños, que se resuelven independientemente para finalmente combinar las soluciones de los subproblemas para obtener la solución del problema original",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "Supongamos el problema de la mochila resuelto mediante programación dinámica y particularizado para n elementos y un peso máximo transportable de P. ¿Es necesario calcular valores para toda la matriz auxiliar para obtener el resultado?",
      "choices": ["Sí", "No", "Depende de los valores de n y P"],
      "solution": 1
    },
    {
      "title": "Disponemos de dos cadenas de longitudes m y n. Si resolvemos el problema de la distancia de edición mediante programación dinámica, ¿de qué tamaño debemos definir la matriz que necesitaremos?",
      "choices": ["\\((m-1)\\times(n-1)\\)", "\\(m\\times n\\)", "\\((m+1)\\times(n+1)\\)"],
      "solution": 2
    },
    {
      "title": "Si n es el número de elementos de un vector. La solución de menor coste al problema de encontrar su k-ésimo mínimo tiene la siguiente complejidad:",
      "choices": [
        "\\(\\Omega(n)\\) y \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(n)\\) y \\(\\Omicron(n^2)\\)",
        "Ninguna de las dos"
      ],
      "solution": 1
    },
    {
      "title": "Si n es el número de elementos de un vector. Podemos encontrar una solución al problema de encontrar su k-ésimo que esté acotada superiormente por:",
      "choices": ["\\(\\Omicron(n^3)\\)", "\\(\\Omicron(n)\\)", "Ninguna de las anteriores"],
      "solution": 0
    },
    {
      "title": "Dada una solución recursiva a un problema, ¿cómo podemos evitar la resolución de los mismos subproblemas muchas veces?",
      "choices": [
        "Resolver los subproblemas de mayor a menor y guardar su resultado en una tabla, inicializándola con los problemas pequeños",
        "Resolver los subproblemas de mayor a menor y guardar su resultado en una tabla, inicializándola con los problemas más grandes",
        "Resolver los subproblemas de menor a mayor y guardar su resultado en una tabla, inicializándola con los problemas pequeños"
      ],
      "solution": 2
    },
    {
      "title": "Un problema de optimización cuya solución se puede expresar mediante una secuencia de decisiones cumple el principio de optimalidad si, dada una secuencia óptima:",
      "choices": [
        "Existe al menos una subsecuencia de esa solución que corresponde a la solución óptima de su subproblema asociado",
        "Existe una subsecuencia de esa solución que corresponde a la solución óptima de su subproblema asociado",
        "Cualquier subsecuencia de esa solución corresponde a la solución óptima de su subproblema asociado"
      ],
      "solution": 2
    },
    {
      "title": "Si n es el número de elementos de un vector, la solución de menor coste al problema de la búsqueda binaria tiene la siguiente complejidad:",
      "choices": [
        "\\(\\Omega(\\log(n))\\) y \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(1)\\) y \\(\\Omicron(\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "¿Cuál es el esquema de programación adecuado para resolver el problema k-ésimo mínimo en un vector?",
      "choices": ["Programación Dinámica", "Divide y Vencerás", "Ningún uno de los dos."],
      "solution": 1
    },
    {
      "title": "El problema de la mochila, ¿Puede solucionarse de forma óptima empleando la estrategia de divide y vencerás?",
      "choices": [
        "Sólo para el caso de la mochila con fraccionamiento",
        "Solo para el caso de la mochila sin fraccionamiento",
        "Sí, se puede aplicar para ambos casos"
      ],
      "solution": 1
    },
    {
      "title": "Un vector de enteros de tamaño n organizado como montículo (heap) tiene complejidad temporal en el mejor caso de borrar el primer elemento y reorganizarlo de:",
      "choices": [
        "Ninguna de las otras dos opciones es correcta",
        "Constantes con el tamaño del vector",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Di cuál de estos resultados de coste temporal asintótico es falsa:",
      "choices": [
        "La ordenación de un vector usando el algoritmo Quicksort requiere en el peor caso un tiempo en \\(\\Omega(n^2)\\)",
        "La ordenación de un vector usando el algoritmo Mergesort requiere en el peor caso un tiempo en \\(\\Omega(n^2)\\)",
        "La búsqueda binaria en un vector ordenado requiere en el peor caso un tiempo en \\(\\log(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "La versión Quicksort que utiliza como pivote el elemento del vector que ocupa la primer posición",
      "choices": [
        "Se comporta peor cuando el vector ya está ordenado",
        "Se comporta mejor cuando el vector está ya ordenado",
        "El hecho de que el vector estuviera previamente ordenado o no, no influye en la complejidad temporal de este algoritmo"
      ],
      "solution": 0
    },
    {
      "title": "De las siguientes expresiones, o bien dos son verdaderas y una falsa, o bien dos son falsas y una verdadera. Marca la que (en este sentido) es distinta a las otras dos.",
      "choices": [
        "\\(\\Theta(n^2)\\sub\\Theta(n^3)\\)",
        "\\(\\Omega(n^2)\\sub\\Omega(n^3)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Sea \\(f(n)\\) la solución de la relación de recurrencia \\(f(n)=2*f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\). Indicad cuál de estas tres expresiones es cierta:",
      "choices": [
        "\\(f(n)\\in\\Theta(n)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Se dispone de un vector de tamaño n cuyos elementos están de antemano organizados formando un montículo (heap). ¿Cuál sería la complejidad temporal de reorganizar el vector para que quede ordenado?",
      "choices": ["\\(\\Omicron(\\log(n))\\)", "\\(\\Omicron(n)\\)", "\\(\\Omicron(n\\log(n))\\)"],
      "solution": 2
    },
    {
      "title": "Indica cuál es la complejidad, en función de n, del fragmento siguiente:<pre><code>int a = 0;\nfor(int i = 0; i < n; i++)\n\tfor(int j = i; j > 0; j/=2)\n\t\ta += A[i][j];</code></pre>",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Sea f(n) la solución de la relación de recurrencia... \\(f(n)=2f(n-1)+1; f(1)=1\\)\nIndicad cuál de estas tres expresiones es cierta:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(2^n)\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    }
  ]
}
