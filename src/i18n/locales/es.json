{
  "questions": [
    {
      "title": "Sea \\(f(n)\\) la solución de la relación de recurrencia \\(f(n) = 2f(\\frac{'{'}n{'}'}{'{'}2{'}'}) + n, \\,f(1) = 1\\)",
      "choices": [
        "\\(f(n)\\in\\Theta(n^{'{'}2{'}'})\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades. Para ello se dispone de una tabla con la distancia entre los pares de ciudades donde hay carreteras o un valor centinela (por ejemplo, -1) si no las hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. También se conocen las coordenadas geográficas de cada ciudad y, por tanto, la distancia geográfica (en línea recta) entre cada par de ciudades. Se pretende acelerar la búsqueda de un algoritmo de ramificación y poda priorizando los nodos vivos (ciudades) que estén a menor distancia geográfica de la ciudad objetivo. Seleccione una: ",
      "choices": [
        "El nuevo algoritmo siempre será más rápido",
        "Esta estrategia no asegura que se obtenga el camino más corto",
        "El nuevo algoritmo solo será más rápido para algunas instancias del problema"
      ],
      "solution": 2
    },
    {
      "title": "Dadas las siguientes funciones, se quiere reducir la complejidad temporal de la función \\(g\\) usando programación dinámica iterativa. ¿Cuál sería la complejidad espacial?<pre><code>// Precondición: {'{'} 0 <= i < v.size(); i < j <= v.size() {'}'}\nunsigned f(const vector<unsigned> &v, unsigned i, unsigned j) {'{'}\n\tif(i == j+1)\n\t\treturn v[i];\n\tunsigned sum = 0;\n\tfor(unsigned k = 0; k < j-i; k++)\n\t\tsum += f(v, i, i+k+1) + f(v, i+k+1, j);\n\treturn sum;\n{'}'}\n\nunsigned g(const vector<unsigned> &v) {'{'}\n\treturn f(v, v.begin(), v.end());\n{'}'}</code></pre>",
      "choices": ["Cuadrática", "Exponencial", "Cúbica"],
      "solution": 0
    },
    {
      "title": "Tratándose de un problema de optimización, en la lista de nodos vivos de ramificación y poda...",
      "choices": [
        "Sólo se introducen nodos prometedores, es decir, nodos que pueden mejorar la mejor solución que se tiene en ese momento",
        "Puede haber nodos que no son prometedores",
        "Las otras dos opciones son ciertas"
      ],
      "solution": 2
    },
    {
      "title": "Se desea obtener todas las permutaciones de una lista compuesta por \\(n\\) elementos, ¿qué esquema es el más adecuado?",
      "choices": [
        "Divide y vencerás, puesto que la división en sublistas se podría hacer en tiempo constante",
        "Ramificación y poda, puesto que con buenas funciones de cota es más eficiente para este problema que vuelta atrás",
        "Vuelta atrás, para este problema no hay un esquema más eficiente"
      ],
      "solution": 2
    },
    {
      "title": "Al resolver el problema del viajante de comercio mediante vuelta atrás y asumiendo un grafo de \\(n\\) vértices totalmente conexo, ¿cuál de estas es una buena cota pesimista al iniciar la búsqueda?",
      "choices": [
        "Se ordenan las aristas restantes de menor a mayor distancia y se calcula la suma de las \\(n\\) aristas más cortas",
        "Se resuelve el problema usando un algoritmo voraz que añade cada vez al camino el vértice más cercano al último añadido",
        "Se multiplica \\(n\\) por la distancia de la arista más corta que nos queda por considerar"
      ],
      "solution": 1
    },
    {
      "title": "¿Para cuál de estos problemas de optimización existe una solución voraz?",
      "choices": [
        "El árbol de recubrimiento mínimo para un grafo no dirigido con pesos.",
        "El problema de la mochila discreta.",
        "El problema de la asignación de coste mínimo de \\(n\\) tareas a \\(n\\) trabajadores cuando el coste de asignar la tarea \\(i\\) al trabajador \\(j\\), \\(c_{'{'}ij{'}'}\\) está tabulado en una matriz."
      ],
      "solution": 0
    },
    {
      "title": "Si para resolver un mismo problema usamos un algoritmo de ramificación y poda y lo modificamos mínimamente para convertirlo en un algoritmo de vuelta atrás, ¿qué cambiamos realmente?",
      "choices": [
        "Provocamos que las cotas optimistas pierdan eficacia",
        "Cambiamos la función que damos a la cota pesimista",
        "Sería necesario comprobar si las soluciones son factibles o no puesto que ramificación y poda solo genera nodos factibles"
      ],
      "solution": 0
    },
    {
      "title": "¿Cuál es la diferencia principal entre una solución de vuelta atrás y una solución de ramificación y poda para el problema de la mochila?",
      "choices": [
        "El orden de exploración de las soluciones",
        "El hecho de que la solución de ramificación y poda puede empezar con una solución subóptima voraz y la de vuelta atrás no",
        "El coste asintótico en el peor caso"
      ],
      "solution": 0
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades. Para ello, se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras, o un valor centinela (por ejemplo, -1) si no las hay. Por lo tanto, para ir de la ciudad inicial a la final, es posible que haya que pasar por varias ciudades. Además, se conocen las coordenadas geográficas de cada ciudad y se desea utilizar la distancia geográfica (en línea recta) entre cada par de ciudades como cota para limitar la búsqueda en un algoritmo de vuelta atrás. ¿Qué tipo de cota sería?",
      "choices": [
        "Una cota pesimista",
        "Una cota optimista",
        "No se trataría de ninguna poda puesto que es posible que esa heurística no encuentre una solución factible."
      ],
      "solution": 1
    },
    {
      "title": "La ventaja de la estrategia de ramificación y poda sobre la vuelta atrás es que la primera genera las posibles soluciones al problema mediante...",
      "choices": [
        "Las otras dos opciones son verdaderas",
        "Un recorrido guiado por una cola de prioridad de la cual se extraen primero los nodos que representan los subárboles más prometedores del espacio de soluciones.",
        "Un recorrido guiado por estimaciones de las mejores ramas del árbol que representa el espacio de soluciones"
      ],
      "solution": 0
    },
    {
      "title": "La estrategia de vuelta atrás es aplicable a problemas de selección y optimización en los que:",
      "choices": [
        "El espacio de soluciones es un conjunto infinito",
        "El espacio de soluciones es un conjunto finito",
        "El espacio de soluciones puede ser tanto finito como infinito pero en este último caso debe ser al menos numerable"
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades.\npara ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela (por ejemplo, -1) si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. también se conocen las coordenadas geográficas de cada ciudad y por tanto la distancia geográfica (en línea recta) entre cada par de ciudades. para limitar la búsqueda en un algoritmo de vuelta atrás, se utiliza la solución de un algoritmo voraz basado en moverse en cada paso a la ciudad, de entre las posibles según el mapa de carreteras, que esté más cercana al destino según su distancia geográfica.\neste algoritmo voraz, ¿serviría como cota pesimista?",
      "choices": [
        "No, ya que no asegura que se encuentre una solución factible",
        "No, ya que en algunos casos puede dar distancias menores que la optima",
        "Sí, puesto que la distancia geográfica asegura que otra solución mejor no es posible"
      ],
      "solution": 0
    },
    {
      "title": "Cuando resolvemos un problema medialilte un esquema de ramificación y poda...",
      "choices": [
        "Las decisiones sólo pueden ser binarias",
        "Los valores entre los cuales se elige en cada una de las decisiones pueden formar un conjunto infinito",
        "Los valores entre los cuales se elige en cada una de las decisiones tienen que formar un conjunto finito"
      ],
      "solution": 2
    },
    {
      "title": "Cuando se resuelve un algoritmo de vuelta atrás un problema de \\(n\\) decisiones, en el que siempre hay como mínimo dos opciones para cada decisión, ¿cuál de las siguientes complejidades en el caso peor es la mejor que nos podemos encontrar?",
      "choices": ["\\(2^n\\)", "\\(\\Omicron(n^2)\\)", "\\(\\Omicron(n!)\\)"],
      "solution": 0
    },
    {
      "title": "La complejidad en el peor de los casos de un algoritmo de ramificación y poda...",
      "choices": [
        "Puede ser exponencial con el número de alternativas por cada decisión",
        "Es exponencial con el número de decisiones a tomar",
        "Puede ser polinómica con el número de decisiones a tomar"
      ],
      "solution": 1
    },
    {
      "title": "En ausencia de cotas optimista y pesimistas, la estrategia de vuelta atrás...",
      "choices": [
        "No se puede usar para resolver problemas de optimización",
        "No recorre todo el árbol si hay manera de descartar subárboles que representan conjuntos de soluciones no factibles",
        "Debe recorrer siempre todo el árbol"
      ],
      "solution": 1
    },
    {
      "title": "Se desea encontrar el camino más corto entre dos ciudades. Para ello se dispone de una tabla con la distancia entre los pares de ciudades en los que hay carreteras o un valor centinela (por ejemplo, -1) si no hay, por lo que para ir de la ciudad inicial a la final es posible que haya que pasar por varias ciudades. Para limitar la búsqueda en un algoritmo de vuelta atrás, se utiliza la solución de un algoritmo voraz basado en moverse en cada paso a la ciudad, de entre las posibles según el mapa de carreteras, que esté más cercana al destino en línea recta. ¿qué tipo de cota sería?",
      "choices": [
        "Sería una cota pesimista siempre que se tenga la certeza de que esa aproximación encuentra la solución factible",
        "Sería una cota optimista siempre que se tenga la certeza de que esa aproximación encuentra una solución factible",
        "Ninguna de las otras dos opciones"
      ],
      "solution": 0
    },
    {
      "title": "Decid cuál de estas tres no sirve como cota optimista para obtener el valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de la mochila discreta que se obtiene usando un algoritmo voraz basado en el valor específico de los objetos",
        "El valor de la mochila continua correspondiente",
        "El valor de una mochila que contiene todos los objetos aunque se pase del peso máximo permitido"
      ],
      "solution": 0
    },
    {
      "title": "La complejidad en el menor de los casos de un algoritmo de ramificación y poda...",
      "choices": [
        "Suele ser polinómica con el número de alternativas por cada decisión",
        "Es siempre exponencial con el número de decisiones a tomar",
        "Puede ser polinómica con el número de decisiones a tomar"
      ],
      "solution": 2
    },
    {
      "title": "¿Para qué sirven las cotas pesimistas en ramificación y poda?",
      "choices": [
        "Para descartar nodos basándose en la preferencia por algún otro nodo ya completado",
        "Para tener la certeza de que la cota optimista está bien calculada",
        "Para descartar nodos basándose en el beneficio esperado"
      ],
      "solution": 2
    },
    {
      "title": "En los algoritmos de ramificación y poda, ¿el valor de una cota pesimista es menor que el valor de una cota optimista?",
      "choices": [
        "Sí, siempre es así",
        "En general sí, si se trata de un problema de maximización, aunque en ocasiones ambos valores pueden coincidir",
        "En general sí, si se trata de un problema de minimización, aunque en ocasiones ambos valores pueden coincidir"
      ],
      "solution": 1
    },
    {
      "title": "La estrategia de ramificación y poda necesita cotas pesimistas...",
      "choices": [
        "Para determinar el orden de visita de los nodos en el árbol de soluciones",
        "Para verificar la factibilidad de una solución",
        "Solo si se utiliza para resolver problemas de optimización"
      ],
      "solution": 2
    },
    {
      "title": "En el esquema de vuelta atrás, los mecanismos de poda basados en la mejor solución hasta el momento...",
      "choices": [
        "Ambas afirmaciones anteriores son verdaderas",
        "Aseguran que no se explorará todo el espacio de soluciones posible",
        "Pueden eliminar soluciones parciales que son factibles"
      ],
      "solution": 2
    },
    {
      "title": "El uso de funciones de cota en ramificación y poda...",
      "choices": [
        "Asegura que el algoritmo será más eficiente en cualquier instancia del problema",
        "Puede disminuir el número de instancias del problema que caen en el peor caso",
        "Convierte complejidades exponenciales previas en polinómicas"
      ],
      "solution": 1
    },
    {
      "title": "Elige cuál de estas tres es la cota pesimista más ajustada para el valor óptimo de la mochila discreta:",
      "choices": [
        "El valor de la mochila continua correspondiente",
        "El valor de una mochila que contiene todos los objetos aunque exceda el peso máximo permitido",
        "El valor de la mochila discreta obtenido usando un algoritmo voraz basado en el valor específico de los objetos"
      ],
      "solution": 2
    },
    {
      "title": "En la estrategia de ramificación y poda...",
      "choices": [
        "Cada nodo tiene su propia cota optimista, mientras que la cota pesimista es común para todos los nodos",
        "Cada nodo tiene su propia cota pesimista y también su propia cota optimista",
        "Cada nodo tiene su propia cota pesimista, siendo la cota optimista común para todos los nodos"
      ],
      "solution": 1
    },
    {
      "title": "En los algoritmos de ramificación y poda...",
      "choices": [
        "Una cota optimista es necesariamente un límite superior inalcanzable; de lo contrario, se podría podar el nodo que lleva a la solución óptima",
        "Una cota optimista es necesariamente un valor alcanzable; de lo contrario, no se garantiza encontrar la solución óptima",
        "El uso de cotas pesimistas solo es efectivo cuando se cuenta con una posible solución inicial"
      ],
      "solution": 0
    },
    {
      "title": "Decide cuál de estas tres es la cota optimista que poda de manera más eficiente al utilizar la estrategia de vuelta atrás para resolver el problema de la mochila:",
      "choices": [
        "El valor de una mochila",
        "El valor óptimo de la mochila continua correspondiente",
        "El valor de la mochila discreta obtenido usando un algoritmo voraz basado en el valor específico del objeto"
      ],
      "solution": 1
    },
    {
      "title": "En los algoritmos de ramificación y poda, ¿el valor de una cota pesimista es mayor que el valor de una cota optimista? (considerando que ambas cotas se aplican al mismo nodo)",
      "choices": [
        "No, nunca es así",
        "En general sí, si se trata de un problema de maximización, aunque en ocasiones ambos valores pueden coincidir",
        "En general sí, si se trata de un problema de minimización, aunque en ocasiones ambos valores pueden coincidir"
      ],
      "solution": 2
    },
    {
      "title": "Dado cualquier problema de optimización, ¿la estrategia de vuelta atrás garantiza la solución óptima?",
      "choices": [
        "Es una condición necesaria que el dominio de decisiones sea discreto o discretizable y que el número de decisiones a tomar esté acotado",
        "Sí, siempre que el dominio de decisiones sea discreto o discretizable además y se empleen mecanismos de poda basados en la mejor solución hasta el momento",
        "Sí, ya que este método analiza todas las posibilidades"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la asignación de turnos.\nEstamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe busca encontrar una solución que satisfaga el máximo número de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya está creada, diseñar un algoritmo que resuelva el problema de manera óptima.",
      "choices": [
        "Óptima mediante backtracking",
        "Aproximada (subóptima) mediante algoritmo voraz",
        "Ambas"
      ],
      "solution": 2
    },
    {
      "title": "El tiempo de ejecución de un algoritmo de ramificación y poda depende de",
      "choices": [
        "La instancia del problema",
        "La función de selección de nodos para su expansión",
        "De ambos"
      ],
      "solution": 2
    },
    {
      "title": "Es un problema de optimización, si el dominio de las decisiones es un conjunto infinito.",
      "choices": [
        "Podemos aplicar el esquema vuelta atrás siempre que se trate de un conjunto infinito numerable",
        "Una estrategia voraz puede ser la única alternativa",
        "Es probable que a través de programación dinámica se obtenga un algoritmo eficaz que lo solucione"
      ],
      "solution": 1
    },
    {
      "title": "Backtracking es aplicable a problemas de selección y optimización en los que:",
      "choices": [
        "El espacio de soluciones es un conjunto finito",
        "En cualquiera de los casos",
        "El espacio de soluciones es un conjunto infinito"
      ],
      "solution": 0
    },
    {
      "title": "Bactracking es una técnica de resolución general de problemas basada en:",
      "choices": [
        "La búsqueda sistemática de soluciones",
        "La construcción directa de la solución",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "Voraz siempre da solución óptima:",
      "choices": [
        "A los dos",
        "Al problema de la mochila sin fraccionamiento",
        "Al problema de la mochila con fraccionamiento"
      ],
      "solution": 2
    },
    {
      "title": "El problema de la mochila, ¿encuentra su solución óptima empleando la estrategia voraz?:",
      "choices": [
        "Sólo para el caso de la mochila sin fraccionamiento",
        "En cualquiera de los casos anteriores",
        "Sólo para el caso de la mochila con fraccionamiento"
      ],
      "solution": 2
    },
    {
      "title": "El problema del viajante de comercio puede resolverse correctamente empleando estos esquemas de programación:",
      "choices": [
        "Sólo programación dinámica",
        "Empleando cualquiera de estos: Voraz y backtracking.",
        "Solo backtracking"
      ],
      "solution": 2
    },
    {
      "title": "En el método Voraz, aunque las decisiones son irreversibles, podemos asegurar que:",
      "choices": [
        "Siempre obtendremos una solución factible",
        "Siempre obtendremos la solución óptima",
        "Sólo obtendremos la solución óptima para algunos problemas"
      ],
      "solution": 2
    },
    {
      "title": "Al aplicar backtracking obtenemos la solución óptima a un problema:",
      "choices": [
        "Siempre",
        "Sólo cuando el problema cumple el principio de Optimalidad",
        "En algunos casos"
      ],
      "solution": 1
    },
    {
      "title": "Dado un problema resuelto mediante backtracking y mediante ramificación y poda, el coste computacional de la solución por ramificación y poda, en comparación con la de backtracking es:",
      "choices": ["Menor", "Igual", "Mayor"],
      "solution": 1
    },
    {
      "title": "El problema de la asignación de turnos.\nEstamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe pretende encontrar una solución para satisfacer el número máximo de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya existe, ¿qué algoritmo se debe diseñar para resolver el problema de forma óptima?",
      "choices": ["Backtracking", "Voraz", "Ambos"],
      "solution": 0
    },
    {
      "title": "Al aplicar vuelta atrás a la solución de problemas, obtenemos algoritmos con costes computacionales:",
      "choices": ["Exponenciales", "Polinómicos", "Los dos son correctos. Depende del problema"],
      "solution": 0
    },
    {
      "title": "Vuelta atrás se emplea en la resolución de problemas de optimización en los que se pretende encontrar:",
      "choices": [
        "La dos respuestas anteriores son correctas",
        "Una solución que satisfaga unas restricciones y optimice una cierta función objetivo",
        "Todas las soluciones que satisfagan unas restricciones"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la asignación de turnos tiene solución óptima voraz aplicando la siguiente estrategia.\nEstamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe pretende encontrar una solución para satisfacer el número máximo de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya existe, diseñar un algoritmo que reroelva el problema de forma óptima.",
      "choices": [
        "El problema no tiene solución óptima voraz",
        "Seleccionamos los alumnos en orden descendente de preferencia respetando las restricciones de cabida de cada turno",
        "Seleccionamos los alumnos en orden ascendente de preferencia respetando las restricciones de cabida de cada turno"
      ],
      "solution": 0
    },
    {
      "title": "El problema de la mochila puede solucionarse empleando vuelta atrás:",
      "choices": [
        "Sólo para el caso de la mochila con fraccionamiento",
        "Sólo para el caso de la mochila sin fraccionamiento",
        "Se puede aplicar para ambos casos"
      ],
      "solution": 1
    },
    {
      "title": "Dado un problema de optimización y un algoritmo voraz que lo soluciona, ¿cuándo podemos estar seguros de que la solución obtenida será óptima?:",
      "choices": [
        "Voraz siempre encuentra solución óptima",
        "En ambos casos. Las dos son correctas",
        "Cuando demostremos formalmente que el criterio conduce a una solución óptima para cualquier instancia del problema"
      ],
      "solution": 2
    },
    {
      "title": "El problema de la asignación de turnos resuelto mediante backtracking tiene una complejidad:\nEstamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe pretende encontrar una solución para satisfacer el número máximo de alumnos según su orden de preferencia. Suponiendo que la matriz \\(\\Mu\\) ya existe, diseñar un algoritmo que resuelva el problema de forma óptima.",
      "choices": ["Exponencial", "Polinómica", "Ninguna de las dos"],
      "solution": 0
    },
    {
      "title": "¿Cuál de las siguientes estrategias procede a obtener la solución a un problema de optimización mediante backtracking?",
      "choices": [
        "Genera todas las combinaciones de la solución y selecciona la que optimiza la función objetivo",
        "Genera todas las soluciones factibles y selecciona la que optimiza la función objetivo",
        "Genera una solución factible empleando un criterio óptimo"
      ],
      "solution": 1
    },
    {
      "title": "Dado un grafo G que representa las poblaciones de la provincia de Alicante de más de 20.000 habitantes junto con todas las carreteras de conexión entre ellas. Queremos obtener el recorrido que nos permita pasar por todas estas ciudades una única vez y volver al punto de origen recorriendo el mínimo número de kilómetros. Si aplicamos una estrategia voraz sobre este grafo obtendremos...",
      "choices": [
        "Puede que no encuentre ninguna solución aunque ésta exista",
        "Una solución factible",
        "La solución óptima"
      ],
      "solution": 1
    },
    {
      "title": "Si aplicamos un algoritmo voraz que no nos garantiza la solución óptima sobre un problema entonces...",
      "choices": [
        "Si el problema tiene solución óptima, el esquema voraz nos garantiza que la encuentra",
        "Obtendremos una solución factible",
        "Puede que no encuentre ninguna solución aunque ésta exista"
      ],
      "solution": 2
    },
    {
      "title": "El método voraz se emplea en la resolución de problemas de selección y optimización en los que se pretende encontrar:",
      "choices": [
        "Las dos respuestas anteriores son correctas",
        "Todas las soluciones que satisfagan unas restricciones",
        "Una solución que satisfaga unas restricciones y optimice una cierta función objetivo"
      ],
      "solution": 2
    },
    {
      "title": "Si aplicamos un esquema backtracking que no nos garantiza la solución óptima sobre un problema entonces:",
      "choices": [
        "Obtendremos una solución factible",
        "Puede que no encuentre ninguna solución aunque ésta exista",
        "Ninguna de las anteriores"
      ],
      "solution": 2
    },
    {
      "title": "La estrategia de ramificación y poda genera las soluciones posibles al problema mediante:",
      "choices": [
        "Un recorrido en profundidad del árbol que representa el espacio de soluciones",
        "Un recorrido en anchura que representa el espacio de soluciones",
        "Un recorrido guiado por estimaciones de las mejores ramas del árbol que representa el espacio de soluciones"
      ],
      "solution": 2
    },
    {
      "title": "Dada la solución recursiva mediante vuelta atrás al problema de la asignación de turnos, ¿cuántas nuevas llamadas recursivas genera cada llamada recursiva?\nEstamos al inicio del curso y los alumnos desean encontrar compañeros para formar grupos de práctica. Para resolver este problema, se sugiere que seleccionen a varias personas y les asignen una prioridad. El número de alumnos es \\(\\Nu\\). Se cuenta con una matriz cuadrada \\(\\Mu\\) con \\(\\Nu\\) filas, donde cada alumno ha escrito en su fila correspondiente un número entero (entre \\(-1\\) y \\(\\Nu-1\\) que indica dicha prioridad (un valor \\(-1\\) indica que no desea o no puede estar con la persona de la columna correspondiente. \\(0\\) indica indiferencia y, cuanto mayor sea el valor, mayor es la preferencia por esa persona). Ningún alumno puede formar grupo consigo mismo.\nSe pretende encontrar una solución para satisfacer el número máximo de alumnos según su orden de preferencia. Suponiendo que la matriz M ya existe, diseñar un algoritmo que resuelva el problema de forma óptima.",
      "choices": ["Una o dos", "Una o ninguna", "Ninguna de las anteriores"],
      "solution": 2
    },
    {
      "title": "¿Cuál de estas afirmaciones es falsa?",
      "choices": [
        "La complejidad en el peor caso de las soluciones Backtracking y ramificación y poda a un mismo problema es la misma",
        "Para un mismo problema, ramificación y poda explora siempre un número de nodos menor o igual que backtracking",
        "Backtracking inspecciona todo el espacio de soluciones de un problema mientras que Ramificación y poda no"
      ],
      "solution": 2
    },
    {
      "title": "Si para resolver un mismo problema usamos un algoritmo de vuelta atrás y lo modificamos mínimamente para convertirlo en un algoritmo de ramificación y poda, ¿qué cambiamos realmente?",
      "choices": [
        "Cambiamos la función que damos a la cota pesimista",
        "La comprobación de las soluciones factibles: en ramificación y poda no es necesario puesto que sólo genera nodos factibles",
        "Aprovechamos mejor las cotas optimistas"
      ],
      "solution": 2
    },
    {
      "title": "Backtracking genera las soluciones posibles al problema:",
      "choices": [
        "Mediante el recorrido en profundidad del árbol que representa el espacio de soluciones",
        "Mediante el recorrido en anchura del árbol que representa el espacio de soluciones",
        "Ninguna de las anteriores"
      ],
      "solution": 0
    },
    {
      "title": "En un problema resuelto por backtracking, el conjunto de valores que pueden tomar las componentes de la tupla solución, ha de ser:",
      "choices": ["Infinito", "Continuo", "Finito"],
      "solution": 2
    },
    {
      "title": "Cuando la descomposición recursiva de un problema da lugar a subproblemas de tamaño similar, ¿qué esquema promete ser más apropiado?",
      "choices": [
        "Programación dinámica",
        "Divide y vencerás, siempre que se garantice que los subproblemas no son del mismo tamaño",
        "El método voraz"
      ],
      "solution": 0
    },
    {
      "title": "El uso de funciones de cota en ramificación y poda:",
      "choices": [
        "Puede reducir el número de instancias del problema que pertenecen al caso peor",
        "No garantiza que el algoritmo va a ser más eficiente ante cualquier instancia del problema",
        "No transforma en polinómicas complejidades que antes eran exponenciales"
      ],
      "solution": 0
    }
  ]
}
