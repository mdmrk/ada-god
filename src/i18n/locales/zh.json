{
  "questions": [
    {
      "title": "目的是使用包含两座城市之间距离的表格找到两个城市之间的最短路径，其中 -1 表示没有道路。",
      "choices": [
        "并不总是保证更快",
        "不保证获得最短路径",
        "仅在某些问题情况下才会更快"
      ],
      "solution": 2
    },
    {
      "title": "作为一个优化问题，在实时分支和修剪节点列表中......",
      "choices": [
        "仅引入有前途的节点，即可以改进当时可用的最佳解决方案的节点。",
        "可能存在不被看好的节点",
        "其他两个选项都是正确的"
      ],
      "solution": 2
    },
    {
      "title": "我们想要获得由以下组成的列表的所有排列 \\(n\\) 要素，哪种方案最合适？",
      "choices": [
        "分而治之，因为划分子列表可以在恒定时间内完成",
        "分支和修剪，因为有了良好的边界函数，解决这个问题比返回更有效",
        "回过头来，对于这个问题没有更高效的方案"
      ],
      "solution": 2
    },
    {
      "title": "通过回溯并假设一个图来解决旅行商问题 \\(n\\) 完全连接的顶点，在开始搜索时，哪一个是好的悲观边界？",
      "choices": [
        "剩余的边按从最小到最大距离排序，并计算边的总和。 \\(n\\) 较短的边缘",
        "该问题是使用贪心算法解决的，该算法每次都会将最接近最后添加的顶点的顶点添加到路径中。",
        "它倍增 \\(n\\) 由我们剩下要考虑的最短边的距离"
      ],
      "solution": 1
    },
    {
      "title": "如果我们使用分支和剪枝算法并稍微调整它以将其转换为回溯算法，我们真正改变了什么？：",
      "choices": [
        "我们导致乐观限制失去有效性",
        "我们将给定函数更改为悲观界限",
        "有必要验证解决方案是否可行，因为分支和修剪只会生成可行的节点。"
      ],
      "solution": 0
    },
    {
      "title": "背包问题的回溯解决方案和分支剪枝解决方案之间的主要区别是什么？",
      "choices": [
        "探索解决方案的顺序",
        "事实上，分支和修剪解决方案可以从贪婪的次优解决方案开始，而一次回溯则不能",
        "最坏情况下的渐近成本"
      ],
      "solution": 0
    },
    {
      "title": "您想要找到两个城市之间的最短路径。\n",
      "choices": [
        "悲观的名言",
        "乐观一点",
        "这不会是任何修剪，因为这种启发式方法可能找不到可行的解决方案。"
      ],
      "solution": 1
    },
    {
      "title": "分支和修剪策略相对于回溯的优点在于，前者通过以下方式生成问题的可能解决方案......",
      "choices": [
        "引导遍历优先级队列，首先从优先级队列中提取代表解决方案空间最有希望的子树的节点",
        "其他两个选项都是正确的",
        "由代表解决方案空间的树的最佳分支的估计引导的游览"
      ],
      "solution": 1
    },
    {
      "title": "回溯策略适用于以下选择和优化问题：",
      "choices": [
        "解空间是一个无限集",
        "解空间是有限集",
        "解空间可以是有限的也可以是无限的，但在后一种情况下它必须至少是可数的。"
      ],
      "solution": 1
    },
    {
      "title": "您想要找到两个城市之间的最短路径。\n",
      "choices": [
        "不，因为它不能确保找到可行的解决方案。",
        "不，因为在某些情况下，它给出的距离可能小于最佳距离。",
        "是的，因为地理距离确保不可能有其他更好的解决方案"
      ],
      "solution": 0
    },
    {
      "title": "当我们使用分支和修剪方案解决问题时......",
      "choices": [
        "决策只能是二元的",
        "我们在每个决策中选择的值可以形成一个无限集",
        "我们在每个决策中选择的值必须形成一个有限集。"
      ],
      "solution": 2
    },
    {
      "title": "当回溯算法解决问题时 \\(n\\) 决策，其中每个决策总是至少有两个选择，以下哪种最坏情况的复杂性是我们能遇到的最好的？",
      "choices": [
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "分支和剪枝算法的最坏情况复杂度：",
      "choices": [
        "它可以随着每个决策的替代方案数量呈指数增长",
        "它与要做的决策数量呈指数关系",
        "它可以是要做出的决策数量的多项式"
      ],
      "solution": 1
    },
    {
      "title": "在没有乐观和悲观限制的情况下，回溯策略...",
      "choices": [
        "不能用于解决优化问题",
        "如果有办法丢弃代表不可行解集的子树，则不会遍历整个树",
        "它必须始终遍历整棵树"
      ],
      "solution": 1
    },
    {
      "title": "您想要找到两个城市之间的最短路径。\n",
      "choices": [
        "只要我们确定这种近似找到可行的解决方案，这将是一个悲观的估计。",
        "只要确定这种方法找到可行的解决方案，这就是一个乐观的估计。",
        "其他两个选项都没有"
      ],
      "solution": 0
    },
    {
      "title": "决定这三者中哪一个不能作为获得离散背包最优值的乐观界限：",
      "choices": [
        "根据物品的具体值，采用贪心算法得到的离散背包值",
        "对应连续背包的数值",
        "包含所有物品的背包的价值，即使超过允许的最大重量"
      ],
      "solution": 0
    },
    {
      "title": "分支和修剪算法最小情况下的复杂度...",
      "choices": [
        "它通常是多项式，其中包含每个决策的替代方案数量",
        "它总是随着要做的决定的数量呈指数增长",
        "它可以是要做出的决策数量的多项式"
      ],
      "solution": 2
    },
    {
      "title": "分支和修剪的悲观限制是什么？",
      "choices": [
        "根据对其他已完成节点的偏好丢弃节点",
        "确保乐观极限经过精心计算",
        "根据预期利润丢弃节点"
      ],
      "solution": 2
    },
    {
      "title": "在分支和剪枝算法中，悲观界限的值是否小于乐观界限的值？",
      "choices": [
        "是的，总是这样",
        "一般来说是的，如果是一个最大化问题，尽管有时两个值可以重合",
        "一般来说是的，如果是最小化问题，尽管有时两个值可以重合"
      ],
      "solution": 1
    },
    {
      "title": "分支和修剪策略...",
      "choices": [
        "您需要悲观边界来决定访问解决方案树的节点的顺序",
        "确定解决方案是否可行",
        "仅当用于解决优化问题时"
      ],
      "solution": 2
    },
    {
      "title": "在回溯的方案中，基于迄今为止最佳解决方案的剪枝机制......",
      "choices": [
        "前两条是真的",
        "他们保证永远不会探索所有可能的解决方案。",
        "他们可以消除部分可行的解决方案"
      ],
      "solution": 2
    },
    {
      "title": "在分支和修剪中使用维度函数...",
      "choices": [
        "它保证算法在任何问题实例中都会更有效",
        "可以减少属于最坏情况的问题实例的数量",
        "将以前的指数复杂度转换为多项式"
      ],
      "solution": 1
    },
    {
      "title": "确定这三个中哪一个是最接近离散背包最优值的悲观边界：",
      "choices": [
        "对应连续背包的数值",
        "包含所有物品的背包的价值，即使超过允许的最大重量",
        "根据物品的具体值，采用贪心算法得到的离散背包值"
      ],
      "solution": 2
    },
    {
      "title": "在分支和修剪策略中...",
      "choices": [
        "每个节点都有自己的乐观界限，但悲观界限对于所有节点来说都是共同的。",
        "每个节点都有自己的悲观界限和乐观界限。",
        "每个节点都有自己的悲观界限，但乐观界限对于所有节点来说都是共同的。"
      ],
      "solution": 1
    },
    {
      "title": "在分支和修剪算法中：",
      "choices": [
        "乐观界限必然是一个不可逾越的值，但如果不是，则可以修剪导致最优解的节点。",
        "乐观界限必然是一个可实现的值，但如果不是，则不能保证找到最优解。",
        "仅当可能的起始解决方案可用时，使用悲观界限才有效。"
      ],
      "solution": 1
    },
    {
      "title": "使用回溯策略解决背包问题时，确定这三个中哪一个是乐观边界：",
      "choices": [
        "背包的价值",
        "对应连续背包的最优值",
        "根据物体的具体值，通过贪心算法得到的离散背包值"
      ],
      "solution": 1
    },
    {
      "title": "在分支和剪枝算法中，悲观界限的值是否大于乐观界限的值？ ",
      "choices": [
        "不，从来不是这样的",
        "一般来说是的，如果是一个最大化问题，尽管有时两个值可以重合",
        "一般来说是的，如果是最小化问题，尽管有时两个值可以重合"
      ],
      "solution": 2
    },
    {
      "title": "给定任何优化问题，回溯策略能否保证最优解？",
      "choices": [
        "必要条件是决策的范围是离散的或可离散的，并且要做出的决策的数量是有限的。",
        "是的，只要决策域是离散的或可离散的，并且使用基于迄今为止最佳解决方案的剪枝机制。",
        "是的，因为这个方法分析了所有的可能性"
      ],
      "solution": 0
    },
    {
      "title": "轮班分配问题有一个解决方案：\n \\(\\Nu\\)。 \\(\\Mu\\) 和 \\(\\Nu\\) 行，每个学生在其相应行中写下一个整数（介于 \\(-1\\) 和 \\(\\Nu-1\\) 指示所述优先级（一个值 \\(-1\\) 表示您不想或不能与相应栏中的人在一起。 \\(0\\) 表示冷漠，值越高，对该人的偏好越大）。 \\(\\Mu\\) 已经创建，设计一个算法来最佳地解决问题。",
      "choices": ["通过回溯优化", "通过贪心近似（次优）", "两个都"],
      "solution": 2
    },
    {
      "title": "分支和修剪算法的执行时间取决于：",
      "choices": ["问题实例", "选择扩展节点的功能", "来自两者"],
      "solution": 2
    },
    {
      "title": "如果决策域是无限集，则这是一个优化问题",
      "choices": [
        "只要它是可数无限集，我们就可以应用回溯方案。",
        "贪婪策略可能是唯一的选择",
        "通过动态规划很可能会获得有效的算法来解决它。"
      ],
      "solution": 1
    },
    {
      "title": "回溯适用于选择和优化问题，其中：",
      "choices": ["解空间是有限集", "无论如何", "解空间是一个无限集"],
      "solution": 0
    },
    {
      "title": "回溯是一种通用的问题解决技术，基于：",
      "choices": ["系统性地寻找解决方案", "直接构建解决方案", "以上都不是"],
      "solution": 0
    },
    {
      "title": "Voraz 总是给出最优解：",
      "choices": ["二者皆是", "针对背包没有分叉的问题", "关于背包有分馏的问题"],
      "solution": 2
    },
    {
      "title": "背包问题是否使用贪心策略找到其最优解？：",
      "choices": [
        "仅适用于背包不分馏的情况",
        "在上述任何一种情况下",
        "仅在背包有分隔的情况下"
      ],
      "solution": 2
    },
    {
      "title": "旅行商问题可以使用以下编程方案正确解决：",
      "choices": ["仅动态规划", "使用其中任何一个：贪婪和回溯", "仅回溯"],
      "solution": 2
    },
    {
      "title": "在贪婪方法中，虽然决策是不可逆转的，但我们可以确保：",
      "choices": [
        "我们总会得到可行的解决方案",
        "我们总会得到最优解",
        "我们只会得到一些问题的最优解"
      ],
      "solution": 2
    },
    {
      "title": "通过应用回溯，我们获得问题的最佳解决方案：",
      "choices": ["总是", "只有当问题满足最优性原则时", "在某些情况下"],
      "solution": 2
    },
    {
      "title": "给定通过回溯以及分支和剪枝解决的问题，与回溯相比，分支和剪枝解决方案的计算成本为：",
      "choices": ["次要的", "平等的", "老年"],
      "solution": 1
    },
    {
      "title": "轮班分配问题有一个最优解：\n \\(\\Nu\\)。 \\(\\Mu\\) 和 \\(\\Nu\\) 行，每个学生在其相应行中写下一个整数（介于 \\(-1\\) 和 \\(\\Nu-1\\) 指示所述优先级（一个值 \\(-1\\) 表示您不想或不能与相应栏中的人在一起。 \\(0\\) 表示冷漠，值越高，对该人的偏好越大）。 \\(\\Mu\\) 已经创建，设计一个算法来最佳地解决问题。",
      "choices": ["回溯", "贪婪的", "两个都"],
      "solution": 0
    },
    {
      "title": "通过将回溯应用于问题解决，我们获得了具有计算成本的算法：",
      "choices": ["指数", "多项式", "两者都是正确的。"],
      "solution": 0
    },
    {
      "title": "回溯用于解决优化问题，其目的是找到：",
      "choices": [
        "前面两个答案都是正确的",
        "满足某些约束并优化某个目标函数的解决方案",
        "满足某些约束的所有解决方案"
      ],
      "solution": 0
    },
    {
      "title": "轮班分配问题通过应用以下策略获得贪婪最优解：\n \\(\\Nu\\)。 \\(\\Mu\\) 和 \\(\\Nu\\) 行，每个学生在其相应行中写下一个整数（介于 \\(-1\\) 和 \\(\\Nu-1\\) 指示所述优先级（一个值 \\(-1\\) 表示您不想或不能与相应栏中的人在一起。 \\(0\\) 表示冷漠，值越高，对该人的偏好越大）。 \\(\\Mu\\) 已经创建，设计一个算法来最佳地解决问题。",
      "choices": [
        "问题没有最优解",
        "我们按照偏好降序选择学生，尊重每个班次的空间限制。",
        "我们按照偏好升序选择学生，尊重每个班次的空间限制"
      ],
      "solution": 0
    },
    {
      "title": "背包问题可以用回溯法解决吗？：",
      "choices": [
        "仅在背包有分隔的情况下",
        "仅适用于背包不分馏的情况",
        "两种情况都可以应用"
      ],
      "solution": 2
    },
    {
      "title": "给定一个优化问题和一个解决该问题的贪心算法，我们什么时候可以确定获得的解决方案是最优的？：",
      "choices": [
        "贪婪的总能找到最优的解决方案",
        "在这两种情况下。",
        "当我们正式证明该标准可以为任何问题实例带来最佳解决方案时"
      ],
      "solution": 2
    },
    {
      "title": "通过回溯解决的轮班分配问题具有复杂性：\n \\(\\Nu\\)。 \\(\\Mu\\) 和 \\(\\Nu\\) 行，每个学生在其相应行中写下一个整数（介于 \\(-1\\) 和 \\(\\Nu-1\\) 指示所述优先级（一个值 \\(-1\\) 表示您不想或不能与相应栏中的人在一起。 \\(0\\) 表示冷漠，值越高，对该人的偏好越大）。 \\(\\Mu\\) 已经创建，设计一个算法来最佳地解决问题。",
      "choices": ["指数", "多项式", "两者都不是"],
      "solution": 0
    },
    {
      "title": "回溯旨在通过以下策略获得优化问题的解决方案：",
      "choices": [
        "生成解决方案的所有组合并选择优化目标函数的组合",
        "生成所有可行的解决方案并选择优化目标函数的解决方案",
        "使用最优标准生成可行解决方案"
      ],
      "solution": 1
    },
    {
      "title": "给定一个图 G，它代表阿利坎特省拥有超过 20,000 名居民的城镇以及它们之间的所有连接道路。",
      "choices": [
        "即使存在，您也可能找不到解决方案",
        "可行的解决方案",
        "最优解"
      ],
      "solution": 1
    },
    {
      "title": "如果我们应用的贪心算法不能保证问题的最佳解决方案，那么......",
      "choices": [
        "如果问题有最优解，贪心方案保证找到最优解。",
        "我们将得到一个可行的解决方案",
        "即使存在，您也可能找不到解决方案"
      ],
      "solution": 2
    },
    {
      "title": "贪心法用于解决选择和优化问题，其目的是找到：",
      "choices": [
        "前面两个答案都是正确的",
        "满足某些约束的所有解决方案",
        "满足某些约束并优化某个目标函数的解决方案"
      ],
      "solution": 2
    },
    {
      "title": "如果我们应用回溯方案不能保证问题的最佳解决方案，那么",
      "choices": [
        "我们将得到一个可行的解决方案",
        "即使存在，您也可能找不到解决方案",
        "以上都不是"
      ],
      "solution": 2
    },
    {
      "title": "分支和修剪策略通过以下方式生成问题的可能解决方案：",
      "choices": [
        "深度遍历代表解空间的树",
        "代表解空间的宽度路径",
        "由代表解决方案空间的树的最佳分支的估计引导的游览"
      ],
      "solution": 2
    },
    {
      "title": "考虑到递归回溯问题，每次递归调用会生成多少个新的递归调用？：\n \\(\\Nu\\)。 \\(\\Mu\\) 和 \\(\\Nu\\) 行，每个学生在其相应行中写下一个整数（介于 \\(-1\\) 和 \\(\\Nu-1\\) 指示所述优先级（一个值 \\(-1\\) 表示您不想或不能与相应栏中的人在一起。 \\(0\\) 表示冷漠，值越高，对该人的偏好越大）。 \\(\\Mu\\) 已经创建，设计一个算法来最佳地解决问题。",
      "choices": ["一个或两个", "一个或没有", "以上都不是"],
      "solution": 2
    },
    {
      "title": "以下哪些说法是错误的？",
      "choices": [
        "回溯和分支剪枝解决同一问题的最坏情况复杂度是相同的",
        "对于同一问题，分支和剪枝总是探索小于或等于回溯的节点数",
        "回溯检查问题的整个解决方案空间，而分支和修剪则不然。"
      ],
      "solution": 2
    },
    {
      "title": "如果为了解决同样的问题，我们使用回溯算法并对其进行最小程度的修改，将其变成分支和剪枝算法，我们真正改变了什么？",
      "choices": [
        "我们改变我们给悲观界限的函数",
        "检查可行的解决方案：分支和修剪是不必要的，因为它只生成可行的节点",
        "我们更好地利用乐观水平"
      ],
      "solution": 2
    },
    {
      "title": "回溯产生问题的可能解决方案：",
      "choices": [
        "通过深度遍历代表解空间的树",
        "通过遍历代表解空间的树的宽度",
        "以上都不是"
      ],
      "solution": 0
    },
    {
      "title": "在通过回溯解决的问题中，解元组的分量可以取的值的集合必须是：",
      "choices": ["无穷", "连续的", "有限"],
      "solution": 2
    },
    {
      "title": "当问题的递归分解产生类似大小的子问题时，哪种方案最合适？",
      "choices": [
        "动态规划",
        "分而治之，只要保证子问题大小不一样",
        "贪婪的方法"
      ],
      "solution": 0
    },
    {
      "title": "在分支和修剪中使用维度函数...",
      "choices": [
        "可以减少属于最坏情况的问题实例的数量",
        "它保证算法在任何问题实例中都会更有效",
        "将以前的指数复杂度转换为多项式"
      ],
      "solution": 0
    },
    {
      "title": "如果优化问题针对的是采用连续值的函数",
      "choices": [
        "就内存使用而言，迭代动态编程总是比递归动态编程高效得多",
        "无论域是离散的还是连续的，迭代动态规划和递归动态规划的内存使用量都是相同的。",
        "就内存使用而言，递归动态编程比迭代动态编程高效得多"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(f(n)\\in\\Omicron(n^3)\\)，会不会发生这样的情况 \\(f(n)\\in\\Omicron(n^2)\\)？",
      "choices": [
        "不是因为 \\(n^3\\) 不 \\(\\in\\Omicron(n^2)\\)",
        "这是完全有可能的，因为 \\(\\Omicron(n^2)\\sube\\Omicron(n^3)\\)",
        "仅适用于低值 \\(n\\)"
      ],
      "solution": 1
    },
    {
      "title": "设以下递推关系为\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n是的 \\(T(n)\\in\\Omicron(n^2)\\)我们会发现自己属于这三种情况中的哪一种？",
      "choices": ["\\(g(n)=1\\)", "\\(g(n)=n^2\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "优化问题的简单（但正确）递归解决方案多次调用具有相同参数的函数。",
      "choices": [
        "通过将每次调用第一次发生时为每组参数返回的值存储在表中，可以提高算法的效率。",
        "在不改变其基本运算的情况下，将递归算法直接转化为迭代算法，可以提高算法的效率",
        "通过预先定义计算子问题解的顺序并按该顺序填写表格，可以提高算法的效率。"
      ],
      "solution": 1
    },
    {
      "title": "尺寸问题 \\(n\\) 可以转化为时间 \\(\\Omicron(n^2)\\) 另一种尺寸 \\(n-1\\)。",
      "choices": [
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "当贪婪算法用于解决离散选择优化问题（即，解决方案是找到优化给定函数的元素集的子集的问题）时，这三件事中哪一件是不可能的发生？",
      "choices": [
        "该解决方案不是最优的",
        "该算法没有找到任何解决方案",
        "考虑到当前必须做出的决定，重新考虑之前已经做出的关于元素选择的决定"
      ],
      "solution": 2
    },
    {
      "title": "这三个问题之一没有遵循动态规划方案的有效解决方案",
      "choices": [
        "谨慎的背包问题",
        "河内塔的问题",
        "管材切割长度问题 \\(n\\) 分成 1 到 1 之间的整数长度段 \\(n\\) 以便根据给出每个长度的价格的表格使价格最大化"
      ],
      "solution": 1
    },
    {
      "title": "这三个优化问题中哪一个没有或不知道有最优的贪婪解？",
      "choices": [
        "谨慎的背包问题",
        "连接网络的最小成本覆盖树",
        "连续背包或分馏的问题"
      ],
      "solution": 0
    },
    {
      "title": "以下哪种算法将为寻找两个城市之间的最短路径的问题提供悲观界限（假设该图是连通的）",
      "choices": [
        "计算出发城市和目的地之间的几何距离（直线）",
        "对于从出发城市一步可达的所有城市，将到该城市的距离和到目的地城市的几何距离相加",
        "计算在图表中随机移动直到（偶然）到达目的地城市的行驶距离"
      ],
      "solution": 2
    },
    {
      "title": "给定任何优化问题，回溯策略能否保证最优解？",
      "choices": [
        "是的，只要决策域是离散的或可离散的，并且使用基于迄今为止最佳解决方案的剪枝机制。",
        "是的，因为这个方法分析了所有的可能性",
        "必要条件是决策的范围是离散的或可离散的，并且要做出的决策的数量是有限的。"
      ],
      "solution": 2
    },
    {
      "title": "对于这些优化问题中的哪些有贪心解？",
      "choices": [
        "带权重无向图的最小覆盖树",
        "谨慎的背包问题",
        "最小成本分配问题 \\(n\\) 分配任务的成本时将任务分配给工人 \\(i\\) 给工人 \\(j\\), \\(C_{'{'}ij{'}'}\\) 以矩阵形式列出"
      ],
      "solution": 0
    },
    {
      "title": "最好的时间复杂度",
      "choices": [
        "它是算法解决可呈现的尺寸或最小尺寸问题所花费的时间。",
        "它是问题的大小或大小的函数，必须为此定义所有可能的值",
        "其他两个选项都是正确的"
      ],
      "solution": 1
    },
    {
      "title": "使用“分而治之”策略是否可以保证任何问题都存在多项式时间复杂度解决方案？",
      "choices": [
        "是的，但只要问题分解运算和解组合的联合时间复杂度是多项式",
        "不",
        "是的，无论如何"
      ],
      "solution": 1
    },
    {
      "title": "确定这三个中哪一个是最接近离散背包最优值的悲观边界：",
      "choices": [
        "根据物品的具体值，采用贪心算法得到的离散背包值",
        "包含所有物品的背包的价值，即使超过允许的最大重量",
        "对应连续背包的数值"
      ],
      "solution": 0
    },
    {
      "title": "通过回溯解决旅行商问题，我们可以期望哪些乐观界限可以改进搜索树？",
      "choices": [
        "问题的其余部分是使用贪心算法解决的，该算法每次将最接近最后添加的顶点的顶点添加到路径中。",
        "剩余的边按距离从最短到最大的顺序排列，并计算 k 个最短边的总和，其中 k 是我们剩下要进行的跳跃次数。",
        "K 乘以仍需考虑的最短边的距离，其中 k 是仍需进行的跳跃次数。"
      ],
      "solution": 1
    },
    {
      "title": "您想要找到两个城市之间的最短路径。",
      "choices": [
        "新算法并不保证它对于所有可能的问题实例都会更快。",
        "该策略并不能保证获得最短路径。",
        "新的算法总是会更快"
      ],
      "solution": 0
    },
    {
      "title": "在分支和修剪算法中：",
      "choices": [
        "乐观的界限并不一定是不可逾越的价值；",
        "乐观的极限必然是可实现的值；",
        "悲观界限是任何非最优可行节点可以达到的最大值。"
      ],
      "solution": 0
    },
    {
      "title": "分支和剪枝算法的最佳情况复杂度",
      "choices": [
        "它总是随着要做的决定的数量呈指数增长",
        "它通常是多项式，其中包含每个决策的替代方案数量",
        "它可以是要做出的决策数量的多项式"
      ],
      "solution": 2
    },
    {
      "title": "对于离散背包问题，用贪心法得到的值为...",
      "choices": [
        "最优值的上限",
        "最佳值的下限，但永远不会与此一致",
        "最佳值的下限有时可以等于此"
      ],
      "solution": 2
    },
    {
      "title": "在该方案中，将不同值分配给解将包含的向量的分量的顺序将返回。",
      "choices": [
        "其他两个选项都是正确的",
        "如果使用基于乐观估计的修剪机制，则可能相关",
        "如果不使用基于迄今为止最佳解决方案的剪枝机制，那是无关紧要的"
      ],
      "solution": 0
    },
    {
      "title": "连续背包问题最著名的解决方案遵循以下方案",
      "choices": ["分而治之", "贪婪的", "分枝和修剪"],
      "solution": 1
    },
    {
      "title": "设 A 为方阵 \\(n\\times n\\)。",
      "choices": [
        "如果问题的解决方案是基于分支和剪枝方案构建的，那么乐观和悲观边界的良好选择可以避免探索所有可能的排列。",
        "问题的最佳解决方案的时间复杂度为 \\(\\Omicron(n^2)\\)",
        "问题的最佳解决方案的时间复杂度为 \\(\\Omicron(n!)\\)"
      ],
      "solution": 1
    },
    {
      "title": "在网格上你想画出一个正方形的轮廓 \\(n\\) 边箱。",
      "choices": [
        "\\(\\Omicron(\\sqrt{'{'}n{'}'})\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "给定一个优化问题，贪心法...",
      "choices": [
        "你总能得到最优的解决方案",
        "你总能得到可行的解决方案",
        "仅保证某些问题的最优解决方案"
      ],
      "solution": 2
    },
    {
      "title": "判断这三种算法中哪一个不是“分而治之”算法：",
      "choices": ["快速排序", "归并排序", "Prim 算法"],
      "solution": 2
    },
    {
      "title": "在使用回溯策略解决离散背包问题时，如果先尝试将每个对象放入然后再不放入，是否可以减少找到最优解的时间？",
      "choices": [
        "不，因为无论如何都必须探索所有可行的解决方案",
        "是的，但前提是使用乐观边界来修剪搜索树",
        "是的，是否使用乐观边界来修剪搜索树"
      ],
      "solution": 1
    },
    {
      "title": "给定以下函数，我们希望降低函数的时间复杂度 \\(g\\) 使用迭代动态规划。<pre><code>// Precondición: {'{'} 0 <= i < v.size(); i < j <= v.size() {'}'}\nunsigned f(const vector<unsigned> &v, unsigned i, unsigned j) {'{'}\n\tif(i == j+1)\n\t\treturn v[i];\n\tunsigned sum = 0;\n\tfor(unsigned k = 0; k < j-i; k++)\n\t\tsum += f(v, i, i+k+1) + f(v, i+k+1, j);\n\treturn sum;\n{'}'}\n\nunsigned g(const vector<unsigned> &v) {'{'}\n\treturn f(v, v.begin(), v.end());\n{'}'}</code></pre>",
      "choices": ["二次", "指数", "立方体"],
      "solution": 0
    },
    {
      "title": "在优化问题中，如果决策域是无限集，",
      "choices": [
        "通过动态规划很可能会获得有效的算法来解决它。",
        "贪婪策略可能是唯一的选择",
        "只要它是可数无限集，我们就可以应用向后方案。"
      ],
      "solution": 1
    },
    {
      "title": "如果为了解决同样的问题，我们使用回溯算法并对其进行最小程度的修改，将其变成分支和剪枝算法，我们真正改变了什么？",
      "choices": [
        "该算法可以更好地利用乐观界限",
        "我们改变我们给悲观界限的函数",
        "检查可行的解决方案：分支和修剪是不必要的，因为它只生成可行的节点"
      ],
      "solution": 0
    },
    {
      "title": "以下哪些问题可以使用动态规划有效解决？",
      "choices": ["低调的背包，没有额外的限制", "改变的问题", "任务分配问题"],
      "solution": 1
    },
    {
      "title": "以下程序解决了切割一定长度的管子的问题 \\(n\\) 分成 1 到 1 之间的整数长度段 \\(n\\) 以便根据给出每个长度的价格的表格使价格最大化，但缺少一块。<pre><code>void fill(price r[]) {'{'}\n\tfor (index i=0; i <= n; i++) r[i] = -1;\n{'}'}\n\nprice cutrod(price p[], r[], length n) {'{'}\nprice q;\nif (r[n]>=0) return r[n];\nif (n==0) q=0;\nelse {'{'}\n\tq=-1;\n\tfor (index i=1; i<=n; i++)\n\tq=max(q,p[i]+cutrod(XXXXXXX));\n{'}'}\nr[n]=q;\nreturn q;\n{'}'}</code></pre>",
      "choices": ["p,r.n-r[n]", "p,r-1,1", "p,r,n-i"],
      "solution": 2
    },
    {
      "title": "在分支和剪枝算法中，悲观界限的值是否大于乐观界限的值？ ",
      "choices": [
        "不，从来不是这样的",
        "一般来说是的，如果是一个最大化问题，尽管有时两个值可以重合",
        "一般来说是的，如果是最小化问题，尽管有时两个值可以重合"
      ],
      "solution": 2
    },
    {
      "title": "以下三种情况之一是不可能的：",
      "choices": [
        "\\(f(n)\\in\\Omicron(n)\\) 和 \\(f(n)\\in\\Omega(1)\\)",
        "\\(f(n)\\in\\Omega(n^2)\\) 和 \\(f(n)\\in\\Omicron(n)\\)",
        "\\(f(n)\\in\\Omicron(n)\\) 和 \\(f(n)\\in\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "动态规划通常比朴素解决方案提供的改进是由于以下事实而实现的：",
      "choices": [
        "在朴素解决方案中，相对大量的不同子问题很少得到解决。",
        "解决子问题的次数与使用动态规划解决问题的效率无关。",
        "在朴素解决方案中，通常会解决相对少量的不同子问题。"
      ],
      "solution": 2
    },
    {
      "title": "使用占据第一个位置的向量元素作为基准的快速排序版本...",
      "choices": [
        "当向量已经排序时它表现得更好",
        "不呈现相同大小实例的最佳和最坏情况",
        "当向量已经排序时，它的表现会更糟"
      ],
      "solution": 2
    },
    {
      "title": "在回溯的方案中，基于迄今为止最佳解决方案的剪枝机制......",
      "choices": [
        "其他两个选项都是正确的",
        "他们保证永远不会探索所有可能的解决方案。",
        "他们可以消除部分可行的解决方案"
      ],
      "solution": 2
    },
    {
      "title": "基于分而治之方案的递归算法...",
      "choices": [
        "它永远不会具有指数复杂性。",
        "前两条是真的。",
        "子问题的划分越公平，效率就越高。"
      ],
      "solution": 2
    },
    {
      "title": "您想要订购 1 到 1 之间的不同数字 \\(n\\)。 \\(n\\) 首先初始化为 false 的布尔值。",
      "choices": [
        "是的，因为合并排序是 \\(\\Omicron(n\\log(n))\\) 这是 \\(\\Omicron(n)\\)",
        "不，因为该算法必须多次遍历布尔向量",
        "除非 \\(d\\log(d)>kn\\) （在哪里 \\(k\\) 是一个常数，取决于实现）"
      ],
      "solution": 2
    },
    {
      "title": "在分支和剪枝中，使用节点的乐观界限作为对活动节点列表进行排序的标准是否有意义？",
      "choices": [
        "不，乐观界限仅用于确定 n 元组是否有前途。",
        "是的，尽管这并不能保证它是一个好的搜索策略",
        "是的，如果对活动节点列表进行排序，则必须始终根据乐观边界标准进行排序"
      ],
      "solution": 1
    },
    {
      "title": "在回溯的方案中，基于迄今为止最佳解决方案的剪枝机制：",
      "choices": [
        "他们可以消除代表可能可行解决方案的向量",
        "他们保证不会探索所有可能的解决方案",
        "其他两个选项都是正确的"
      ],
      "solution": 0
    },
    {
      "title": "我们想要获得由以下组成的列表的所有排列 \\(n\\) 项目。",
      "choices": [
        "分而治之，因为划分子列表可以在恒定时间内完成",
        "回过头来说，是解决这个问题最高效的方案",
        "分支和修剪，因为有了良好的高程函数，它比返回更有效"
      ],
      "solution": 1
    },
    {
      "title": "在没有乐观和悲观水平的情况下，回溯策略...",
      "choices": [
        "如果有办法丢弃代表不可行解集的子树，则不会遍历整个树",
        "它必须始终遍历整棵树",
        "不能用于解决优化问题"
      ],
      "solution": 0
    },
    {
      "title": "贪婪的计划...",
      "choices": [
        "保证找到任何问题的解决方案，尽管它可能不是最佳的",
        "你可能找不到解决方案，但如果你找到了，它一定是最佳的",
        "另外两个选项都是 false"
      ],
      "solution": 2
    },
    {
      "title": "一种基于分而治之的递归算法",
      "choices": [
        "其他两个选项都是正确的",
        "当尺寸问题时它达到最大效率 \\(n\\) 分为尺寸问题 \\(\\frac{'{'}n{'}'}{'{'}a{'}'}\\)",
        "它永远不会有指数渐近时间成本（0时间复杂度）"
      ],
      "solution": 1
    },
    {
      "title": "当问题的分解产生与原始问题大小相似的子问题时，其中许多子问题是重复的，哪种先验方案更合适？",
      "choices": ["动态规划", "分而治之", "分枝和修剪"],
      "solution": 0
    },
    {
      "title": "给定三步迷宫问题，是否可以应用动态规划方案来获得退出路径？",
      "choices": [
        "不，为了确保找到退出路径，必须应用穷举搜索方法，例如回溯或分支和修剪。",
        "是的，如果你存在这个方案，你总能找到退出路径",
        "不，通过这个方案，您可以知道通向出口的不同路径的总数，但您无法知道其中任何一条的组成。"
      ],
      "solution": 1
    },
    {
      "title": "我们要解决n次方的问题（\\(x^n\\)）， 假如说 \\(n\\) 是偶数，将使用以下递推式：\n\\(pot(x, n) = pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'}) * pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'})\\) 就时间成本而言，哪种方案更有效？",
      "choices": [
        "在这种情况下，动态规划和分治法在时间复杂度方面是等效的。",
        "动态规划",
        "分而治之"
      ],
      "solution": 1
    },
    {
      "title": "确定这三个中哪一个是最接近离散背包最优值的乐观边界：",
      "choices": [
        "包含所有物品的背包的价值，即使超过允许的最大重量",
        "对应连续背包的数值",
        "根据物品的具体值，采用贪心算法得到的离散背包值"
      ],
      "solution": 1
    },
    {
      "title": "实验室实践之一是经验计算Quicksort向量排序算法的平均时间复杂度，以向量中占据中心位置的元素作为哨兵。",
      "choices": ["\\(n^2\\)", "\\(n\\log(n)\\)", "\\(n\\log^2(n)\\)"],
      "solution": 1
    },
    {
      "title": "由什么推导出来 \\(f(n)\\) 和 \\(g(n)\\) 如果实现的话 \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=k\\)？",
      "choices": [
        "\\(g(n)\\in\\Omicron(f(n))\\) 但 \\(f(n)\\notin\\Omicron(g(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) 和 \\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) 但 \\(g(n)\\notin\\Omicron(f(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "给定具有三个运动的迷宫问题，我们想知道从初始正方形开始的不同路径的数量 \\((1, 1)\\) 直到盒子 \\((n, m)\\) 为此，应用了分而治之的方案。",
      "choices": [
        "\\(nc(n, m) = nc(n - 1, m) + nc(n, m - 1) + nc(n - 1, m - 1)\\)",
        "\\(nc(n, m) = nc(n - 1, m) + nc(m - 1, n) + nc(n - 1, m - 1)\\)",
        "其他两个递归都不符合分而治之方案"
      ],
      "solution": 0
    },
    {
      "title": "设以下递推关系为：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n是的 \\(T(n)\\in\\Omicron(n)\\)我们会发现自己属于这三种情况中的哪一种？",
      "choices": [
        "\\(g(n)=\\sqrt{'{'}n{'}'}\\)",
        "\\(g(n)=\\log(n)\\)",
        "其他两个选项都是正确的"
      ],
      "solution": 2
    },
    {
      "title": "回去的计划...",
      "choices": [
        "保证您找到任何离散选择问题的最佳解决方案",
        "其他两个选项都是正确的",
        "它可以应用于任何类型的问题，尽管时间成本很高。"
      ],
      "solution": 0
    },
    {
      "title": "如果节点的悲观边界对应的解决方案不可行，会发生什么？",
      "choices": [
        "该算法会更慢，因为会探索比必要的更多的节点",
        "没什么特别的，悲观极限不必对应于可行的解决方案",
        "该算法将是不正确的，因为导致最佳解决方案的节点可能会被丢弃"
      ],
      "solution": 2
    },
    {
      "title": "给定具有三个移动的迷宫问题，我们想知道从初始框 (1, 1) 到框 (n, m) 的不同路径的数量，为此应用了动态规划方案。",
      "choices": [
        "不能保证改进，因为具有记忆功能的递归版本可能比从分而治之方案获得的版本更糟糕。",
        "从使用朴素复杂度获得的二次复杂度来看，它将减少到与记忆复杂度成线性关系。",
        "从使用朴素复杂度获得的指数复杂度出发，使用记忆复杂度将其简化为多项式。"
      ],
      "solution": 2
    },
    {
      "title": "给定具有三个运动的迷宫问题，目的是知道最短出口路径的长度。",
      "choices": [
        "实际上这并不是一个贪婪的算法，因为选择标准不是",
        "这是一个贪婪的算法，但不能保证解决问题",
        "事实上，它并不是一个贪婪的算法，因为所做的决定不应该被重新考虑"
      ],
      "solution": 0
    },
    {
      "title": "给定以下函数：<pre><code>int exa(vector<int> &v) {'{'}\n\tint j, i=1, n=v.size();\n\n\tif (n>1) do {'{'}\n\t\tint x = v[i];\n\t\tfor(j=i; j>0 && v[j-1] > x; j++)\n\t\t\tv[j]=v[j-1];\n\t\tv[j]=x;\n\t\ti++;\n\t{'}'} while(i<n);\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "最好的时间复杂度是 \\(\\Omega(n)\\)",
        "最好的时间复杂度是 \\(\\Omega(1)\\)",
        "确切的时间复杂度是 \\(\\Theta(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "在回溯方案中哪种先验搜索策略最合适？",
      "choices": [
        "首先探索具有最佳乐观边界的节点。",
        "首先探索最完整的节点",
        "回溯方案中不能定义搜索策略。"
      ],
      "solution": 2
    },
    {
      "title": "给定通过分而治之解决的汉诺塔问题，以下哪一个递归关系最能表达一般情况的时间复杂度： \\(n\\) 磁盘数量？",
      "choices": [
        "\\(T(n)=T(n-1)+n\\)",
        "\\(T(n)=2T(n-1)+1\\)",
        "\\(T(n)=2T(n-1)+n\\)"
      ],
      "solution": 1
    },
    {
      "title": "如果算法的时间成本是 \\(T(n)\\)，以下哪种情况是不可能的？",
      "choices": [
        "\\(T(n)\\in\\Omicron(n)\\) 和 \\(T(n)\\in\\Theta(n)\\)",
        "\\(T(n)\\in\\Theta(n)\\) 和 \\(T(n)\\in\\Omega(n^2)\\)",
        "\\(T(n)\\in\\Omega(n)\\) 和 \\(T(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "一管 \\(n\\) 厘米长的可切成1厘米、2厘米等的段。",
      "choices": [
        "布尔向量",
        "一个表格，指示要切割的每个位置的每个可能的累积值",
        "一对整数，表示进行的切割和累积值"
      ],
      "solution": 0
    },
    {
      "title": "应用动态规划后，以下函数的时间复杂度是多少？<pre><code>double f(int n, int m) {'{'}\n\tif(n == 0) return 1;\n\treturn m * f(n-1,m) * f(n-2,m);\n{'}'}</code></pre>",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\times m)\\)",
        "\\(\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "给定以下函数： <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\tif (n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j;i<n;i++)\n\t\t\t\tsum+=v[i];\n\t\t\tif(j==0) sum=100;\n\t\t{'}'}\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>",
      "choices": [
        "最好的时间复杂度是 \\(\\Omega(n)\\)",
        "最坏情况时间复杂度为 \\(\\Omega(1)\\)",
        "最坏情况时间复杂度为 \\(\\Omega(n\\log(n))\\)"
      ],
      "solution": 0
    },
    {
      "title": "将元素插入有序向量以使其保持有序的渐近时间成本为：",
      "choices": [
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omega(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "给定一个使用分支剪枝方案解决的最大化问题，如果乐观界限的值过高，会发生什么情况？",
      "choices": [
        "可以探索的节点数量少于必要的数量",
        "您可以修剪导致最佳解决方案的节点",
        "您可以探索不必要的节点"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(f\\in\\Omega(g1)\\) 和 \\(f\\in\\Omega(g2)\\) 所以：",
      "choices": [
        "\\(f\\in\\Omega(g1*g2)\\)",
        "\\(f\\notin\\Omega(\\min(g1*g2))\\)",
        "\\(f\\in\\Omega(g1+g2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "从递推关系得到什么复杂度 \\(T(n)=8T(\\frac{'{'}n{'}'}{'{'}2{'}'})+n^3\\) 和 \\(T(1)=\\Omicron(1)\\)？",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(n^3\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "在旅行商问题中，我们想要列出所有可行的解决方案。",
      "choices": [
        "最重要的是要有一个适当的悲观限度",
        "探索部分解决方案的顺序无关紧要；",
        "最合适的是使用分支和修剪技术，因为探索部分解决方案的顺序非常重要。"
      ],
      "solution": 1
    },
    {
      "title": "给定以下函数，其中 \\(\\max(a,b)\\in\\Theta(1)\\)：<pre><code>float exa(vector<float> &v, vector<int> &p, int P, int i) {'{'}\n\tfloat a, b;\n\tif (i>=0) {'{'}\n\t\tif (p[i] <= P)\n\t\t\ta = v[i]*exa(v,p,P-p[i],i-1);\n\t\telse a=0;\n\t\tb=exa(v,p,P,i-1);\n\t\treturn max(a,b);\n\t{'}'}\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "最好的时间复杂度是 \\(\\Omega(n^2)\\)",
        "最坏情况时间复杂度为 \\(\\Omicron(n^2)\\)",
        "最好的时间复杂度是 \\(\\Omicron(2^n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "在分支和剪枝方案中，如果我们想要进行层次探索，哪种结构是最合适的？",
      "choices": ["优先队列", "线", "堆"],
      "solution": 1
    },
    {
      "title": "给定以下函数：<pre><code>int exa(string &cad, int pri, int ult) {'{'}\n\tif(pri>=ult)\n\t\treturn 1;\n\telse\n\t\tif (cad[pri]==cad[ult])\n\t\t\treturn exa(cad, pri+1, ult-1);\n\t\telse\n\t\t\treturn 0;\n{'}'}</code></pre>它的渐近时间复杂度是多少？",
      "choices": [
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "考虑到三步迷宫问题，以下哪种策略可以为分支和修剪提供乐观的界限？",
      "choices": [
        "假设从现在开始迷宫中的所有空间都是可访问的",
        "假设不会再有任何动作",
        "其他两个策略都是有效的"
      ],
      "solution": 2
    },
    {
      "title": "下列表达式中，要么两个为真，一个为假，要么两个为假，一个为真。",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(\\Omicron(2^{'{'}\\log(n){'}'}\\sub\\Omicron(n^2))\\)",
        "\\(\\Theta(n)\\sub\\Theta(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "最坏情况下的渐近时间成本和最好情况下的渐近时间成本之间的平均值给我们带来了什么？",
      "choices": ["平均时间成本", "平均情况下的渐近时间成本", "没什么感兴趣的"],
      "solution": 2
    },
    {
      "title": "您想要对链接列表进行排序 \\(n\\) 使用归并排序算法的元素。",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "其他两个选项都不正确"
      ],
      "solution": 1
    },
    {
      "title": "给定具有三个运动的迷宫问题，我们想知道从初始框 (1,1) 到框 (n, m) 的不同路径的数量，为此应用动态规划方案以获得最有效的算法。在时间和空间复杂性方面是可能的。",
      "choices": [
        "暂时的 \\(\\Theta(n\\times m)\\) 和空间 \\(\\Theta(n\\times m)\\)",
        "暂时的 \\(\\Theta(\\max{n}{m})\\) 和空间 \\(\\Theta(\\max{n}{m})\\)",
        "暂时的 \\(\\Theta(n\\times m)\\) 和空间 \\(\\Theta(\\min{'{'}n{'}'}{'{'}m{'}'})\\)"
      ],
      "solution": 2
    },
    {
      "title": "指出以下哪项陈述是正确的。",
      "choices": [
        "悲观限制与回溯方案不兼容",
        "在后向方案中，如果目标是获得所有可行解，则悲观限制没有意义。",
        "回溯方案与悲观和乐观边界的联合使用不兼容。"
      ],
      "solution": 1
    },
    {
      "title": "给定使用分支剪枝方案解决的最小化问题，乐观界限满足什么属性？",
      "choices": [
        "它总是大于或等于达到的最佳可能解决方案",
        "确保节省测试所有可行解决方案的成本",
        "另外两个选项都是 false"
      ],
      "solution": 2
    },
    {
      "title": "给定以下函数 <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\t if(n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j; i<n; i++)\n\t\t\t\tsum=v[i];\n\t\t\tif (j==0) sum=100;\n\t\t{'}'};\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>标记正确答案：",
      "choices": [
        "确切的时间复杂度是 \\(\\Theta(n\\log(n))\\)",
        "最好的时间复杂度是 \\(\\Omega(n)\\)",
        "最好的时间复杂度是 \\(\\Omega(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "是否可以通过存储递归调用返回的结果来减少递归算法的时间成本？",
      "choices": [
        "不行，只能通过将递归算法转为迭代算法来降低成本",
        "是的，如果重复使用相同参数的函数调用",
        "不，这不会减少时间成本，因为无论如何都必须进行递归调用"
      ],
      "solution": 1
    },
    {
      "title": "下列表达式中，要么两个为真，一个为假，要么两个为假，一个为真。",
      "choices": [
        "\\(\\Theta(f)=\\Omicron(f)\\cap\\Omega(f)\\)",
        "\\(\\Omega(f)=\\Theta(f)\\cap\\Omicron(f)\\)",
        "\\(\\Omicron(f)=\\Omega(f)\\cap\\Theta(f)\\)"
      ],
      "solution": 0
    },
    {
      "title": "快速排序算法将问题分为两个子问题。",
      "choices": [
        "\\(\\Omega(n)\\) 和 \\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "离散背包问题回溯解的时间复杂度为：",
      "choices": [
        "最坏情况下呈指数增长",
        "最坏情况下的二次",
        "任何情况下都是指数"
      ],
      "solution": 0
    },
    {
      "title": "在通过分支和修剪解决的图着色问题（为图的所有顶点着色所需的最小颜色数，以便没有两个相邻顶点保持相同颜色）中，乐观界限是假设的结果：",
      "choices": [
        "只要有剩余的顶点需要着色，就会使用与已使用的颜色不同的颜色。",
        "只需要多一种颜色",
        "除已使用的颜色外，不会使用其他颜色。"
      ],
      "solution": 2
    },
    {
      "title": "使用占据中心位置的向量元素作为枢轴的快速排序版本",
      "choices": [
        "不呈现相同大小实例的最佳和最坏情况",
        "当向量已经排序时，它的表现会更糟",
        "当向量排序时它表现得更好"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) 和 \\(k\\ne0\\) 这三种说法哪一个是错误的？",
      "choices": [
        "\\(f(n)\\in\\Omicron(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "我们有一套 \\(n\\) 正整数，我们想要找到 size 的子集 \\(m\\) 最低金额",
      "choices": [
        "贪心技术将给出最优解决方案",
        "最合适的是使用分支和剪枝技术，尽管在最坏的情况下，渐近时间成本（0时间复杂度）将是指数级的",
        "要找到解决方案，您必须尝试所有可能的组合 \\(m\\) 整体，因此分支和修剪技术对于返回没有任何贡献"
      ],
      "solution": 0
    },
    {
      "title": "快速排序和合并排序哪个算法渐近更快？",
      "choices": [
        "它们都同样快，因为两者的渐近时间成本都是 \\(\\Omicron(n\\log(n))\\)",
        "顾名思义，快速排序",
        "归并排序总是比快速排序快或相等（常量除外）"
      ],
      "solution": 0
    },
    {
      "title": "是 \\(f(n)\\) 递推关系的解 \\(f(n)=2f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\) 指出这三个表达式中哪一个是正确的：",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "以下哪些说法是正确的？",
      "choices": [
        "记忆化可防止递归算法重复解决同一问题",
        "迭代动态规划解决离散背包问题的优点是永远不会执行不必​​要的计算。",
        "迭代动态规划算法使用记忆来避免解决再次出现的相同子问题。"
      ],
      "solution": 0
    },
    {
      "title": "是 \\(g(n)= \\sum_{'{'}i=0{'}'}^{'{'}K{'}'}a_in^i\\)。",
      "choices": [
        "\\(g(n)\\in\\Omega(n^k)\\)",
        "另外两种说法都是错误的。",
        "\\(g(n)\\in\\Theta(n^k)\\)"
      ],
      "solution": 1
    },
    {
      "title": "指出这三个表达式中哪一个是错误的：",
      "choices": [
        "\\(\\Theta(n)\\cap\\Theta(n^2)\\)",
        "\\(\\Theta(n)\\cap\\Omicron(n)\\)",
        "\\(\\Theta(\\frac{'{'}n{'}'}{'{'}2{'}'})=\\Theta(n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "表示以下程序的渐近时间成本（或时间复杂度），作为 n 的函数： <pre><code>s=0; for(i=0; i<n; i++) for(j=i; j<n; j++) s+=n*i*j;</code></pre>",
      "choices": [
        "是 \\(\\Theta(n^2)\\)",
        "是 \\(\\Theta(n)\\)",
        "是 \\(\\Omicron(n^2)\\) 但不是 \\(\\Omega(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "是否属于 \\(3n^2\\) \\(\\Omicron(n^3)\\)？",
      "choices": ["不", "是的", "仅适用于 c = 1 且 n = 5"],
      "solution": 1
    },
    {
      "title": "利用乐观界限的回溯算法通过以下方式生成问题的可能解决方案...",
      "choices": [
        "由代表解决方案空间的树的最佳分支的估计引导的游览",
        "引导遍历优先级队列，首先从优先级队列中提取代表解决方案空间最有希望的子树的节点",
        "深度遍历代表解空间的树"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=0\\)",
      "choices": [
        "\\(f(n)\\in\\Theta(g(n))\\)",
        "\\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(f\\in\\Theta(g1)\\) 和 \\(f\\in\\Theta(g2)\\)",
      "choices": [
        "\\(f\\in\\Theta(g1*g2)\\)",
        "\\(f\\in\\Theta(g1+g2)\\)",
        "\\(f\\notin\\Theta(\\max{g1,g2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "我们希望通过使用动态规划来降低以下函数的时间复杂度。<pre><code>unsigned g(unsigned n, unsigned r) {'{'}\n\tif (r==0 || r==n)\n\t\treturn 1;\n\treturn g(n-1, r-1) + g(n-1, r);\n{'}'}</code></pre>",
      "choices": [
        "可以简化为线性",
        "二次",
        "该函数不满足应用动态规划的必要要求"
      ],
      "solution": 1
    },
    {
      "title": "以下哪些说法是错误的？",
      "choices": [
        "在某些优化问题中，贪心法只能获得某些实例的最优解，而对于许多其他实例则获得次优解。",
        "所有优化问题都有一个贪婪的解决方案，无论要解决的实例是什么，该解决方案都是最优的。",
        "对于某些优化问题，总是可以使用贪心策略获得最优解。"
      ],
      "solution": 1
    },
    {
      "title": "给定递推关系：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n（在哪里 \\(p\\) 和 \\(a\\) 是大于 1 的整数并且 \\(g(n)=n^k\\)，必须发生什么才能实现它？ \\(T(n)\\in\\Theta(n^k)\\)？",
      "choices": ["\\(p>a^k\\)", "\\(p < a^k\\)", "\\(p=a^k\\)"],
      "solution": 1
    },
    {
      "title": "背包问题的回溯解决方案和分支剪枝解决方案之间的主要区别是什么？",
      "choices": [
        "探索解决方案的顺序",
        "最坏情况下的渐近成本",
        "事实上，分支和修剪解决方案可以从贪婪的次优解决方案开始，而一次回溯则不能"
      ],
      "solution": 0
    },
    {
      "title": "时间复杂度（或渐近时间成本）充其量......",
      "choices": [
        "它是问题大小或大小的函数，必须为该问题的所有可能值定义该函数",
        "S 是算法求解可呈现的最小尺寸所花费的时间。",
        "前两条是真的"
      ],
      "solution": 0
    },
    {
      "title": "给定一个优化问题，什么时候可以应用回溯方法？",
      "choices": [
        "决策域是离散的或可离散的，这是一个必要（尽管不是充分）条件。",
        "决策域是离散的或可离散的是充分必要条件。",
        "决策域离散到可离散不仅是一个必要条件，而且也是一个必要条件。"
      ],
      "solution": 0
    },
    {
      "title": "以下递归关系表示递归算法的复杂度，其中 g(n) 是多项式函数：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n说出以下哪项陈述是正确的：",
      "choices": [
        "是的 \\(g(n)\\in\\Theta(n)\\) 递归率代表快速排序算法的最佳情况时间复杂度。",
        "是的 \\(g(n)\\in\\Theta(n)\\) 递归率代表快速排序算法最坏情况的时间复杂度",
        "是的 \\(g(n)\\in\\Theta(1)\\) 递归率代表快速排序算法的最佳情况时间复杂度。"
      ],
      "solution": 0
    },
    {
      "title": "基于分而治之方案的递归算法...",
      "choices": [
        "它永远不会有指数复杂性",
        "子问题的划分越公平，效率就越高。",
        "其他选项均正确"
      ],
      "solution": 1
    },
    {
      "title": "算法的时间成本符合以下递推方程：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &n=0 \\\\ n+\\sum_{'{'}j=0{'}'}^{'{'}n-1{'}'}T(j) &n>1\\end{'{'}cases{'}'}\\)\n\n该算法的渐近时间成本（或时间复杂度）是多少？",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "研究递推关系：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}q{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n（在哪里 \\(p\\) 和 \\(q\\) 是大于 1 的整数）。",
      "choices": ["动态规划", "分而治之", "分枝和修剪"],
      "solution": 1
    },
    {
      "title": "我们采用归并排序算法，不是将向量分为两部分，而是将其分为三部分。",
      "choices": [
        "\\(\\Theta(\\log n)\\)",
        "\\(\\Theta(n)\\)",
        "其他两个选项都不正确"
      ],
      "solution": 1
    },
    {
      "title": "这三个问题之一没有遵循贪婪方案的简单而有效的解决方案",
      "choices": [
        "背包问题依然存在",
        "不限制最大背包负载的谨慎背包问题",
        "改变的问题"
      ],
      "solution": 2
    },
    {
      "title": "“问题大小”是什么意思？",
      "choices": [
        "该问题的任何实例可以采用的最大值",
        "构成问题的参数数量",
        "编写该问题实例所需的内存空间量"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) 和 \\(k\\neq0\\)，这三个陈述哪一个是正确的？",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Omega(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 0
    },
    {
      "title": "递归关系...",
      "choices": [
        "当解决方案令人望而却步时，它们可以降低解决方案的临时成本",
        "它们递归地表达算法的时间成本",
        "仅当解决方案是分而治之类型时它们才会出现"
      ],
      "solution": 2
    },
    {
      "title": "快速排序和归并排序算法有共同点：",
      "choices": [
        "准时运行的 \\(\\Omicron(n)\\)",
        "谁运用分而治之的策略",
        "在不使用额外空间的情况下对向量进行排序"
      ],
      "solution": 1
    },
    {
      "title": "这三种表述哪一个是正确的？",
      "choices": [
        "\\(\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sube\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(2^n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "插入排序算法的时间成本为",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "有 \\(n\\) 不同的粉末状物质，我们希望生成所有不同的混合方式，且总重量不超过 1 克，因为我们的秤只能计数到 0.1 克的精度。",
      "choices": [
        "你不能，因为决策不是离散值。",
        "是的，你可以毫无问题。",
        "你不能，因为组合的数量是无限的。"
      ],
      "solution": 1
    },
    {
      "title": "以下函数的最佳情况时间复杂度是多少？<pre><code>void examen(vector<int> &v) {'{'}\n\tint i=0,j,x,n=v.size();\n\tbool permuta = 1;\n\twhile(n>0 && permuta) {'{'}\n\t\ti=i+1;\n\t\tpermuta=0;\n\t\tfor(j=n-1; j>=i; j--)\n\t\t\tif(v[j] < v[j-1]) {'{'}\n\t\t\t\tx=v[j];\n\t\t\t\tpermuta=1;\n\t\t\t\tv[j]=v[j-1];\n\t\t\t\tv[j-1]=x;\n\t\t\t{'}'}\n\t{'}'}\n{'}'}</code></pre>",
      "choices": [
        "这个函数没有更好的情况",
        "\\(\\Theta(n)\\)",
        "\\(\\Theta(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "以下哪些说法是错误的？",
      "choices": [
        "迭代动态规划算法使用记忆来避免解决再次出现的相同子问题。",
        "离散背包问题的迭代动态规划求解执行不必要的计算",
        "记忆化可防止简单的递归算法重复解决同一问题"
      ],
      "solution": 0
    },
    {
      "title": "设以下递推关系为\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n是的 \\(T(n)\\in\\Omicron(n)\\)我们会发现自己属于这三种情况中的哪一种？",
      "choices": ["\\(g(n)=n^2\\)", "\\(g(n)=1\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "下列表达式中，要么两个为真，一个为假，要么两个为假，一个为真。",
      "choices": [
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log_2(n){'}'})\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(4^{\\log_2(n)})\\sube\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(2^{\\log_2(n)})\\sub\\Omicron(n^2)\\sub\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "是的 \\(f\\in\\Theta(g_1)\\) 和 \\(f\\in\\Theta(g_2)\\)",
      "choices": [
        "\\(f^2\\in\\Theta(g_1\\cdot g_2)\\)",
        "其他两个选项都是正确的",
        "\\(f\\in\\Theta(\\max{g_1,g_2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "分支和剪枝算法的最佳情况复杂度",
      "choices": [
        "它总是随着要做的决定的数量呈指数增长",
        "它可以是要做出的决策数量的多项式",
        "它通常是多项式，其中包含每个决策的替代方案数量"
      ],
      "solution": 1
    },
    {
      "title": "最小复合函数的问题包括从一组给定函数中找到允许变换数字的最小组合序列 \\(\\) 在另一米。",
      "choices": [
        "使用布尔向量",
        "使用实数向量",
        "如果不设置函数应用总数的上限，则无法使用分支和剪枝来解决此问题。"
      ],
      "solution": 2
    },
    {
      "title": "功能 \\(\\gamma\\) 正半整数（如果减去 0.5 使其成为整数，则该数是半整数）的定义为<pre><code>double gamma(double n) {'{'}\n\tif(n == 0.5)\n\t\treturn sqrt(PI);\n\treturn n * gamma(n-1);\n{'}'}</code></pre>可以用迭代动态规划来计算吗？",
      "choices": [
        "否，因为仓库索引是实数而不是整数",
        "是的，但是时间复杂度并没有提高",
        "不，因为我们无法将中间结果存储在仓库中"
      ],
      "solution": 1
    },
    {
      "title": "这些表述中哪一个是错误的？",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(2n^2+3n+1\\in\\Omicron(n^3)\\)",
        "\\(n+n\\log(n)\\in\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "给定递推关系：\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ pT(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n（在哪里 \\(p\\) 和 \\(a\\) 是大于 1 的整数并且 \\(g(n)=n^k\\)），要实现它必须发生什么？ \\(T(n)\\in\\Theta(n^k\\log(n))\\)？",
      "choices": ["\\(p>a^k\\)", "\\(p=a^k\\)", "\\(p < a^k\\)"],
      "solution": 1
    },
    {
      "title": "当面对通过回溯解决的优化问题时，使用悲观和乐观界限会不会毫无用处，甚至有害？",
      "choices": [
        "根据边界的类型，悲观边界可能不会丢弃任何节点，但使用乐观边界可以保证搜索空间的减少",
        "不，乐观和悲观边界都保证了解决方案空间的减少，从而保证了算法的效率。",
        "是的，因为尽管使用这些维度，但有可能没有节点被丢弃"
      ],
      "solution": 2
    },
    {
      "title": "说出以下渐近时间成本结果中哪一个是错误的：",
      "choices": [
        "在最坏的情况下，有序向量中的二分搜索需要的时间为 \\(\\Omicron(\\log(n))\\)",
        "在最坏的情况下，使用快速排序算法对向量进行排序需要时间 \\(\\Omega(n^2)\\)",
        "在最坏的情况下，使用归并排序算法对向量进行排序需要的时间 \\(\\Omega(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "只要满足以下条件，问题就可以通过分而治之来解决：",
      "choices": ["遵守最优原则", "满足约简定理", "以上都不是"],
      "solution": 0
    },
    {
      "title": "我们通过什么编程方案获得计算两条链之间的编辑距离的算法？",
      "choices": ["动态规划", "分而治之", "两个都"],
      "solution": 0
    },
    {
      "title": "什么编程方案适合解决二分查找问题？",
      "choices": ["分而治之", "动态规划", "两者都不"],
      "solution": 0
    },
    {
      "title": "我们什么时候会使用动态规划而不是分而治之？",
      "choices": ["当空间成本降低时", "当效率提高时", "当效率提高时"],
      "solution": 1
    },
    {
      "title": "是的 \\(n\\) 是向量的元素数量，归并排序算法的成本为：",
      "choices": [
        "\\(\\Omicron(n^2)\\) 和 \\(\\Omega(n\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "\\(\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "给定二分搜索算法，假设我们不是将元素列表分成大小相等的两半，而是将其分成大小分别为 1/3 和 2/3 的两部分。",
      "choices": ["它比原来的小", "它比原来的大", "和原来的一样"],
      "solution": 1
    },
    {
      "title": "对于使用动态规划解决的优化问题，必须满足以下条件：",
      "choices": ["遵守最优原则", "满足约简定理", "遵守前两条"],
      "solution": 0
    },
    {
      "title": "斐波那契数列定义如下：\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\n以下哪种实施方式的成本最低？",
      "choices": ["分而治之", "动态规划", "两者具有相同的渐近成本"],
      "solution": 1
    },
    {
      "title": "在动态规划中，我们将在哪里存储已解决问题的值？",
      "choices": ["在二维向量中", "这取决于问题", "在一维向量中"],
      "solution": 1
    },
    {
      "title": "什么编程方案适合解决向量上的第 k 个最小值问题？",
      "choices": ["动态规划", "分而治之", "两者都不"],
      "solution": 1
    },
    {
      "title": "Quicksort排序算法采用什么算法方案？",
      "choices": ["动态规划", "分而治之", "回溯"],
      "solution": 1
    },
    {
      "title": "给出寻找向量的第 k 个最小值问题的递归解决方案。",
      "choices": ["两个或没有", "一个或两个", "一个或没有"],
      "solution": 2
    },
    {
      "title": "如果我们将动态规划应用于一个也有分治法解决方案的问题，我们可以确保：",
      "choices": [
        "相对于 D&V 解决方案，时间成本降低，空间成本增加。",
        "相对于 D&V 解决方案，时间成本增加，空间成本降低。",
        "以上都不是"
      ],
      "solution": 2
    },
    {
      "title": "当遇到提供递归解决方案的问题时，我们始终可以应用：",
      "choices": ["分而治之", "动态规划", "以上两项中的任何一项"],
      "solution": 0
    },
    {
      "title": "斐波那契数列定义如下：\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\n为了实现这个功能我们可以使用...",
      "choices": ["分而治之", "动态规划", "以上两项中的任何一项"],
      "solution": 2
    },
    {
      "title": "寻找向量的第 k 个最小值问题的解决方案实现了以下策略：",
      "choices": [
        "不对向量的任何元素进行排序",
        "对向量进行部分排序",
        "对向量进行完全排序"
      ],
      "solution": 1
    },
    {
      "title": "下列哪种情况不能适用分治法：",
      "choices": [
        "当子问题的大小相差很大时",
        "当问题不满足最优性原则时",
        "两种情况都可以应用"
      ],
      "solution": 2
    },
    {
      "title": "动态规划，为了解决问题，应用以下策略：",
      "choices": [
        "解决较小的问题，并通过组合解决方案，依次获得较大问题的解决方案，直到达到原始问题。",
        "将待解决的问题分解为更小的子问题，各个子问题独立求解，最终将子问题的解组合起来，得到原问题的解。",
        "以上都不是"
      ],
      "solution": 0
    },
    {
      "title": "让我们假设背包问题是通过动态规划解决的，并且具体为 \\(n\\) 元素和最大可运输重量 \\(P\\)。",
      "choices": ["是的", "不", "这取决于的值 \\(n\\) 和 \\(P\\)"],
      "solution": 1
    },
    {
      "title": "我们有两条长链 \\(m\\) 和 \\(n\\)。",
      "choices": [
        "\\((m-1)\\times(n-1)\\)",
        "\\(m\\times n\\)",
        "\\((m+1)\\times(n+1)\\)"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(n\\) 是向量的元素数量。",
      "choices": [
        "\\(\\Omega(n)\\) 和 \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(n)\\) 和 \\(\\Omicron(n^2)\\)",
        "两者都不是"
      ],
      "solution": 1
    },
    {
      "title": "是的 \\(n\\) 是向量的元素数量。",
      "choices": ["\\(\\Omicron(n^3)\\)", "\\(\\Omicron(n)\\)", "以上都不是"],
      "solution": 0
    },
    {
      "title": "给定一个问题的递归解决方案，我们如何避免多次解决相同的子问题？",
      "choices": [
        "从大到小解决子问题并将结果保存在表中，用小问题对其进行初始化",
        "从最大到最小解决子问题并将结果保存在表中，用最大的问题对其进行初始化",
        "从最小到最大解决子问题并将结果保存在表中，用小问题对其进行初始化"
      ],
      "solution": 2
    },
    {
      "title": "如果给定最优序列，则其解决方案可以由决策序列表示的优化问题符合最优原则：",
      "choices": [
        "该解的至少一个子序列与其相关子问题的最优解相对应。",
        "该解的一个子序列对应于其相关子问题的最优解",
        "该解的任何子序列都对应于其相关子问题的最优解。"
      ],
      "solution": 2
    },
    {
      "title": "是的 \\(n\\) 是向量的元素数量，二分查找问题的最低成本解决方案具有以下复杂度：",
      "choices": [
        "\\(\\Omega(\\log(n))\\) 和 \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(1)\\) 和 \\(\\Omicron(\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "解决向量上的第 k 个最小值问题的适当编程方案是什么？",
      "choices": ["动态规划", "分而治之", "两者都不是。"],
      "solution": 1
    },
    {
      "title": "使用分治策略可以最优地解决背包问题吗？",
      "choices": [
        "仅在背包有分隔的情况下",
        "仅适用于背包不分馏的情况",
        "是的，两种情况都适用"
      ],
      "solution": 1
    },
    {
      "title": "大小为整数的向量 \\(n\\) 在删除第一个元素并重新排列它的最佳情况下，组织为堆具有时间复杂度：",
      "choices": [
        "其他两个选项都不正确",
        "具有向量大小的常量",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "说出以下渐近时间成本结果中哪一个是错误的：",
      "choices": [
        "在最坏的情况下，使用快速排序算法对向量进行排序需要时间 \\(\\Omega(n^2)\\)",
        "在最坏的情况下，使用归并排序算法对向量进行排序需要的时间 \\(\\Omega(n^2)\\)",
        "在最坏的情况下，有序向量中的二分搜索需要的时间为 \\(\\log(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "使用占据第一个位置的向量元素作为基准的快速排序版本",
      "choices": [
        "当向量已经排序时，它的表现会更糟",
        "当向量已经排序时它表现得更好",
        "向量之前是否有序的事实并不影响该算法的时间复杂度。"
      ],
      "solution": 0
    },
    {
      "title": "下列表达式中，要么两个为真，一个为假，要么两个为假，一个为真。",
      "choices": [
        "\\(\\Theta(n^2)\\sub\\Theta(n^3)\\)",
        "\\(\\Omega(n^2)\\sub\\Omega(n^3)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "是 \\(f(n)\\) 递推关系的解 \\(f(n)=2*f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\)。",
      "choices": [
        "\\(f(n)\\in\\Theta(n)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "大小向量可用 \\(n\\) 其元素预先组织形成堆。",
      "choices": [
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "指示以下片段的复杂性（作为 n 的函数）：<pre><code>int a = 0;\nfor(int i = 0; i < n; i++)\n\tfor(int j = i; j > 0; j/=2)\n\t\ta += A[i][j];</code></pre>",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "令 f(n) 为递推关系的解... \\(f(n)=2f(n-1)+1; f(1)=1\\)\n指出这三个表达式中哪一个是正确的：",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(2^n)\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    }
  ]
}
