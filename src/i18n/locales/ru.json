{
  "questions": [
    {
      "title": "Цель состоит в том, чтобы найти кратчайший путь между двумя городами, используя таблицу расстояний между парами городов, где -1 означает отсутствие дороги. ",
      "choices": [
        "Не всегда гарантирует скорость",
        "Не гарантирует получение кратчайшего пути",
        "Это будет быстрее только в определенных случаях проблемы."
      ],
      "solution": 2
    },
    {
      "title": "Будучи проблемой оптимизации, в списке действующих узлов ветвления и обрезки...",
      "choices": [
        "Вводятся только перспективные узлы, то есть узлы, способные улучшить лучшее доступное на данный момент решение.",
        "Могут быть узлы неперспективные",
        "Остальные два варианта верны"
      ],
      "solution": 2
    },
    {
      "title": "Мы хотим получить все перестановки списка, состоящего из \\(n\\) элементы, какая схема является наиболее подходящей?",
      "choices": [
        "Разделяй и властвуй, поскольку разделение на подсписки может осуществляться за постоянное время.",
        "Ветвление и обрезка, поскольку с хорошими граничными функциями это более эффективно для этой задачи, чем возврат назад.",
        "Возвращаясь назад, для этой задачи нет более эффективной схемы."
      ],
      "solution": 2
    },
    {
      "title": "Решив задачу коммивояжера путем возврата и предположения графика \\(n\\) полносвязные вершины, какая из них является хорошей пессимистической границей при начале поиска?",
      "choices": [
        "Остальные ребра упорядочиваются от наименьшего к наибольшему расстоянию и вычисляется сумма ребер. \\(n\\) более короткие края",
        "Задача решается с помощью жадного алгоритма, который каждый раз добавляет к пути вершину, ближайшую к последней добавленной.",
        "Он умножается \\(n\\) на расстояние кратчайшего ребра, которое нам осталось рассмотреть"
      ],
      "solution": 1
    },
    {
      "title": "Если мы воспользуемся алгоритмом ветвления и сокращения и слегка адаптируем его, чтобы преобразовать в алгоритм обратного отслеживания, что мы действительно изменим?:",
      "choices": [
        "Мы заставляем оптимистические пределы терять эффективность",
        "Заменим данную функцию на пессимистическую оценку",
        "Было бы необходимо проверить, осуществимы ли решения или нет, поскольку ветвление и сокращение генерируют только возможные узлы."
      ],
      "solution": 0
    },
    {
      "title": "В чем основное различие между решением с обратным поиском и решением с ветвлением и обрезкой для задачи о рюкзаке?",
      "choices": [
        "Порядок исследования решений",
        "Тот факт, что решение ветвления и сокращения может начинаться с жадного неоптимального решения, а решение с возвратом не",
        "Асимптотическая стоимость в худшем случае"
      ],
      "solution": 0
    },
    {
      "title": "Вы хотите найти кратчайший путь между двумя городами.\n",
      "choices": [
        "Пессимистичная цитата",
        "Оптимистичный момент",
        "Это не будет сокращением, поскольку вполне возможно, что эта эвристика не найдет приемлемого решения."
      ],
      "solution": 1
    },
    {
      "title": "Преимущество стратегии ветвления и сокращения перед обратным отслеживанием состоит в том, что первая стратегия генерирует возможные решения проблемы с помощью...",
      "choices": [
        "Управляемый обход очереди приоритетов, из которой сначала извлекаются узлы, представляющие наиболее перспективные поддеревья пространства решений.",
        "Остальные два варианта верны",
        "Экскурсия, основанная на оценке лучших ветвей дерева, представляющего пространство решений."
      ],
      "solution": 1
    },
    {
      "title": "Стратегия возврата применима к задачам выбора и оптимизации, в которых:",
      "choices": [
        "Пространство решений представляет собой бесконечное множество",
        "Пространство решений представляет собой конечное множество",
        "Пространство решений может быть как конечным, так и бесконечным, но в последнем случае оно должно быть как минимум счетным."
      ],
      "solution": 1
    },
    {
      "title": "Вы хотите найти кратчайший путь между двумя городами.\n",
      "choices": [
        "Нет, поскольку это не гарантирует, что будет найдено осуществимое решение.",
        "Нет, так как в некоторых случаях он может давать расстояния меньше оптимального.",
        "Да, поскольку географическое расстояние гарантирует, что другое лучшее решение невозможно."
      ],
      "solution": 0
    },
    {
      "title": "Когда мы решаем проблему, используя схему ветвей и обрезки...",
      "choices": [
        "Решения могут быть только бинарными",
        "Значения, между которыми мы выбираем в каждом из решений, могут образовывать бесконечное множество",
        "Значения, между которыми мы выбираем в каждом из решений, должны образовывать конечное множество."
      ],
      "solution": 2
    },
    {
      "title": "Когда алгоритм обратного отслеживания решает проблему \\(n\\) решений, в которых всегда есть по крайней мере два варианта для каждого решения, с какой из следующих сложностей наихудшего случая мы можем столкнуться лучше всего?",
      "choices": ["\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)", "\\(\\Omicron(n!)\\)"],
      "solution": 0
    },
    {
      "title": "Наихудшая сложность алгоритма ветвления и сокращения:",
      "choices": [
        "Оно может быть экспоненциальным с количеством альтернатив для каждого решения.",
        "Это экспоненциально с количеством решений, которые нужно принять.",
        "Оно может быть полиномиальным по количеству принимаемых решений."
      ],
      "solution": 1
    },
    {
      "title": "В отсутствие оптимистических и пессимистических ограничений стратегия возврата...",
      "choices": [
        "Не может использоваться для решения задач оптимизации.",
        "Не проходит все дерево, если есть способ отбросить поддеревья, представляющие недопустимые множества решений.",
        "Он всегда должен проходить через все дерево"
      ],
      "solution": 1
    },
    {
      "title": "Вы хотите найти кратчайший путь между двумя городами.\n",
      "choices": [
        "Это была бы пессимистическая оценка, пока мы уверены, что это приближение находит допустимое решение.",
        "Это была бы оптимистичная оценка, пока есть уверенность в том, что этот подход найдет осуществимое решение.",
        "Ни один из двух других вариантов"
      ],
      "solution": 0
    },
    {
      "title": "Решите, какой из этих трех показателей не является оптимистической границей для получения оптимальной стоимости отдельного рюкзака:",
      "choices": [
        "Дискретное значение рюкзака, полученное с помощью жадного алгоритма, основанного на конкретной стоимости объектов.",
        "Стоимость соответствующего непрерывного рюкзака",
        "Стоимость рюкзака, вмещающего все предметы, даже если его вес превышает максимально допустимый вес."
      ],
      "solution": 0
    },
    {
      "title": "Сложность алгоритма ветвления и обрезки в наименьшем случае...",
      "choices": [
        "Обычно оно полиномиально с количеством альтернатив для каждого решения.",
        "Это всегда экспоненциально с количеством решений, которые нужно принять.",
        "Оно может быть полиномиальным по количеству принимаемых решений."
      ],
      "solution": 2
    },
    {
      "title": "Каковы пессимистические пределы ветвления и обрезки?",
      "choices": [
        "Чтобы отбросить узлы на основании предпочтения какого-либо другого уже завершенного узла",
        "Чтобы быть уверенным, что оптимистический предел правильно рассчитан.",
        "Чтобы отбросить узлы на основе ожидаемой прибыли"
      ],
      "solution": 2
    },
    {
      "title": "Является ли значение пессимистической границы в алгоритмах ветвления и сокращения меньше значения оптимистической границы?",
      "choices": [
        "Да, это всегда так",
        "В целом да, если это задача максимизации, хотя иногда оба значения могут совпадать",
        "В целом да, если это задача минимизации, хотя иногда оба значения могут совпадать"
      ],
      "solution": 1
    },
    {
      "title": "Стратегия ветвления и обрезки...",
      "choices": [
        "Вам нужны пессимистические оценки, чтобы определить порядок посещения узлов дерева решений.",
        "Чтобы определить, возможно ли решение",
        "Только если используется для решения задач оптимизации."
      ],
      "solution": 2
    },
    {
      "title": "В схеме, возвращающейся назад, механизмы обрезки основаны на лучшем на данный момент решении...",
      "choices": [
        "Предыдущие два верны",
        "Они гарантируют, что все пространство возможных решений никогда не будет исследовано.",
        "Они могут исключить частичные решения, которые осуществимы."
      ],
      "solution": 2
    },
    {
      "title": "Использование функций измерения для ветвления и обрезки...",
      "choices": [
        "Это гарантирует, что алгоритм будет более эффективным в любом случае задачи.",
        "Может уменьшить количество экземпляров проблем, относящихся к наихудшему случаю.",
        "Преобразуйте сложности, которые ранее были экспоненциальными, в полиномы"
      ],
      "solution": 1
    },
    {
      "title": "Решите, какая из этих трех пессимистических оценок наиболее близка к оптимальной стоимости дискретного рюкзака:",
      "choices": [
        "Стоимость соответствующего непрерывного рюкзака",
        "Стоимость рюкзака, вмещающего все предметы, даже если его вес превышает максимально допустимый вес.",
        "Дискретное значение рюкзака, полученное с помощью жадного алгоритма, основанного на конкретной стоимости объектов."
      ],
      "solution": 2
    },
    {
      "title": "В стратегии ветвления и обрезки...",
      "choices": [
        "Каждый узел имеет свою оптимистическую границу, однако пессимистическая граница является общей для всех узлов.",
        "Каждый узел имеет свою пессимистическую границу, а также свою оптимистическую границу.",
        "Каждый узел имеет свою пессимистическую оценку, однако оптимистическая граница является общей для всех узлов."
      ],
      "solution": 1
    },
    {
      "title": "В алгоритмах ветвления и обрезки:",
      "choices": [
        "Оптимистическая граница обязательно является непреодолимой ценностью, но если бы это было не так, узел, ведущий к оптимальному решению, мог бы быть обрезан.",
        "Оптимистическая граница обязательно является достижимой величиной, но если это не так, то не гарантируется, что оптимальное решение будет найдено.",
        "Использование пессимистических оценок эффективно только тогда, когда доступно возможное стартовое решение."
      ],
      "solution": 1
    },
    {
      "title": "Решите, какая из этих трех границ является оптимистической при использовании стратегии возврата для решения задачи о рюкзаке:",
      "choices": [
        "Стоимость рюкзака",
        "Оптимальная стоимость соответствующего непрерывного рюкзака",
        "Дискретное значение рюкзака, полученное с помощью жадного алгоритма, основанного на конкретной стоимости объекта."
      ],
      "solution": 1
    },
    {
      "title": "В алгоритмах ветвления и сокращения является ли значение пессимистической границы больше значения оптимистической границы? ",
      "choices": [
        "Нет, никогда не бывает так",
        "В целом да, если это задача максимизации, хотя иногда оба значения могут совпадать",
        "В целом да, если это задача минимизации, хотя иногда оба значения могут совпадать"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая любую задачу оптимизации, гарантирует ли стратегия поиска с возвратом оптимальное решение?",
      "choices": [
        "Необходимым условием является то, чтобы область принятия решений была дискретной или дискретизируемой и чтобы количество принимаемых решений было ограничено.",
        "Да, при условии, что область принятия решений является дискретной или дискретизируемой и используются механизмы сокращения, основанные на наилучшем на данный момент решении.",
        "Да, поскольку этот метод анализирует все возможности"
      ],
      "solution": 0
    },
    {
      "title": "Проблема распределения смен имеет решение:\n \\(\\Nu\\).  \\(\\Mu\\) с \\(\\Nu\\) строки, где каждый учащийся написал в соответствующей строке целое число (между \\(-1\\) и \\(\\Nu-1\\) что указывает на указанный приоритет (значение \\(-1\\) указывает на то, что вы не хотите или не можете быть с человеком из соответствующего столбца. \\(0\\) указывает на безразличие, и чем выше значение, тем больше предпочтения этому человеку).  \\(\\Mu\\) уже создан, разработайте алгоритм, оптимально решающий задачу.",
      "choices": [
        "Оптимизация с помощью возврата",
        "Приблизительный (неоптимальный) через жадный",
        "Оба"
      ],
      "solution": 2
    },
    {
      "title": "Время выполнения алгоритма ветвления и обрезки зависит от:",
      "choices": ["Экземпляр проблемы", "Функция выбора узлов для расширения", "От обоих"],
      "solution": 2
    },
    {
      "title": "Это задача оптимизации, если областью решения является бесконечное множество.",
      "choices": [
        "Мы можем применить схему поиска с возвратом всякий раз, когда это счетное бесконечное множество.",
        "Жадная стратегия может быть единственной альтернативой",
        "Вполне вероятно, что посредством динамического программирования будет получен эффективный алгоритм ее решения."
      ],
      "solution": 1
    },
    {
      "title": "Поиск с возвратом применим к задачам выбора и оптимизации, в которых:",
      "choices": [
        "Пространство решений представляет собой конечное множество",
        "В любом случае",
        "Пространство решений представляет собой бесконечное множество"
      ],
      "solution": 0
    },
    {
      "title": "Возврат — это общий метод решения проблем, основанный на:",
      "choices": [
        "Систематический поиск решений",
        "Непосредственное построение решения",
        "Ни один из вышеперечисленных"
      ],
      "solution": 0
    },
    {
      "title": "Вораз всегда дает оптимальное решение:",
      "choices": [
        "Как для",
        "К проблеме рюкзака без фракционирования",
        "К проблеме рюкзака с фракционированием"
      ],
      "solution": 2
    },
    {
      "title": "Находит ли проблема с рюкзаком оптимальное решение с помощью жадной стратегии?:",
      "choices": [
        "Только для корпуса рюкзака без дробления.",
        "В любом из вышеперечисленных случаев",
        "Только в случае с рюкзаком с разделением"
      ],
      "solution": 2
    },
    {
      "title": "Задачу коммивояжера можно правильно решить, используя следующие схемы программирования:",
      "choices": [
        "Только динамическое программирование",
        "Использование любого из них: жадность и возврат назад.",
        "Только возврат"
      ],
      "solution": 2
    },
    {
      "title": "В ненасытном методе, хотя решения необратимы, мы можем гарантировать, что:",
      "choices": [
        "Мы всегда найдем приемлемое решение",
        "Мы всегда найдем оптимальное решение",
        "Мы получим оптимальное решение только для некоторых задач."
      ],
      "solution": 2
    },
    {
      "title": "Применяя обратный поиск, мы получаем оптимальное решение задачи:",
      "choices": [
        "Всегда",
        "Только тогда, когда задача удовлетворяет принципу оптимальности",
        "В некоторых случаях"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая проблему, решаемую путем обратного отслеживания, а также путем ветвления и сокращения, вычислительные затраты на решение с помощью ветвления и сокращения по сравнению с решением с возвратом составляют:",
      "choices": ["Незначительный", "Равный", "Пожилые"],
      "solution": 1
    },
    {
      "title": "Задача о назначении смен имеет оптимальное решение, используя:\n \\(\\Nu\\).  \\(\\Mu\\) с \\(\\Nu\\) строки, где каждый учащийся написал в соответствующей строке целое число (между \\(-1\\) и \\(\\Nu-1\\) что указывает на указанный приоритет (значение \\(-1\\) указывает на то, что вы не хотите или не можете быть с человеком из соответствующего столбца. \\(0\\) указывает на безразличие, и чем выше значение, тем больше предпочтения этому человеку).  \\(\\Mu\\) уже создан, разработайте алгоритм, оптимально решающий задачу.",
      "choices": ["Возврат", "Прожорливый", "Оба"],
      "solution": 0
    },
    {
      "title": "Применяя возврат к решению задач, мы получаем алгоритмы с вычислительными затратами:",
      "choices": ["Экспоненты", "Полиномы", "Оба верны. "],
      "solution": 0
    },
    {
      "title": "Поиск с возвратом используется для решения задач оптимизации, цель которых состоит в том, чтобы найти:",
      "choices": [
        "Два предыдущих ответа верны",
        "Решение, которое удовлетворяет некоторым ограничениям и оптимизирует определенную целевую функцию.",
        "Все решения, удовлетворяющие некоторым ограничениям"
      ],
      "solution": 0
    },
    {
      "title": "Задача о назначении смен имеет жадное оптимальное решение, применяя следующую стратегию:\n \\(\\Nu\\).  \\(\\Mu\\) с \\(\\Nu\\) строки, где каждый учащийся написал в соответствующей строке целое число (между \\(-1\\) и \\(\\Nu-1\\) что указывает на указанный приоритет (значение \\(-1\\) указывает на то, что вы не хотите или не можете быть с человеком из соответствующего столбца. \\(0\\) указывает на безразличие, и чем выше значение, тем больше предпочтения этому человеку).  \\(\\Mu\\) уже создан, разработайте алгоритм, оптимально решающий задачу.",
      "choices": [
        "Задача не имеет оптимального решения",
        "Мы отбираем студентов в порядке убывания предпочтений, соблюдая ограничения по количеству мест каждой смены.",
        "Мы отбираем студентов в порядке возрастания предпочтений, соблюдая ограничения по количеству мест каждой смены."
      ],
      "solution": 0
    },
    {
      "title": "Можно ли решить проблему с рюкзаком с помощью обратного отслеживания?:",
      "choices": [
        "Только в случае с рюкзаком с разделением",
        "Только для корпуса рюкзака без дробления.",
        "Может применяться в обоих случаях"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая задачу оптимизации и жадный алгоритм, который ее решает, когда мы можем быть уверены, что полученное решение будет оптимальным?:",
      "choices": [
        "Прожорливый всегда находит оптимальное решение",
        "В обоих случаях. ",
        "Когда мы формально докажем, что критерий приводит к оптимальному решению для любого случая задачи"
      ],
      "solution": 2
    },
    {
      "title": "Проблема назначения смен, решаемая с помощью обратного отслеживания, имеет сложность:\n \\(\\Nu\\).  \\(\\Mu\\) с \\(\\Nu\\) строки, где каждый учащийся написал в соответствующей строке целое число (между \\(-1\\) и \\(\\Nu-1\\) что указывает на указанный приоритет (значение \\(-1\\) указывает на то, что вы не хотите или не можете быть с человеком из соответствующего столбца. \\(0\\) указывает на безразличие, и чем выше значение, тем больше предпочтения этому человеку).  \\(\\Mu\\) уже создан, разработайте алгоритм, оптимально решающий задачу.",
      "choices": ["Экспоненциальный", "Полиномиальный", "Ни один из двух"],
      "solution": 0
    },
    {
      "title": "Поиск с возвратом направлен на получение решения задачи оптимизации с помощью следующей стратегии:",
      "choices": [
        "Сгенерируйте все комбинации решения и выберите ту, которая оптимизирует целевую функцию.",
        "Сгенерируйте все возможные решения и выберите то, которое оптимизирует целевую функцию.",
        "Сгенерируйте возможное решение, используя оптимальный критерий"
      ],
      "solution": 1
    },
    {
      "title": "Дан граф G, который представляет города провинции Аликанте с населением более 20 000 человек, а также все соединяющие их дороги. ",
      "choices": [
        "Возможно, вы не найдете решения, даже если оно существует.",
        "Возможное решение",
        "Оптимальное решение"
      ],
      "solution": 1
    },
    {
      "title": "Если мы применим жадный алгоритм, который не гарантирует нам оптимальное решение проблемы, то...",
      "choices": [
        "Если задача имеет оптимальное решение, жадная схема гарантирует, что оно будет найдено.",
        "Мы получим приемлемое решение",
        "Возможно, вы не найдете решения, даже если оно существует."
      ],
      "solution": 2
    },
    {
      "title": "Жадный метод используется для решения задач выбора и оптимизации, целью которых является найти:",
      "choices": [
        "Два предыдущих ответа верны",
        "Все решения, удовлетворяющие некоторым ограничениям",
        "Решение, которое удовлетворяет некоторым ограничениям и оптимизирует определенную целевую функцию."
      ],
      "solution": 2
    },
    {
      "title": "Если применить схему поиска с возвратом, которая не гарантирует оптимального решения задачи, то",
      "choices": [
        "Мы получим приемлемое решение",
        "Возможно, вы не найдете решения, даже если оно существует.",
        "Ни один из вышеперечисленных"
      ],
      "solution": 2
    },
    {
      "title": "Стратегия ветвления и обрезки позволяет найти возможные решения проблемы за счет:",
      "choices": [
        "Глубокий обход дерева, представляющего пространство решений.",
        "Путь ширины, представляющий пространство решения",
        "Экскурсия, основанная на оценке лучших ветвей дерева, представляющего пространство решений."
      ],
      "solution": 2
    },
    {
      "title": "Учитывая проблему рекурсивного поиска с возвратом, каждый рекурсивный вызов генерирует сколько новых рекурсивных вызовов?:\n \\(\\Nu\\).  \\(\\Mu\\) с \\(\\Nu\\) строки, где каждый учащийся написал в соответствующей строке целое число (между \\(-1\\) и \\(\\Nu-1\\) что указывает на указанный приоритет (значение \\(-1\\) указывает на то, что вы не хотите или не можете быть с человеком из соответствующего столбца. \\(0\\) указывает на безразличие, и чем выше значение, тем больше предпочтения этому человеку).  \\(\\Mu\\) уже создан, разработайте алгоритм, оптимально решающий задачу.",
      "choices": ["Один или два", "Один или ни один", "Ни один из вышеперечисленных"],
      "solution": 2
    },
    {
      "title": "Какое из этих утверждений неверно?",
      "choices": [
        "В худшем случае сложность поиска с возвратом, а также решений ветвления и сокращения для одной и той же проблемы одинакова.",
        "Для одной и той же проблемы ветвление и сокращение всегда исследуют количество узлов, меньшее или равное значению обратного отслеживания.",
        "При обратном отслеживании проверяется все пространство решения проблемы, а при ветвлении и сокращении — нет."
      ],
      "solution": 2
    },
    {
      "title": "Если для решения той же проблемы мы используем алгоритм поиска с возвратом и минимально модифицируем его, чтобы превратить в алгоритм ветвления и сокращения, что мы действительно изменим?",
      "choices": [
        "Мы заменяем функцию, которую мы придаем пессимистической оценке",
        "Проверка допустимых решений: ветвление и обрезка не требуются, поскольку при этом генерируются только возможные узлы.",
        "Мы лучше используем оптимистические уровни"
      ],
      "solution": 2
    },
    {
      "title": "Обратное отслеживание генерирует возможные решения проблемы:",
      "choices": [
        "Путем обхода в глубину дерева, которое представляет пространство решений.",
        "Обходя ширину дерева, представляющего пространство решений.",
        "Ни один из вышеперечисленных"
      ],
      "solution": 0
    },
    {
      "title": "В задаче, решаемой обратным поиском, набор значений, которые могут принимать компоненты кортежа решения, должен быть:",
      "choices": ["бесконечный", "Непрерывный", "Конечный"],
      "solution": 2
    },
    {
      "title": "Какая схема будет наиболее подходящей, если в результате рекурсивной декомпозиции задачи образуются подзадачи одинакового размера?",
      "choices": [
        "Динамическое программирование",
        "Разделяй и властвуй, если гарантировано, что подзадачи не одинакового размера.",
        "Прожорливый метод"
      ],
      "solution": 0
    },
    {
      "title": "Использование функций измерения для ветвления и обрезки...",
      "choices": [
        "Может уменьшить количество экземпляров проблем, относящихся к наихудшему случаю.",
        "Это гарантирует, что алгоритм будет более эффективным в любом случае задачи.",
        "Преобразуйте сложности, которые ранее были экспоненциальными, в полиномы"
      ],
      "solution": 0
    },
    {
      "title": "Если задача оптимизации связана с функцией, принимающей непрерывные значения",
      "choices": [
        "Итеративное динамическое программирование всегда намного эффективнее рекурсивного динамического программирования с точки зрения использования памяти.",
        "Использование памяти при итеративном динамическом программировании и рекурсивном динамическом программировании одинаково независимо от того, является ли предметная область дискретной или непрерывной.",
        "Рекурсивное динамическое программирование может быть намного более эффективным, чем итеративное динамическое программирование, с точки зрения использования памяти."
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(f(n)\\in\\Omicron(n^3)\\), может ли такое случиться \\(f(n)\\in\\Omicron(n^2)\\)?",
      "choices": [
        "Не поэтому \\(n^3\\) Нет \\(\\in\\Omicron(n^2)\\)",
        "Это вполне возможно, поскольку \\(\\Omicron(n^2)\\sube\\Omicron(n^3)\\)",
        "Только для низких значений \\(n\\)"
      ],
      "solution": 1
    },
    {
      "title": "Пусть следующее рекуррентное соотношение будет\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nАга \\(T(n)\\in\\Omicron(n^2)\\)В каком из этих трёх случаев мы можем оказаться?",
      "choices": ["\\(g(n)=1\\)", "\\(g(n)=n^2\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "Наивное (но правильное) рекурсивное решение задачи оптимизации вызывает функцию с одними и теми же параметрами более одного раза. ",
      "choices": [
        "Эффективность алгоритма можно повысить, сохранив в таблице значение, возвращаемое для каждого набора параметров от каждого вызова, когда он происходит впервые.",
        "Эффективность алгоритма можно повысить, преобразуя рекурсивный алгоритм непосредственно в итеративный без изменения его основной операции.",
        "Эффективность алгоритма можно повысить, если заранее определить порядок вычисления решений подзадач и заполнить в этом порядке таблицу."
      ],
      "solution": 1
    },
    {
      "title": "Проблема с размером \\(n\\) можно преобразовать во время \\(\\Omicron(n^2)\\) в другом размере \\(n-1\\). ",
      "choices": ["\\(\\Omicron(n^3)\\)", "\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Когда жадный алгоритм используется для решения задачи оптимизации дискретного выбора (т. е. проблемы, решение которой состоит в том, чтобы найти подмножество набора элементов, оптимизирующее данную функцию), какую из этих трех вещей невозможно решить? случаться?",
      "choices": [
        "Решение не является оптимальным",
        "Алгоритм не находит решения",
        "Пересмотреть уже принятое ранее решение относительно выбора элемента с учетом решения, которое должно быть принято в текущий момент."
      ],
      "solution": 2
    },
    {
      "title": "Одна из этих трех задач не имеет эффективного решения, которое соответствует схеме динамического программирования.",
      "choices": [
        "Проблема сдержанного рюкзака",
        "Проблема башен Ханоя",
        "Задача разрезать трубку по длине \\(n\\) на сегменты целочисленной длины от 1 до \\(n\\) так, чтобы цена была максимальной в соответствии с таблицей, в которой указана цена для каждой длины"
      ],
      "solution": 1
    },
    {
      "title": "Какая из этих трех задач оптимизации не имеет или не имеет оптимального жадного решения?",
      "choices": [
        "Проблема сдержанного рюкзака",
        "Дерево покрытия минимальной стоимости подключенной сети",
        "Проблема непрерывного рюкзака или с фракционированием"
      ],
      "solution": 0
    },
    {
      "title": "Какой из следующих алгоритмов даст пессимистическую оценку задачи поиска кратчайшего пути между двумя городами (предполагается, что граф связен)",
      "choices": [
        "Рассчитайте геометрическое расстояние (по прямой) между городом отправления и назначения.",
        "Для всех городов, до которых можно добраться за один шаг от начального города, добавьте расстояние до этого города и геометрическое расстояние до города назначения.",
        "Рассчитайте пройденное расстояние, перемещаясь случайным образом по графику до достижения (случайно) города назначения."
      ],
      "solution": 2
    },
    {
      "title": "Учитывая любую задачу оптимизации, гарантирует ли стратегия поиска с возвратом оптимальное решение?",
      "choices": [
        "Да, при условии, что область принятия решений является дискретной или дискретизируемой и используются механизмы сокращения, основанные на наилучшем на данный момент решении.",
        "Да, поскольку этот метод анализирует все возможности",
        "Необходимым условием является то, чтобы область принятия решений была дискретной или дискретизируемой и чтобы количество принимаемых решений было ограничено."
      ],
      "solution": 2
    },
    {
      "title": "Для какой из этих задач оптимизации существует жадное решение?",
      "choices": [
        "Минимальное покрывающее дерево неориентированного графа с весами",
        "Проблема сдержанного рюкзака",
        "Проблема распределения минимальных затрат \\(n\\) задачи работникам, когда стоимость назначения задачи \\(i\\) рабочему \\(j\\), \\(C_{'{'}ij{'}'}\\) заносится в матрицу"
      ],
      "solution": 0
    },
    {
      "title": "Временная сложность в лучшем случае",
      "choices": [
        "Это время, которое требуется алгоритму для решения проблемы размера или наименьшего размера, которую можно представить.",
        "Это функция размера или размера проблемы, которую необходимо определить для всех возможных значений этого параметра.",
        "Остальные два варианта верны"
      ],
      "solution": 1
    },
    {
      "title": "Гарантирует ли использование стратегии «разделяй и властвуй» существование решения любой задачи с полиномиальной временной сложностью?",
      "choices": [
        "Да, но при условии, что совместная временная сложность операций декомпозиции задачи и комбинации решений является полиномиальной.",
        "Нет",
        "Да, в любом случае"
      ],
      "solution": 1
    },
    {
      "title": "Решите, какая из этих трех пессимистических оценок наиболее близка к оптимальной стоимости дискретного рюкзака:",
      "choices": [
        "Дискретное значение рюкзака, полученное с помощью жадного алгоритма, основанного на конкретной стоимости объектов.",
        "Стоимость рюкзака, вмещающего все предметы, даже если его вес превышает максимально допустимый вес.",
        "Стоимость соответствующего непрерывного рюкзака"
      ],
      "solution": 0
    },
    {
      "title": "Решая задачу коммивояжера методом обратного отслеживания, какую из этих оптимистических границ мы можем ожидать улучшить дерево поиска?",
      "choices": [
        "Остальная часть задачи решается с помощью жадного алгоритма, который каждый раз добавляет к пути вершину, ближайшую к последней добавленной.",
        "Остальные ребра упорядочиваются от кратчайшего к наибольшему расстоянию и вычисляется сумма k кратчайших ребер, где k — количество прыжков, которые нам осталось сделать.",
        "K умножается на расстояние кратчайшего ребра, которое осталось учесть, где k — количество прыжков, которые осталось совершить."
      ],
      "solution": 1
    },
    {
      "title": "Вы хотите найти кратчайший путь между двумя городами. ",
      "choices": [
        "Новый алгоритм не гарантирует, что он будет быстрее во всех возможных случаях проблемы.",
        "Эта стратегия не гарантирует получение кратчайшего пути.",
        "Новый алгоритм всегда будет быстрее"
      ],
      "solution": 0
    },
    {
      "title": "В алгоритмах ветвления и обрезки:",
      "choices": [
        "Оптимистическая граница не обязательно является непреодолимой ценностью; ",
        "Оптимистический предел обязательно является достижимым значением; ",
        "Пессимистическая граница — это максимальное значение, которого может достичь любой возможный узел, который не является оптимальным."
      ],
      "solution": 0
    },
    {
      "title": "Наилучшая сложность алгоритма ветвления и сокращения",
      "choices": [
        "Это всегда экспоненциально с количеством решений, которые нужно принять.",
        "Обычно оно полиномиально с количеством альтернатив для каждого решения.",
        "Оно может быть полиномиальным по количеству принимаемых решений."
      ],
      "solution": 2
    },
    {
      "title": "Значение, полученное жадным методом для дискретной задачи о рюкзаке, равно...",
      "choices": [
        "Верхняя граница оптимального значения",
        "Нижняя граница оптимального значения, но никогда не совпадающая с этим",
        "Нижняя граница оптимального значения, которое иногда может быть равно этому"
      ],
      "solution": 2
    },
    {
      "title": "В схеме порядок присвоения различных значений компонентам вектора, который будет содержать решение, пойдет обратно.",
      "choices": [
        "Остальные два варианта верны",
        "Может быть актуально, если используются механизмы сокращения, основанные на оптимистических оценках.",
        "Не имеет значения, если не используются механизмы обрезки, основанные на лучшем на данный момент решении."
      ],
      "solution": 0
    },
    {
      "title": "Наиболее известное решение задачи о непрерывном рюкзаке следует схеме",
      "choices": ["Разделяй и властвуй", "Прожорливый", "Ветвление и обрезка"],
      "solution": 1
    },
    {
      "title": "Пусть A — квадратная матрица \\(n\\times n\\). ",
      "choices": [
        "Если решение проблемы строится на основе схемы ветвления и сокращения, хороший выбор оптимистических и пессимистических границ позволит избежать исследования всех возможных перестановок.",
        "Временная сложность наилучшего возможного решения задачи равна \\(\\Omicron(n^2)\\)",
        "Временная сложность наилучшего возможного решения задачи равна \\(\\Omicron(n!)\\)"
      ],
      "solution": 1
    },
    {
      "title": "На сетке вы хотите нарисовать контур квадрата \\(n\\) боковые коробки. ",
      "choices": [
        "\\(\\Omicron(\\sqrt{'{'}n{'}'})\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая задачу оптимизации, жадный метод...",
      "choices": [
        "Вы всегда получаете оптимальное решение",
        "Вы всегда получаете реальное решение",
        "Гарантирует оптимальное решение только определенных проблем"
      ],
      "solution": 2
    },
    {
      "title": "Скажите, какой из этих трех алгоритмов не является алгоритмом «разделяй и властвуй»:",
      "choices": ["Быстрая сортировка", "Сортировка слиянием", "Алгоритм Прима"],
      "solution": 2
    },
    {
      "title": "При решении задачи о дискретном рюкзаке с использованием стратегии обратного отслеживания, может ли поиск оптимального решения занять меньше времени, если вы сначала попробуете положить каждый объект, прежде чем не класть его?",
      "choices": [
        "Нет, поскольку в любом случае необходимо изучить все возможные решения.",
        "Да, но только если для обрезки дерева поиска используются оптимистические границы.",
        "Да, независимо от того, используются ли оптимистические границы для обрезки дерева поиска или нет."
      ],
      "solution": 1
    },
    {
      "title": "Учитывая следующие функции, мы хотим уменьшить временную сложность функции \\(g\\) с использованием итеративного динамического программирования. <pre><code>// Precondición: {'{'} 0 <= i < v.size(); i < j <= v.size() {'}'}\nunsigned f(const vector<unsigned> &v, unsigned i, unsigned j) {'{'}\n\tif(i == j+1)\n\t\treturn v[i];\n\tunsigned sum = 0;\n\tfor(unsigned k = 0; k < j-i; k++)\n\t\tsum += f(v, i, i+k+1) + f(v, i+k+1, j);\n\treturn sum;\n{'}'}\n\nunsigned g(const vector<unsigned> &v) {'{'}\n\treturn f(v, v.begin(), v.end());\n{'}'}</code></pre>",
      "choices": ["квадратичный", "Экспоненциальный", "кубический"],
      "solution": 0
    },
    {
      "title": "В задаче оптимизации, если область решения представляет собой бесконечное множество,",
      "choices": [
        "Вполне вероятно, что посредством динамического программирования будет получен эффективный алгоритм ее решения.",
        "Жадная стратегия может быть единственной альтернативой",
        "Мы можем применить обратную схему всякий раз, когда это счетное бесконечное множество."
      ],
      "solution": 1
    },
    {
      "title": "Если для решения той же проблемы мы используем алгоритм поиска с возвратом и минимально модифицируем его, чтобы превратить в алгоритм ветвления и сокращения, что мы действительно изменим?",
      "choices": [
        "Алгоритм может лучше использовать оптимистические границы.",
        "Мы заменяем функцию, которую мы придаем пессимистической оценке",
        "Проверка допустимых решений: ветвление и обрезка не требуются, поскольку при этом генерируются только возможные узлы."
      ],
      "solution": 0
    },
    {
      "title": "Какая из этих задач имеет эффективное решение с помощью динамического программирования?",
      "choices": [
        "Сдержанный рюкзак без дополнительных ограничений.",
        "Проблема перемен",
        "Проблема с назначением задач"
      ],
      "solution": 1
    },
    {
      "title": "Следующая программа решает задачу разрезания трубы длиной \\(n\\) на сегменты целочисленной длины от 1 до \\(n\\) так, чтобы цена была максимальной по таблице, в которой указана цена для каждой длины, но не хватало куска. <pre><code>void fill(price r[]) {'{'}\n\tfor (index i=0; i <= n; i++) r[i] = -1;\n{'}'}\n\nprice cutrod(price p[], r[], length n) {'{'}\nprice q;\nif (r[n]>=0) return r[n];\nif (n==0) q=0;\nelse {'{'}\n\tq=-1;\n\tfor (index i=1; i<=n; i++)\n\tq=max(q,p[i]+cutrod(XXXXXXX));\n{'}'}\nr[n]=q;\nreturn q;\n{'}'}</code></pre>",
      "choices": ["п,р.н-р[н]", "п,р-1,1", "п, р, н-я"],
      "solution": 2
    },
    {
      "title": "В алгоритмах ветвления и сокращения является ли значение пессимистической границы больше значения оптимистической границы? ",
      "choices": [
        "Нет, никогда не бывает так",
        "В целом да, если это задача максимизации, хотя иногда оба значения могут совпадать",
        "В целом да, если это задача минимизации, хотя иногда оба значения могут совпадать"
      ],
      "solution": 2
    },
    {
      "title": "Одна из этих трех ситуаций невозможна:",
      "choices": [
        "\\(f(n)\\in\\Omicron(n)\\) и \\(f(n)\\in\\Omega(1)\\)",
        "\\(f(n)\\in\\Omega(n^2)\\) и \\(f(n)\\in\\Omicron(n)\\)",
        "\\(f(n)\\in\\Omicron(n)\\) и \\(f(n)\\in\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Улучшение, которое обычно обеспечивает динамическое программирование по сравнению с простым решением, достигается благодаря тому, что",
      "choices": [
        "При наивном решении редко решается относительно большое количество отдельных подзадач.",
        "Количество решений подзадач не имеет ничего общего с эффективностью решения задач с использованием динамического программирования.",
        "При наивном решении часто решается относительно небольшое количество различных подзадач."
      ],
      "solution": 2
    },
    {
      "title": "Версия быстрой сортировки, которая использует элемент вектора, занимающий первую позицию, в качестве опорной точки...",
      "choices": [
        "Он ведет себя лучше, когда вектор уже отсортирован.",
        "Не представляет лучший и худший случай для экземпляров одного и того же размера.",
        "Он ведет себя хуже, когда вектор уже отсортирован"
      ],
      "solution": 2
    },
    {
      "title": "В схеме, возвращающейся назад, механизмы обрезки основаны на лучшем на данный момент решении...",
      "choices": [
        "Остальные два варианта верны",
        "Они гарантируют, что все пространство возможных решений никогда не будет исследовано.",
        "Они могут исключить частичные решения, которые осуществимы."
      ],
      "solution": 2
    },
    {
      "title": "Рекурсивный алгоритм, основанный на схеме «разделяй и властвуй».",
      "choices": [
        "Он никогда не будет иметь экспоненциальную сложность.",
        "Предыдущие два верны.",
        "Чем более справедливо будет разделение на подзадачи, тем эффективнее."
      ],
      "solution": 2
    },
    {
      "title": "Вы хотите заказать разные числа от 1 до \\(n\\).  \\(n\\) логические значения, которые сначала инициализируются значением false. ",
      "choices": [
        "Да, поскольку сортировка слиянием \\(\\Omicron(n\\log(n))\\) а это \\(\\Omicron(n)\\)",
        "Нет, поскольку этот алгоритм должен пройти через вектор логических значений несколько раз.",
        "Только если \\(d\\log(d)>kn\\) (где \\(k\\) это константа, которая зависит от реализации)"
      ],
      "solution": 2
    },
    {
      "title": "Имеет ли смысл при ветвлении и сокращении использовать оптимистическую границу узлов в качестве критерия для упорядочивания списка действующих узлов?",
      "choices": [
        "Нет, оптимистичная граница используется только для определения перспективности n-кортежа.",
        "Да, хотя это не гарантия того, что это хорошая стратегия поиска.",
        "Да, если список активных узлов сортируется, это всегда должно выполняться в соответствии с критерием оптимистической границы."
      ],
      "solution": 1
    },
    {
      "title": "В схеме, возвращающейся назад, механизмы обрезки основаны на лучшем на данный момент решении:",
      "choices": [
        "Они могут исключить векторы, которые представляют собой возможные возможные решения.",
        "Они гарантируют, что не будет исследовано все пространство возможных решений.",
        "Оба других варианта верны"
      ],
      "solution": 0
    },
    {
      "title": "Мы хотим получить все перестановки списка, состоящего из \\(n\\) предметы. ",
      "choices": [
        "Разделяй и властвуй, поскольку разделение на подсписки может осуществляться за постоянное время.",
        "Возвращаясь назад, это наиболее эффективная схема для решения этой проблемы.",
        "Ветвление и обрезка, поскольку при хороших функциях возвышения это более эффективно, чем возвращение назад."
      ],
      "solution": 1
    },
    {
      "title": "В отсутствие оптимистических и пессимистических уровней стратегия возврата...",
      "choices": [
        "Не проходит все дерево, если есть способ отбросить поддеревья, представляющие недопустимые множества решений.",
        "Он всегда должен проходить через все дерево",
        "Не может использоваться для решения задач оптимизации."
      ],
      "solution": 0
    },
    {
      "title": "Прожорливая схема...",
      "choices": [
        "Гарантии найти решение любой проблемы, даже если оно может быть не оптимальным",
        "Возможно, вы не найдете решения, но если найдете, оно гарантированно будет оптимальным.",
        "Два других варианта оба ложны"
      ],
      "solution": 2
    },
    {
      "title": "Рекурсивный алгоритм, основанный на схеме «разделяй и властвуй».",
      "choices": [
        "Оба других варианта верны",
        "Он достигает максимальной эффективности, когда проблема с размером \\(n\\) делится на проблемы размера \\(\\frac{'{'}n{'}'}{'{'}a{'}'}\\)",
        "Он никогда не будет иметь экспоненциальную асимптотическую стоимость времени (0 временная сложность)."
      ],
      "solution": 1
    },
    {
      "title": "Когда в результате декомпозиции проблемы возникают подзадачи такого же размера, что и исходная, многие из которых повторяются, какая схема априори более подходит?",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Ветвление и обрезка"],
      "solution": 0
    },
    {
      "title": "Учитывая задачу лабиринта с тремя ходами, можно ли применить схему динамического программирования для получения пути выхода?",
      "choices": [
        "Нет, чтобы гарантировать, что путь выхода найден, необходимо применить исчерпывающие методы поиска, такие как возврат или ветвление и сокращение.",
        "Да, если вы существуете по этой схеме, вы всегда можете найти путь к выходу.",
        "Нет, с помощью этой схемы вы можете знать общее количество различных путей, ведущих к выходу, но не можете знать состав ни одного из них."
      ],
      "solution": 1
    },
    {
      "title": "Мы хотим решить задачу n-й степени (\\(x^n\\)), при условии, что \\(n\\) является четным, и будет использоваться следующая рекурсия:\n\\(pot(x, n) = pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'}) * pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'})\\) Какая схема окажется более эффективной с точки зрения временных затрат?",
      "choices": [
        "В этом случае и динамическое программирование, и разделяй и властвуй оказываются эквивалентными по временной сложности.",
        "Динамическое программирование",
        "Разделяй и властвуй"
      ],
      "solution": 1
    },
    {
      "title": "Решите, какая из этих трех оптимистических границ наиболее близка к оптимальной стоимости отдельного рюкзака:",
      "choices": [
        "Стоимость рюкзака, вмещающего все предметы, даже если его вес превышает максимально допустимый вес.",
        "Стоимость соответствующего непрерывного рюкзака",
        "Дискретное значение рюкзака, полученное с помощью жадного алгоритма, основанного на конкретной стоимости объектов."
      ],
      "solution": 1
    },
    {
      "title": "Одна из лабораторных практик заключалась в эмпирическом расчете средней временной сложности алгоритма векторной сортировки Quicksort, принимая в качестве дозорного элемент вектора, занимающий центральное положение. ",
      "choices": ["\\(n^2\\)", "\\(n\\log(n)\\)", "\\(n\\log^2(n)\\)"],
      "solution": 1
    },
    {
      "title": "Что выводится из \\(f(n)\\) и \\(g(n)\\) если оно выполнено \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=k\\)?",
      "choices": [
        "\\(g(n)\\in\\Omicron(f(n))\\) но \\(f(n)\\notin\\Omicron(g(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) и \\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) но \\(g(n)\\notin\\Omicron(f(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "Учитывая задачу лабиринта с тремя движениями, мы хотим узнать количество различных путей из исходного квадрата. \\((1, 1)\\) до коробки \\((n, m)\\) и для этого применяется схема «разделяй и властвуй». ",
      "choices": [
        "\\(nc(n, m) = nc(n - 1, m) + nc(n, m - 1) + nc(n - 1, m - 1)\\)",
        "\\(nc(n, m) = nc(n - 1, m) + nc(m - 1, n) + nc(n - 1, m - 1)\\)",
        "Ни одно из двух других повторений не соответствует схеме «разделяй и властвуй»."
      ],
      "solution": 0
    },
    {
      "title": "Пусть следующее рекуррентное соотношение будет:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nАга \\(T(n)\\in\\Omicron(n)\\)В каком из этих трёх случаев мы можем оказаться?",
      "choices": [
        "\\(g(n)=\\sqrt{'{'}n{'}'}\\)",
        "\\(g(n)=\\log(n)\\)",
        "Оба других варианта верны"
      ],
      "solution": 2
    },
    {
      "title": "Схема возвращения...",
      "choices": [
        "Гарантирует, что вы найдете оптимальное решение любой задачи дискретного выбора.",
        "Оба других варианта верны",
        "Его можно применить к любому типу проблем, хотя затраты времени высоки."
      ],
      "solution": 0
    },
    {
      "title": "Что произойдет, если пессимистическая граница узла соответствует недопустимому решению?",
      "choices": [
        "Алгоритм будет работать медленнее, потому что будет исследовано больше узлов, чем необходимо.",
        "Ничего особенного, пессимистические пределы не обязательно должны соответствовать возможным решениям.",
        "Что алгоритм будет неверным, поскольку узел, ведущий к оптимальному решению, может быть отброшен."
      ],
      "solution": 2
    },
    {
      "title": "Учитывая задачу лабиринта с тремя движениями, мы хотим знать количество различных путей от исходного ящика (1, 1) до ящика (n, m) и для этого применяется схема динамического программирования. ",
      "choices": [
        "Улучшение не гарантируется, поскольку рекурсивная версия с мемоизацией может быть хуже, чем версия, полученная по схеме «разделяй и властвуй».",
        "Из квадратичной сложности, которая была бы получена с помощью наивной, она была бы сведена к линейной с помощью мемоизации.",
        "Из экспоненциальной сложности, которая была бы получена с помощью наивного, она была бы сведена к полиномиальной с помощью мемоизации."
      ],
      "solution": 2
    },
    {
      "title": "Учитывая задачу лабиринта с тремя движениями, цель состоит в том, чтобы узнать длину кратчайшего пути выхода. ",
      "choices": [
        "Что на самом деле не является прожорливым алгоритмом, потому что критерий отбора не",
        "Это прожорливый алгоритм, но без гарантии решения проблемы.",
        "Что на самом деле это не прожорливый алгоритм, потому что принятые решения не должны пересматриваться"
      ],
      "solution": 0
    },
    {
      "title": "Учитывая следующую функцию:<pre><code>int exa(vector<int> &v) {'{'}\n\tint j, i=1, n=v.size();\n\n\tif (n>1) do {'{'}\n\t\tint x = v[i];\n\t\tfor(j=i; j>0 && v[j-1] > x; j++)\n\t\t\tv[j]=v[j-1];\n\t\tv[j]=x;\n\t\ti++;\n\t{'}'} while(i<n);\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "Временная сложность в лучшем случае \\(\\Omega(n)\\)",
        "Временная сложность в лучшем случае \\(\\Omega(1)\\)",
        "Точная временная сложность \\(\\Theta(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Какая стратегия поиска априори является наиболее подходящей в схеме поиска с возвратом?",
      "choices": [
        "Сначала исследуйте узлы с наилучшей оптимистичной границей.",
        "Сначала изучите наиболее полные узлы",
        "Стратегии поиска не могут быть определены в схеме поиска с возвратом."
      ],
      "solution": 2
    },
    {
      "title": "Учитывая проблему Ханойских башен, решенную методом «разделяй и властвуй», какое из следующих рекуррентных соотношений лучше всего выражает ее временную сложность для общего случая: \\(n\\) количество дисков?",
      "choices": ["\\(T(n)=T(n-1)+n\\)", "\\(T(n)=2T(n-1)+1\\)", "\\(T(n)=2T(n-1)+n\\)"],
      "solution": 1
    },
    {
      "title": "Если временные затраты алгоритма \\(T(n)\\), какая из следующих ситуаций невозможна?",
      "choices": [
        "\\(T(n)\\in\\Omicron(n)\\) и \\(T(n)\\in\\Theta(n)\\)",
        "\\(T(n)\\in\\Theta(n)\\) и \\(T(n)\\in\\Omega(n^2)\\)",
        "\\(T(n)\\in\\Omega(n)\\) и \\(T(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Тюбик \\(n\\) длиной сантиметра можно разрезать на отрезки по 1 сантиметру, 2 сантиметра и т. д. ",
      "choices": [
        "Вектор логических значений",
        "Таблица, в которой для каждой позиции, где будет производиться резка, указаны все возможные накопленные значения.",
        "Пара целых чисел, обозначающих сделанные разрезы и накопленное значение."
      ],
      "solution": 0
    },
    {
      "title": "Какова будет временная сложность следующей функции после применения динамического программирования?<pre><code>double f(int n, int m) {'{'}\n\tif(n == 0) return 1;\n\treturn m * f(n-1,m) * f(n-2,m);\n{'}'}</code></pre>",
      "choices": ["\\(\\Theta(n^2)\\)", "\\(\\Theta(n\\times m)\\)", "\\(\\Theta(n)\\)"],
      "solution": 2
    },
    {
      "title": "Учитывая следующую функцию: <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\tif (n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j;i<n;i++)\n\t\t\t\tsum+=v[i];\n\t\t\tif(j==0) sum=100;\n\t\t{'}'}\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>",
      "choices": [
        "Временная сложность в лучшем случае \\(\\Omega(n)\\)",
        "Временная сложность в худшем случае равна \\(\\Omega(1)\\)",
        "Временная сложность в худшем случае равна \\(\\Omega(n\\log(n))\\)"
      ],
      "solution": 0
    },
    {
      "title": "Асимптотические затраты времени на вставку элемента в упорядоченный вектор, чтобы он оставался упорядоченным, составляют:",
      "choices": ["\\(\\Omicron(\\log(n))\\)", "\\(\\Omega(n^2)\\)", "\\(\\Omicron(n)\\)"],
      "solution": 2
    },
    {
      "title": "Учитывая задачу максимизации, решенную с использованием схемы ветвей и сокращений, что произойдет, если оптимистическая граница окажется слишком высоким значением?",
      "choices": [
        "Можно было бы исследовать меньше узлов, чем необходимо.",
        "Вы можете сократить узел, который ведет к оптимальному решению.",
        "Что вы можете исследовать больше узлов, чем необходимо"
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(f\\in\\Omega(g1)\\) и \\(f\\in\\Omega(g2)\\) так:",
      "choices": [
        "\\(f\\in\\Omega(g1*g2)\\)",
        "\\(f\\notin\\Omega(\\min(g1*g2))\\)",
        "\\(f\\in\\Omega(g1+g2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Какую сложность получается из рекуррентного соотношения \\(T(n)=8T(\\frac{'{'}n{'}'}{'{'}2{'}'})+n^3\\) с \\(T(1)=\\Omicron(1)\\)?",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(n^3\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "В задаче о коммивояжере мы хотим перечислить все возможные решения.",
      "choices": [
        "Самое главное — получить соответствующий пессимистический предел.",
        "Порядок, в котором исследуются частичные решения, не имеет значения; ",
        "Наиболее подходящим было бы использование техники ветвления и сокращения, поскольку порядок, в котором исследуются частичные решения, очень важен."
      ],
      "solution": 1
    },
    {
      "title": "Учитывая следующую функцию, где \\(\\max(a,b)\\in\\Theta(1)\\):<pre><code>float exa(vector<float> &v, vector<int> &p, int P, int i) {'{'}\n\tfloat a, b;\n\tif (i>=0) {'{'}\n\t\tif (p[i] <= P)\n\t\t\ta = v[i]*exa(v,p,P-p[i],i-1);\n\t\telse a=0;\n\t\tb=exa(v,p,P,i-1);\n\t\treturn max(a,b);\n\t{'}'}\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "Временная сложность в лучшем случае \\(\\Omega(n^2)\\)",
        "Временная сложность в худшем случае равна \\(\\Omicron(n^2)\\)",
        "Временная сложность в лучшем случае \\(\\Omicron(2^n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Какая структура в схеме ветвления и сокращения является наиболее подходящей, если мы хотим выполнить исследование уровня?",
      "choices": ["приоритетная очередь", "Линия", "Куча"],
      "solution": 1
    },
    {
      "title": "Учитывая следующую функцию:<pre><code>int exa(string &cad, int pri, int ult) {'{'}\n\tif(pri>=ult)\n\t\treturn 1;\n\telse\n\t\tif (cad[pri]==cad[ult])\n\t\t\treturn exa(cad, pri+1, ult-1);\n\t\telse\n\t\t\treturn 0;\n{'}'}</code></pre>Какова его асимптотическая временная сложность?",
      "choices": ["\\(\\Omicron(n)\\)", "\\(\\Omicron(\\log(n))\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Учитывая задачу лабиринта с тремя ходами, какая из следующих стратегий обеспечит оптимистическую границу ветвления и обрезки?",
      "choices": [
        "Предположим, что с этого момента все места лабиринта доступны.",
        "Предположим, что больше никаких движений совершаться не будет.",
        "Обе другие стратегии верны."
      ],
      "solution": 2
    },
    {
      "title": "Из следующих выражений либо два истинны, а одно ложно, либо два ложны и одно истинно. ",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(\\Omicron(2^{'{'}\\log(n){'}'}\\sub\\Omicron(n^2))\\)",
        "\\(\\Theta(n)\\sub\\Theta(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Что дает нам среднее между асимптотическими затратами времени в худшем случае и асимптотическими затратами времени в лучшем случае?",
      "choices": [
        "Средняя стоимость времени",
        "Асимптотические затраты времени в среднем случае",
        "Ничего интересного"
      ],
      "solution": 2
    },
    {
      "title": "Вы хотите отсортировать связанный список \\(n\\) элементы с использованием алгоритма Mergesort. ",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "Ни один из двух других вариантов не верен"
      ],
      "solution": 1
    },
    {
      "title": "Учитывая задачу лабиринта с тремя движениями, мы хотим знать количество различных путей от исходного ящика (1,1) до ящика (n, m), и для этого применяется схема динамического программирования для получения наиболее эффективного алгоритма. возможно с точки зрения временной и пространственной сложности. ",
      "choices": [
        "Временный \\(\\Theta(n\\times m)\\) и пространственный \\(\\Theta(n\\times m)\\)",
        "Временный \\(\\Theta(\\max{n}{m})\\) и пространственный \\(\\Theta(\\max{n}{m})\\)",
        "Временный \\(\\Theta(n\\times m)\\) и пространственный \\(\\Theta(\\min{'{'}n{'}'}{'{'}m{'}'})\\)"
      ],
      "solution": 2
    },
    {
      "title": "Укажите, какое из следующих утверждений верно.",
      "choices": [
        "Пессимистические пределы несовместимы со схемой обратного отслеживания.",
        "В обратной схеме пессимистические пределы не имеют смысла, если цель состоит в том, чтобы получить все возможные решения.",
        "Схема обратного отслеживания несовместима с совместным использованием пессимистических и оптимистических оценок."
      ],
      "solution": 1
    },
    {
      "title": "Учитывая задачу минимизации, решенную с использованием схемы ветвей и сокращений, какому свойству удовлетворяет оптимистическая оценка?",
      "choices": [
        "Оно всегда больше или равно наилучшему возможному решению.",
        "Обеспечивает экономию при тестировании всех возможных решений.",
        "Два других варианта оба ложны"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая следующую функцию <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\t if(n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j; i<n; i++)\n\t\t\t\tsum=v[i];\n\t\t\tif (j==0) sum=100;\n\t\t{'}'};\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>Отметьте правильный ответ:",
      "choices": [
        "Точная временная сложность \\(\\Theta(n\\log(n))\\)",
        "Временная сложность в лучшем случае \\(\\Omega(n)\\)",
        "Временная сложность в лучшем случае \\(\\Omega(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Можно ли сократить временные затраты рекурсивного алгоритма за счет сохранения результатов, возвращаемых рекурсивными вызовами?",
      "choices": [
        "Нет, снизить стоимость можно только за счет преобразования рекурсивного алгоритма в итеративный",
        "Да, если повторяются вызовы функций с теми же аргументами",
        "Нет, это не уменьшает временные затраты, поскольку рекурсивные вызовы все равно необходимо выполнять."
      ],
      "solution": 1
    },
    {
      "title": "Из следующих выражений либо два истинны, а одно ложно, либо два ложны и одно истинно. ",
      "choices": [
        "\\(\\Theta(f)=\\Omicron(f)\\cap\\Omega(f)\\)",
        "\\(\\Omega(f)=\\Theta(f)\\cap\\Omicron(f)\\)",
        "\\(\\Omicron(f)=\\Omega(f)\\cap\\Theta(f)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Алгоритм быстрой сортировки делит проблему на две подзадачи. ",
      "choices": [
        "\\(\\Omega(n)\\) и \\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "Временная сложность решения задачи с обратным поиском дискретного рюкзака равна:",
      "choices": [
        "Экспоненциальный в худшем случае",
        "Квадратичный в худшем случае",
        "Экспоненциально в любом случае"
      ],
      "solution": 0
    },
    {
      "title": "В задаче о раскраске графа (минимальное количество цветов, необходимых для окраски всех вершин графа так, чтобы никакие две соседние вершины не оставались одного цвета), решаемой путем ветвления и обрезки, оптимистическая граница является результатом предположения, что:",
      "choices": [
        "Будет использовано столько цветов, отличных от уже использованных, сколько осталось вершин для раскрашивания.",
        "Нужен будет только еще один цвет",
        "Цвета, отличные от уже использованных, использоваться не будут."
      ],
      "solution": 2
    },
    {
      "title": "Версия быстрой сортировки, в которой векторный элемент, занимающий центральное положение, используется в качестве опорной точки.",
      "choices": [
        "Не представляет лучший и худший случай для экземпляров одного и того же размера.",
        "Он ведет себя хуже, когда вектор уже отсортирован",
        "Он ведет себя лучше, когда вектор отсортирован"
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) и \\(k\\ne0\\) Какое из этих трех утверждений неверно?",
      "choices": [
        "\\(f(n)\\in\\Omicron(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "У нас есть набор \\(n\\) положительные целые числа, и мы хотим найти подмножество размера \\(m\\) минимальная сумма",
      "choices": [
        "Жадный метод даст оптимальное решение",
        "Наиболее подходящим было бы использование метода ветвления и сокращения, хотя в худшем случае асимптотические временные затраты (0 временная сложность) были бы экспоненциальными.",
        "Чтобы найти решение, вам придется попробовать все возможные комбинации \\(m\\) целом, поэтому техника ветвления и обрезки ничего не дает в отношении возвращения назад"
      ],
      "solution": 0
    },
    {
      "title": "Какой алгоритм асимптотически быстрее: быстрая сортировка или сортировка слиянием?",
      "choices": [
        "Они оба одинаково быстры, поскольку асимптотическая временная стоимость обоих равна \\(\\Omicron(n\\log(n))\\)",
        "Как следует из названия, быстрая сортировка",
        "Сортировка слиянием всегда быстрее или равна (за исключением константы), чем быстрая сортировка."
      ],
      "solution": 0
    },
    {
      "title": "Быть \\(f(n)\\) решение рекуррентного соотношения \\(f(n)=2f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\) Укажите, какое из этих трех выражений верно:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Какое из этих утверждений верно?",
      "choices": [
        "Мемоизация не позволяет рекурсивному алгоритму повторно решать одну и ту же задачу.",
        "Преимущество решения задачи о дискретном рюкзаке с помощью итеративного динамического программирования состоит в том, что ненужные вычисления никогда не выполняются.",
        "Алгоритмы итеративного динамического программирования используют мемоизацию, чтобы избежать повторного решения одних и тех же подзадач."
      ],
      "solution": 0
    },
    {
      "title": "Быть \\(g(n)= \\sum_{'{'}i=0{'}'}^{'{'}K{'}'}a_in^i\\). ",
      "choices": [
        "\\(g(n)\\in\\Omega(n^k)\\)",
        "Два других утверждения ложны.",
        "\\(g(n)\\in\\Theta(n^k)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Укажите, какое из этих трех выражений неверно:",
      "choices": [
        "\\(\\Theta(n)\\cap\\Theta(n^2)\\)",
        "\\(\\Theta(n)\\cap\\Omicron(n)\\)",
        "\\(\\Theta(\\frac{'{'}n{'}'}{'{'}2{'}'})=\\Theta(n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Указывает асимптотические временные затраты (или временную сложность) в зависимости от n следующей программы: <pre><code>s=0; for(i=0; i<n; i++) for(j=i; j<n; j++) s+=n*i*j;</code></pre>",
      "choices": [
        "Является \\(\\Theta(n^2)\\)",
        "Является \\(\\Theta(n)\\)",
        "Является \\(\\Omicron(n^2)\\) но нет \\(\\Omega(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Это принадлежит? \\(3n^2\\) \\(\\Omicron(n^3)\\)?",
      "choices": ["Нет", "Ага", "Только для c = 1 и n = 5"],
      "solution": 1
    },
    {
      "title": "Алгоритмы обратного отслеживания, использующие оптимистические границы, генерируют возможные решения проблемы с помощью...",
      "choices": [
        "Экскурсия, основанная на оценке лучших ветвей дерева, представляющих пространство решений.",
        "Управляемый обход очереди приоритетов, из которой сначала извлекаются узлы, представляющие наиболее перспективные поддеревья пространства решений.",
        "Глубокий обход дерева, представляющего пространство решений."
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=0\\)",
      "choices": [
        "\\(f(n)\\in\\Theta(g(n))\\)",
        "\\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(f\\in\\Theta(g1)\\) и \\(f\\in\\Theta(g2)\\)",
      "choices": [
        "\\(f\\in\\Theta(g1*g2)\\)",
        "\\(f\\in\\Theta(g1+g2)\\)",
        "\\(f\\notin\\Theta(\\max{g1,g2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "Мы хотим уменьшить временную сложность следующей функции с помощью динамического программирования. <pre><code>unsigned g(unsigned n, unsigned r) {'{'}\n\tif (r==0 || r==n)\n\t\treturn 1;\n\treturn g(n-1, r-1) + g(n-1, r);\n{'}'}</code></pre>",
      "choices": [
        "Можно свести к линейному.",
        "квадратичный",
        "Функция не соответствует необходимым требованиям для применения динамического программирования."
      ],
      "solution": 1
    },
    {
      "title": "Какое из этих утверждений неверно?",
      "choices": [
        "Существуют задачи оптимизации, в которых жадный метод позволяет получить оптимальное решение только для некоторых случаев и субоптимальное решение для многих других случаев.",
        "Все задачи оптимизации имеют жадное решение, оптимальное для любого случая решения.",
        "Существуют задачи оптимизации, для которых оптимальное решение всегда можно получить с помощью жадной стратегии."
      ],
      "solution": 1
    },
    {
      "title": "Учитывая рекуррентное соотношение:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(где \\(p\\) и \\(a\\) являются целыми числами больше 1 и \\(g(n)=n^k\\), что должно произойти, чтобы оно исполнилось? \\(T(n)\\in\\Theta(n^k)\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p < a^k\\)", "\\(p=a^k\\)"],
      "solution": 1
    },
    {
      "title": "В чем основное различие между решением с обратным поиском и решением с ветвлением и обрезкой для задачи о рюкзаке?",
      "choices": [
        "Порядок исследования решений",
        "Асимптотическая стоимость в худшем случае",
        "Тот факт, что решение ветвления и сокращения может начинаться с жадного неоптимального решения, а решение с возвратом не"
      ],
      "solution": 0
    },
    {
      "title": "Временная сложность (или асимптотическая стоимость времени) в лучшем случае...",
      "choices": [
        "Это функция размера или размера проблемы, которую необходимо определить для всех возможных значений этой",
        "S — это время, необходимое алгоритму для решения задачи наименьшего размера, который может быть представлен.",
        "Предыдущие два верны"
      ],
      "solution": 0
    },
    {
      "title": "Учитывая проблему оптимизации, когда можно применить метод обратного отслеживания?",
      "choices": [
        "Необходимым (хотя и не достаточным) условием является дискретность или дискретизируемость области принятия решений.",
        "Дискретность или дискретизируемость области принятия решений является необходимым и достаточным условием.",
        "Это не только необходимое условие, чтобы область принятия решений была дискретной или дискретизируемой; "
      ],
      "solution": 0
    },
    {
      "title": "Следующее рекуррентное соотношение выражает сложность рекурсивного алгоритма, где g(n) — полиномиальная функция:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nСкажите, какое из следующих утверждений верно:",
      "choices": [
        "Ага \\(g(n)\\in\\Theta(n)\\) Коэффициент повторения представляет собой временную сложность алгоритма быстрой сортировки в лучшем случае.",
        "Ага \\(g(n)\\in\\Theta(n)\\) коэффициент повторения представляет собой наихудшую временную сложность алгоритма сортировки Quicksort.",
        "Ага \\(g(n)\\in\\Theta(1)\\) Коэффициент повторения представляет собой временную сложность алгоритма быстрой сортировки в лучшем случае."
      ],
      "solution": 0
    },
    {
      "title": "Рекурсивный алгоритм, основанный на схеме «разделяй и властвуй».",
      "choices": [
        "Он никогда не будет иметь экспоненциальную сложность",
        "Чем более справедливо будет разделение на подзадачи, тем эффективнее.",
        "Остальные варианты верны"
      ],
      "solution": 1
    },
    {
      "title": "Временные затраты алгоритма соответствуют следующему рекуррентному уравнению:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &n=0 \\\\ n+\\sum_{'{'}j=0{'}'}^{'{'}n-1{'}'}T(j) &n>1\\end{'{'}cases{'}'}\\)\n\nКакую асимптотическую стоимость времени (или временную сложность) будет иметь алгоритм?",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(2^n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 1
    },
    {
      "title": "Изучите рекуррентные отношения:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}q{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(где \\(p\\) и \\(q\\) являются целыми числами больше 1). ",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Ветвление и обрезка"],
      "solution": 1
    },
    {
      "title": "Берем алгоритм Mergesort и вместо того, чтобы делить вектор на две части, делим его на три. ",
      "choices": [
        "\\(\\Theta(\\log n)\\)",
        "\\(\\Theta(n)\\)",
        "Ни один из двух других вариантов не верен"
      ],
      "solution": 1
    },
    {
      "title": "Ни одна из этих трех задач не имеет тривиального и эффективного решения по жадной схеме.",
      "choices": [
        "Проблема с рюкзаком продолжается",
        "Проблема незаметного рюкзака без ограничения максимальной нагрузки на рюкзак.",
        "Проблема перемен"
      ],
      "solution": 2
    },
    {
      "title": "Что подразумевается под «размером проблемы»?",
      "choices": [
        "Максимальное значение, которое может принять любой экземпляр этой проблемы.",
        "Количество параметров, составляющих задачу",
        "Объем памяти, необходимый для кода экземпляра этой проблемы."
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) и \\(k\\neq0\\), какое из этих трех утверждений верно?",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Omega(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Рекуррентные отношения...",
      "choices": [
        "Они служат для снижения временной стоимости решения, когда она непомерно высока.",
        "Они рекурсивно выражают временные затраты алгоритма.",
        "Они появляются только тогда, когда решение носит тип «разделяй и властвуй»."
      ],
      "solution": 2
    },
    {
      "title": "Алгоритмы сортировки Quicksort и Mergesort имеют общие черты:",
      "choices": [
        "которые работают вовремя \\(\\Omicron(n)\\)",
        "Кто применяет стратегию «разделяй и властвуй»",
        "Какая сортировка вектора без использования дополнительного пространства"
      ],
      "solution": 1
    },
    {
      "title": "Какое из этих трех выражений верно?",
      "choices": [
        "\\(\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sube\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(2^n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Временные затраты алгоритма сортировки вставками составляют",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(n^2)\\)", "\\(\\Omicron(n)\\)"],
      "solution": 1
    },
    {
      "title": "Иметь \\(n\\) различные порошкообразные вещества, и мы хотим создать все возможные способы их смешивания с общим весом, не превышающим одного грамма, поскольку наши весы учитывают точность только до 0,1 грамма. ",
      "choices": [
        "Вы не можете этого сделать, потому что решения не являются дискретными значениями.",
        "Да, можно без проблем.",
        "Невозможно из-за бесконечного количества комбинаций."
      ],
      "solution": 1
    },
    {
      "title": "Какова наилучшая временная сложность следующей функции?<pre><code>void examen(vector<int> &v) {'{'}\n\tint i=0,j,x,n=v.size();\n\tbool permuta = 1;\n\twhile(n>0 && permuta) {'{'}\n\t\ti=i+1;\n\t\tpermuta=0;\n\t\tfor(j=n-1; j>=i; j--)\n\t\t\tif(v[j] < v[j-1]) {'{'}\n\t\t\t\tx=v[j];\n\t\t\t\tpermuta=1;\n\t\t\t\tv[j]=v[j-1];\n\t\t\t\tv[j-1]=x;\n\t\t\t{'}'}\n\t{'}'}\n{'}'}</code></pre>",
      "choices": ["У этой функции нет лучшего случая", "\\(\\Theta(n)\\)", "\\(\\Theta(1)\\)"],
      "solution": 1
    },
    {
      "title": "Какое из этих утверждений неверно?",
      "choices": [
        "Алгоритмы итеративного динамического программирования используют мемоизацию, чтобы избежать повторного решения одних и тех же подзадач.",
        "Решение задачи дискретного рюкзака с помощью итеративного динамического программирования выполняет ненужные вычисления.",
        "Мемоизация не позволяет наивному рекурсивному алгоритму повторно решать одну и ту же задачу."
      ],
      "solution": 0
    },
    {
      "title": "Пусть следующее рекуррентное соотношение будет\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nАга \\(T(n)\\in\\Omicron(n)\\)В каком из этих трёх случаев мы можем оказаться?",
      "choices": ["\\(g(n)=n^2\\)", "\\(g(n)=1\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "Из следующих выражений либо два истинны, а одно ложно, либо два ложны и одно истинно. ",
      "choices": [
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log_2(n){'}'})\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(4^{\\log_2(n)})\\sube\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(2^{\\log_2(n)})\\sub\\Omicron(n^2)\\sub\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Ага \\(f\\in\\Theta(g_1)\\) и \\(f\\in\\Theta(g_2)\\)",
      "choices": [
        "\\(f^2\\in\\Theta(g_1\\cdot g_2)\\)",
        "Оба других варианта верны",
        "\\(f\\in\\Theta(\\max{g_1,g_2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "Наилучшая сложность алгоритма ветвления и сокращения",
      "choices": [
        "Это всегда экспоненциально с количеством решений, которые нужно принять.",
        "Оно может быть полиномиальным по количеству принимаемых решений.",
        "Обычно оно полиномиально с количеством альтернатив для каждого решения."
      ],
      "solution": 1
    },
    {
      "title": "Задача о минимальной сложной функции состоит в нахождении по множеству заданных функций минимальной последовательности их композиций, позволяющей преобразовать число \\(\\) в другом м. ",
      "choices": [
        "Использование вектора логических значений",
        "Использование вектора действительных чисел",
        "Эту проблему невозможно решить с помощью ветвления и сокращения без установления верхней границы общего количества применений функций."
      ],
      "solution": 2
    },
    {
      "title": "Функция \\(\\gamma\\) положительного полуцелого числа (число является полуцелым, если вычитание 0,5 делает его целым) определяется как<pre><code>double gamma(double n) {'{'}\n\tif(n == 0.5)\n\t\treturn sqrt(PI);\n\treturn n * gamma(n-1);\n{'}'}</code></pre>Можно ли его вычислить с помощью итеративного динамического программирования?",
      "choices": [
        "Нет, поскольку складской индекс будет действительным, а не целым числом.",
        "Да, но временная сложность не улучшается",
        "Нет, так как мы не смогли хранить промежуточные результаты на складе"
      ],
      "solution": 1
    },
    {
      "title": "Какое из этих выражений неверно?",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(2n^2+3n+1\\in\\Omicron(n^3)\\)",
        "\\(n+n\\log(n)\\in\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Учитывая рекуррентное соотношение:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ pT(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(где \\(p\\) и \\(a\\) являются целыми числами больше 1 и \\(g(n)=n^k\\)), что должно произойти, чтобы оно исполнилось? \\(T(n)\\in\\Theta(n^k\\log(n))\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p=a^k\\)", "\\(p < a^k\\)"],
      "solution": 1
    },
    {
      "title": "Может ли случиться так, что использование пессимистических и оптимистических границ бесполезно или даже вредно, когда мы сталкиваемся с задачей оптимизации, решаемой с помощью обратного отслеживания?",
      "choices": [
        "В зависимости от типа границы пессимистические границы могут не отбрасывать какие-либо узлы, но использование оптимистических границ гарантирует сокращение пространства поиска.",
        "Нет, как оптимистические, так и пессимистические оценки гарантируют сокращение пространства решений и, следовательно, эффективность алгоритма.",
        "Да, поскольку возможно, что, несмотря на использование этих размеров, ни один узел не будет отброшен."
      ],
      "solution": 2
    },
    {
      "title": "Скажите, какой из этих результатов асимптотических затрат времени является ложным:",
      "choices": [
        "Бинарный поиск в упорядоченном векторе требует в худшем случае времени \\(\\Omicron(\\log(n))\\)",
        "Сортировка вектора с использованием алгоритма быстрой сортировки требует в худшем случае времени \\(\\Omega(n^2)\\)",
        "Сортировка вектора с использованием алгоритма Mergesort требует в худшем случае времени \\(\\Omega(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Проблему можно решить методом «разделяй и властвуй», если:",
      "choices": [
        "Соблюдайте принцип оптимальности",
        "Удовлетворить теореме сведения",
        "Ни один из вышеперечисленных"
      ],
      "solution": 0
    },
    {
      "title": "С помощью какой схемы программирования мы получаем алгоритмы, вычисляющие расстояние редактирования между двумя цепочками?",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Оба"],
      "solution": 0
    },
    {
      "title": "Какая схема программирования подходит для решения задачи двоичного поиска?",
      "choices": ["Разделяй и властвуй", "Динамическое программирование", "Ни один"],
      "solution": 0
    },
    {
      "title": "Когда мы будем использовать динамическое программирование вместо принципа «разделяй и властвуй»?",
      "choices": [
        "Когда стоимость помещения снижается",
        "Когда эффективность возрастает",
        "Когда эффективность возрастает"
      ],
      "solution": 1
    },
    {
      "title": "Ага \\(n\\) — количество элементов вектора, стоимость алгоритма сортировки слиянием равна:",
      "choices": [
        "\\(\\Omicron(n^2)\\) и \\(\\Omega(n\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "\\(\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Учитывая алгоритм бинарного поиска, предположим, что вместо разделения списка элементов на две половины одинакового размера мы разбили его на две части размером 1/3 и 2/3. ",
      "choices": ["Он меньше оригинала", "Он больше оригинала", "Это то же самое, что и оригинал"],
      "solution": 1
    },
    {
      "title": "Для решения задачи оптимизации с помощью динамического программирования необходимо, чтобы:",
      "choices": [
        "Соблюдайте принцип оптимальности",
        "Удовлетворить теореме сведения",
        "Соблюдайте предыдущие два"
      ],
      "solution": 0
    },
    {
      "title": "Числовой ряд Фибоначчи определяется следующим образом:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\nКакая реализация из следующих имеет наименьшую стоимость?",
      "choices": [
        "Разделяй и властвуй",
        "Динамическое программирование",
        "Оба имеют одинаковую асимптотическую стоимость"
      ],
      "solution": 1
    },
    {
      "title": "Где в динамическом программировании мы будем хранить значения решенных задач?",
      "choices": ["В двумерном векторе", "Это зависит от проблемы", "В одномерном векторе"],
      "solution": 1
    },
    {
      "title": "Какая схема программирования подходит для решения k-й задачи минимума на векторе?",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Ни один"],
      "solution": 1
    },
    {
      "title": "Какую алгоритмическую схему использует алгоритм сортировки Quicksort?",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Возврат"],
      "solution": 1
    },
    {
      "title": "Дано рекурсивное решение задачи нахождения k-го минимума вектора. ",
      "choices": ["два или ни одного", "Один или два", "Один или ни один"],
      "solution": 2
    },
    {
      "title": "Если мы применим динамическое программирование к проблеме, которая также имеет решение методом «разделяй и властвуй», мы можем гарантировать, что:",
      "choices": [
        "Временные затраты сокращаются, а пространственные затраты увеличиваются по сравнению с решением D&V.",
        "По сравнению с решением D&V временные затраты увеличиваются, а пространственные затраты уменьшаются.",
        "Ни один из вышеперечисленных"
      ],
      "solution": 2
    },
    {
      "title": "Столкнувшись с проблемой, которая представляет собой рекурсивное решение, мы всегда можем применить:",
      "choices": [
        "Разделяй и властвуй",
        "Динамическое программирование",
        "Любой из двух вышеперечисленных"
      ],
      "solution": 0
    },
    {
      "title": "Числовой ряд Фибоначчи определяется следующим образом:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\nДля реализации этой функции мы можем использовать...",
      "choices": [
        "Разделяй и властвуй",
        "Динамическое программирование",
        "Любой из двух вышеперечисленных"
      ],
      "solution": 2
    },
    {
      "title": "Решение задачи нахождения k-го минимума вектора реализует следующую стратегию:",
      "choices": [
        "Не сортирует элементы вектора",
        "Частично отсортировать вектор",
        "Полностью отсортировать вектор"
      ],
      "solution": 1
    },
    {
      "title": "В каком из следующих случаев нельзя применять схему «Разделяй и властвуй»:",
      "choices": [
        "Когда подзадачи очень разных размеров",
        "Когда задача не удовлетворяет принципу оптимальности",
        "Его можно применять в обоих случаях"
      ],
      "solution": 2
    },
    {
      "title": "Динамическое программирование для решения проблемы применяет стратегию:",
      "choices": [
        "Решаются меньшие проблемы, и путем объединения решений получаются решения последовательно более крупных проблем, пока не будет достигнута исходная проблема.",
        "Решаемая задача разбивается на более мелкие подзадачи, которые решаются независимо, чтобы в конечном итоге объединить решения подзадач для получения решения исходной задачи.",
        "Ни один из вышеперечисленных"
      ],
      "solution": 0
    },
    {
      "title": "Предположим, что задача о рюкзаке решена с помощью динамического программирования и конкретизирована \\(n\\) элементов и максимальной перевозимой массой \\(P\\). ",
      "choices": ["Ага", "Нет", "Это зависит от значений \\(n\\) и \\(P\\)"],
      "solution": 1
    },
    {
      "title": "У нас есть две цепи длины \\(m\\) и \\(n\\). ",
      "choices": ["\\((m-1)\\times(n-1)\\)", "\\(m\\times n\\)", "\\((m+1)\\times(n+1)\\)"],
      "solution": 2
    },
    {
      "title": "Ага \\(n\\) — количество элементов вектора. ",
      "choices": [
        "\\(\\Omega(n)\\) и \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(n)\\) и \\(\\Omicron(n^2)\\)",
        "Ни один из двух"
      ],
      "solution": 1
    },
    {
      "title": "Ага \\(n\\) — количество элементов вектора. ",
      "choices": ["\\(\\Omicron(n^3)\\)", "\\(\\Omicron(n)\\)", "Ни один из вышеперечисленных"],
      "solution": 0
    },
    {
      "title": "Учитывая рекурсивное решение проблемы, как мы можем избежать многократного решения одних и тех же подзадач?",
      "choices": [
        "Решите подзадачи от самой большой к самой маленькой и сохраните результат в таблице, инициализируя ее небольшими задачами.",
        "Решите подзадачи от самой большой к самой маленькой и сохраните результат в таблице, инициализируя ее самыми крупными задачами.",
        "Решите подзадачи от самой маленькой до самой большой и сохраните результат в таблице, инициализируя ее небольшими задачами."
      ],
      "solution": 2
    },
    {
      "title": "Задача оптимизации, решение которой может быть выражено последовательностью решений, удовлетворяет принципу оптимальности, если для заданной оптимальной последовательности:",
      "choices": [
        "Существует по крайней мере одна подпоследовательность этого решения, которая соответствует оптимальному решению связанной с ней подзадачи.",
        "Существует подпоследовательность этого решения, которая соответствует оптимальному решению связанной с ней подзадачи.",
        "Любая подпоследовательность этого решения соответствует оптимальному решению связанной с ней подзадачи."
      ],
      "solution": 2
    },
    {
      "title": "Ага \\(n\\) — количество элементов вектора, то решение задачи двоичного поиска с наименьшей стоимостью имеет следующую сложность:",
      "choices": [
        "\\(\\Omega(\\log(n))\\) и \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(1)\\) и \\(\\Omicron(\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "Какова подходящая схема программирования для решения k-й задачи минимума на векторе?",
      "choices": ["Динамическое программирование", "Разделяй и властвуй", "Ни один из двух."],
      "solution": 1
    },
    {
      "title": "Можно ли оптимально решить проблему с рюкзаком, используя стратегию «разделяй и властвуй»?",
      "choices": [
        "Только в случае с рюкзаком с разделением",
        "Только для корпуса рюкзака без дробления.",
        "Да, его можно применить в обоих случаях."
      ],
      "solution": 1
    },
    {
      "title": "Вектор целых чисел размера \\(n\\) организованный как куча, имеет временную сложность, в лучшем случае удаление первого элемента и его переупорядочение:",
      "choices": [
        "Ни один из двух других вариантов неверен",
        "Константы с размером вектора",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Скажите, какой из этих результатов асимптотических затрат времени является ложным:",
      "choices": [
        "Сортировка вектора с использованием алгоритма быстрой сортировки требует в худшем случае времени \\(\\Omega(n^2)\\)",
        "Сортировка вектора с использованием алгоритма Mergesort требует в худшем случае времени \\(\\Omega(n^2)\\)",
        "Бинарный поиск в упорядоченном векторе требует в худшем случае времени \\(\\log(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Версия быстрой сортировки, в которой элемент вектора, занимающий первую позицию, используется в качестве опорной точки.",
      "choices": [
        "Он ведет себя хуже, когда вектор уже отсортирован",
        "Он ведет себя лучше, когда вектор уже отсортирован.",
        "Тот факт, был ли вектор ранее упорядочен или нет, не влияет на временную сложность этого алгоритма."
      ],
      "solution": 0
    },
    {
      "title": "Из следующих выражений либо два истинны, а одно ложно, либо два ложны и одно истинно. ",
      "choices": [
        "\\(\\Theta(n^2)\\sub\\Theta(n^3)\\)",
        "\\(\\Omega(n^2)\\sub\\Omega(n^3)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Быть \\(f(n)\\) решение рекуррентного соотношения \\(f(n)=2*f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\). ",
      "choices": [
        "\\(f(n)\\in\\Theta(n)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Доступен вектор размера \\(n\\) элементы которого заранее организованы в кучу. ",
      "choices": ["\\(\\Omicron(\\log(n))\\)", "\\(\\Omicron(n)\\)", "\\(\\Omicron(n\\log(n))\\)"],
      "solution": 2
    },
    {
      "title": "Указывает сложность в зависимости от n следующего фрагмента:<pre><code>int a = 0;\nfor(int i = 0; i < n; i++)\n\tfor(int j = i; j > 0; j/=2)\n\t\ta += A[i][j];</code></pre>",
      "choices": ["\\(\\Omicron(n\\log(n))\\)", "\\(\\Omicron(n)\\)", "\\(\\Omicron(n^2)\\)"],
      "solution": 0
    },
    {
      "title": "Пусть f(n) — решение рекуррентного соотношения... \\(f(n)=2f(n-1)+1; f(1)=1\\)\nУкажите, какое из этих трех выражений верно:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(2^n)\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    }
  ]
}
