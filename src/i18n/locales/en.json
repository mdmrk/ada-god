{
  "questions": [
    {
      "title": "The aim is to find the shortest path between two cities using a table with distances between pairs of cities, where -1 indicates absence of road. ",
      "choices": [
        "Does not always guarantee being faster",
        "Does not guarantee obtaining the shortest path",
        "It will only be faster in certain instances of the problem"
      ],
      "solution": 2
    },
    {
      "title": "Being an optimization problem, in the list of live branching and pruning nodes...",
      "choices": [
        "Only promising nodes are introduced, that is, nodes that can improve the best solution available at that moment.",
        "There may be nodes that are not promising",
        "The other two options are true"
      ],
      "solution": 2
    },
    {
      "title": "We want to obtain all the permutations of a list composed of \\(n\\) elements, which scheme is the most appropriate?",
      "choices": [
        "Divide and conquer, since the division into sublists could be done in constant time",
        "Branching and pruning, since with good boundary functions it is more efficient for this problem than going back",
        "Going back, for this problem there is no more efficient scheme"
      ],
      "solution": 2
    },
    {
      "title": "By solving the traveling salesman problem by backtracking and assuming a graph of \\(n\\) fully connected vertices, which of these is a good pessimistic bound when starting the search?",
      "choices": [
        "The remaining edges are ordered from smallest to greatest distance and the sum of the edges is calculated. \\(n\\) shorter edges",
        "The problem is solved using a greedy algorithm that adds each time to the path the vertex closest to the last added one.",
        "It multiplies \\(n\\) by the distance of the shortest edge that we have left to consider"
      ],
      "solution": 1
    },
    {
      "title": "If we use a branch and pruning algorithm and adapt it slightly to transform it into a backtracking algorithm, what do we really change?:",
      "choices": [
        "We cause optimistic limits to lose effectiveness",
        "We change the given function to the pessimistic bound",
        "It would be necessary to verify whether the solutions are feasible or not, since branching and pruning only generate feasible nodes."
      ],
      "solution": 0
    },
    {
      "title": "What is the main difference between a backtracking solution and a branch and pruning solution for the knapsack problem?",
      "choices": [
        "The order of exploration of the solutions",
        "The fact that the branching and pruning solution can start with a greedy suboptimal solution and the one backtracking does not",
        "The asymptotic cost in the worst case"
      ],
      "solution": 0
    },
    {
      "title": "You want to find the shortest path between two cities.\n",
      "choices": [
        "A pessimistic quote",
        "An optimistic point",
        "This would not be any pruning since it is possible that this heuristic will not find a feasible solution."
      ],
      "solution": 1
    },
    {
      "title": "The advantage of the branching and pruning strategy over backtracking is that the former generates possible solutions to the problem by...",
      "choices": [
        "A guided walk through a priority queue from which the nodes representing the most promising subtrees of the solution space are first extracted",
        "The other two options are true",
        "A tour guided by estimates of the best branches of the tree that represents the solution space"
      ],
      "solution": 1
    },
    {
      "title": "The backtracking strategy is applicable to selection and optimization problems in which:",
      "choices": [
        "The solution space is an infinite set",
        "The solution space is a finite set",
        "The solution space can be either finite or infinite, but in the latter case it must be at least countable."
      ],
      "solution": 1
    },
    {
      "title": "You want to find the shortest path between two cities.\n",
      "choices": [
        "No, since it does not ensure that a feasible solution will be found.",
        "No, since in some cases it can give distances less than the optimal one.",
        "Yes since the geographical distance ensures that another better solution is not possible"
      ],
      "solution": 0
    },
    {
      "title": "When we solve a problem using a branch and pruning scheme...",
      "choices": [
        "Decisions can only be binary",
        "The values ​​between which we choose in each of the decisions can form an infinite set",
        "The values ​​between which we choose in each of the decisions have to form a finite set."
      ],
      "solution": 2
    },
    {
      "title": "When a backtracking algorithm solves a problem \\(n\\) decisions, in which there are always at least two options for each decision, which of the following worst-case complexities is the best we can encounter?",
      "choices": [
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "The worst-case complexity of a branch and pruning algorithm:",
      "choices": [
        "It can be exponential with the number of alternatives for each decision",
        "It is exponential with the number of decisions to make",
        "It can be polynomial with the number of decisions to make"
      ],
      "solution": 1
    },
    {
      "title": "In the absence of optimistic and pessimistic limits, the backtracking strategy...",
      "choices": [
        "Cannot be used to solve optimization problems",
        "Does not traverse the entire tree if there is a way to discard subtrees that represent infeasible solution sets",
        "It must always go through the entire tree"
      ],
      "solution": 1
    },
    {
      "title": "You want to find the shortest path between two cities.\n",
      "choices": [
        "It would be a pessimistic estimate as long as we are certain that this approximation finds a feasible solution.",
        "It would be an optimistic estimate as long as there is certainty that this approach finds a feasible solution.",
        "None of the other two options"
      ],
      "solution": 0
    },
    {
      "title": "Decide which of these three does not serve as an optimistic bound to obtain the optimal value of the discrete backpack:",
      "choices": [
        "The discrete backpack value obtained using a greedy algorithm based on the specific value of the objects",
        "The value of the corresponding continuous backpack",
        "The value of a backpack that contains all the objects even if it exceeds the maximum weight allowed"
      ],
      "solution": 0
    },
    {
      "title": "The complexity in the smallest case of a branching and pruning algorithm...",
      "choices": [
        "It is usually polynomial with the number of alternatives for each decision",
        "It is always exponential with the number of decisions to make",
        "It can be polynomial with the number of decisions to make"
      ],
      "solution": 2
    },
    {
      "title": "What are pessimistic limits for branching and pruning?",
      "choices": [
        "To discard nodes based on preference for some other already completed node",
        "To be sure that the optimistic limit is well calculated",
        "To discard nodes based on expected profit"
      ],
      "solution": 2
    },
    {
      "title": "In branching and pruning algorithms, is the value of a pessimistic bound less than the value of an optimistic bound?",
      "choices": [
        "Yes, it's always like this",
        "In general yes, if it is a maximization problem, although sometimes both values ​​can coincide",
        "In general yes, if it is a minimization problem, although sometimes both values ​​can coincide"
      ],
      "solution": 1
    },
    {
      "title": "The branching and pruning strategy...",
      "choices": [
        "You need pessimistic bounds to decide the order of visiting the nodes of the solution tree",
        "To determine if a solution is feasible",
        "Only if used to solve optimization problems"
      ],
      "solution": 2
    },
    {
      "title": "In the scheme going back, the pruning mechanisms based on the best solution so far...",
      "choices": [
        "The previous two are true",
        "They guarantee that the entire space of possible solutions will never be explored.",
        "They can eliminate partial solutions that are feasible"
      ],
      "solution": 2
    },
    {
      "title": "Using dimension functions in branching and pruning...",
      "choices": [
        "It guarantees that the algorithm will be more efficient in any instance of the problem",
        "Can reduce the number of problem instances that belong to the worst case",
        "Transform complexities that were previously exponential into polynomials"
      ],
      "solution": 1
    },
    {
      "title": "Decide which of these three is the pessimistic bound closest to the optimal value of the discrete backpack:",
      "choices": [
        "The value of the corresponding continuous backpack",
        "The value of a backpack that contains all the objects even if it exceeds the maximum weight allowed",
        "The discrete backpack value obtained using a greedy algorithm based on the specific value of the objects"
      ],
      "solution": 2
    },
    {
      "title": "In the branching and pruning strategy...",
      "choices": [
        "Each node has its own optimistic bound, the pessimistic bound, however, is common for all nodes.",
        "Each node has its own pessimistic bound and also its own optimistic bound.",
        "Each node has its own pessimistic bound, the optimistic bound, however, is common for all nodes."
      ],
      "solution": 1
    },
    {
      "title": "In branching and pruning algorithms:",
      "choices": [
        "An optimistic bound is necessarily an insurmountable value, but if it were not, the node that leads to the optimal solution could be pruned.",
        "An optimistic bound is necessarily an achievable value, but if it is not, it is not guaranteed that the optimal solution will be found.",
        "The use of pessimistic bounds is only effective when a possible starting solution is available."
      ],
      "solution": 1
    },
    {
      "title": "Decide which of these three is the optimistic bound when using the backtracking strategy to solve the knapsack problem:",
      "choices": [
        "Value of a backpack",
        "Optimum value of the corresponding continuous backpack",
        "Discrete backpack value obtained with a greedy algorithm based on the specific value of the object"
      ],
      "solution": 1
    },
    {
      "title": "In branching and pruning algorithms, is the value of a pessimistic bound greater than the value of an optimistic bound? ",
      "choices": [
        "No, it's never like that",
        "In general yes, if it is a maximization problem, although sometimes both values ​​can coincide",
        "In general yes, if it is a minimization problem, although sometimes both values ​​can coincide"
      ],
      "solution": 2
    },
    {
      "title": "Given any optimization problem, does the backtracking strategy guarantee the optimal solution?",
      "choices": [
        "It is a necessary condition that the domain of decisions be discrete or discretizable and that the number of decisions to be made is limited.",
        "Yes, as long as the decision domain is discrete or discretizable and pruning mechanisms based on the best solution so far are used.",
        "Yes, since this method analyzes all the possibilities"
      ],
      "solution": 0
    },
    {
      "title": "The problem of shift assignment has a solution:\n \\(\\Nu\\).  \\(\\Mu\\) with \\(\\Nu\\) rows, where each student has written in their corresponding row an integer (between \\(-1\\) and \\(\\Nu-1\\) that indicates said priority (a value \\(-1\\) indicates that you do not want or cannot be with the person in the corresponding column. \\(0\\) indicates indifference and, the higher the value, the greater the preference for that person).  \\(\\Mu\\) is already created, design an algorithm that solves the problem optimally.",
      "choices": [
        "Optimize through backtracking",
        "Approximate (sub-optimal) via greedy",
        "Both"
      ],
      "solution": 2
    },
    {
      "title": "The execution time of a branch and pruning algorithm depends on:",
      "choices": [
        "The problem instance",
        "The function of selecting nodes for expansion",
        "From both"
      ],
      "solution": 2
    },
    {
      "title": "It is an optimization problem, if the decision domain is an infinite set",
      "choices": [
        "We can apply the backtracking scheme whenever it is a countable infinite set.",
        "A greedy strategy may be the only alternative",
        "It is likely that through dynamic programming an efficient algorithm will be obtained to solve it."
      ],
      "solution": 1
    },
    {
      "title": "Backtracking is applicable to selection and optimization problems in which:",
      "choices": [
        "The solution space is a finite set",
        "Anyways",
        "The solution space is an infinite set"
      ],
      "solution": 0
    },
    {
      "title": "Backtracking is a general problem solving technique based on:",
      "choices": [
        "The systematic search for solutions",
        "Direct construction of the solution",
        "None of the above"
      ],
      "solution": 0
    },
    {
      "title": "Voraz always gives optimal solution:",
      "choices": [
        "To both",
        "To the problem of the backpack without fractionation",
        "To the problem of the backpack with fractionation"
      ],
      "solution": 2
    },
    {
      "title": "Does the backpack problem find its optimal solution using the greedy strategy?:",
      "choices": [
        "Only for the case of the backpack without fractionation",
        "In any of the above cases",
        "Only in the case of the backpack with division"
      ],
      "solution": 2
    },
    {
      "title": "The traveling salesman problem can be solved correctly using these programming schemes:",
      "choices": [
        "Dynamic programming only",
        "Using any of these: Greedy and backtracking",
        "Backtracking only"
      ],
      "solution": 2
    },
    {
      "title": "In the voracious method, although the decisions are irreversible, we can ensure that:",
      "choices": [
        "We will always obtain a feasible solution",
        "We will always obtain the optimal solution",
        "We will only obtain the optimal solution for some problems"
      ],
      "solution": 2
    },
    {
      "title": "By applying backtracking we obtain the optimal solution to a problem:",
      "choices": [
        "Always",
        "Only when the problem meets the optimality principle",
        "In some cases"
      ],
      "solution": 2
    },
    {
      "title": "Given a problem solved by backtracking and by branching and pruning, the computational cost of the solution by Branching and Pruning, compared to that of Backtracking, is:",
      "choices": ["Minor", "Equal", "Elderly"],
      "solution": 1
    },
    {
      "title": "The shift assignment problem has an optimal solution using:\n \\(\\Nu\\).  \\(\\Mu\\) with \\(\\Nu\\) rows, where each student has written in their corresponding row an integer (between \\(-1\\) and \\(\\Nu-1\\) that indicates said priority (a value \\(-1\\) indicates that you do not want or cannot be with the person in the corresponding column. \\(0\\) indicates indifference and, the higher the value, the greater the preference for that person).  \\(\\Mu\\) is already created, design an algorithm that solves the problem optimally.",
      "choices": ["Backtracking", "Voracious", "Both"],
      "solution": 0
    },
    {
      "title": "By applying backtracking to problem solving, we obtain algorithms with computational costs:",
      "choices": ["Exponentials", "Polynomials", "Both are correct. "],
      "solution": 0
    },
    {
      "title": "Backtracking is used to solve optimization problems in which the aim is to find:",
      "choices": [
        "The two previous answers are correct",
        "A solution that satisfies some constraints and optimizes a certain objective function",
        "All solutions that satisfy some constraints"
      ],
      "solution": 0
    },
    {
      "title": "The shift assignment problem has a greedy optimal solution by applying the following strategy:\n \\(\\Nu\\).  \\(\\Mu\\) with \\(\\Nu\\) rows, where each student has written in their corresponding row an integer (between \\(-1\\) and \\(\\Nu-1\\) that indicates said priority (a value \\(-1\\) indicates that you do not want or cannot be with the person in the corresponding column. \\(0\\) indicates indifference and, the higher the value, the greater the preference for that person).  \\(\\Mu\\) is already created, design an algorithm that solves the problem optimally.",
      "choices": [
        "The problem does not have an optimal solution",
        "We select the students in descending order of preference, respecting the space restrictions of each shift.",
        "We select students in ascending order of preference, respecting the space restrictions of each shift"
      ],
      "solution": 0
    },
    {
      "title": "Can the backpack problem be solved by using backtracking?:",
      "choices": [
        "Only in the case of the backpack with division",
        "Only for the case of the backpack without fractionation",
        "It can be applied for both cases"
      ],
      "solution": 2
    },
    {
      "title": "Given an optimization problem and a greedy algorithm that solves it, when can we be sure that the solution obtained will be optimal?:",
      "choices": [
        "Voracious always finds optimal solution",
        "In both cases. ",
        "When we formally prove that the criterion leads to an optimal solution for any instance of the problem"
      ],
      "solution": 2
    },
    {
      "title": "The shift assignment problem solved through backtracking has a complexity:\n \\(\\Nu\\).  \\(\\Mu\\) with \\(\\Nu\\) rows, where each student has written in their corresponding row an integer (between \\(-1\\) and \\(\\Nu-1\\) that indicates said priority (a value \\(-1\\) indicates that you do not want or cannot be with the person in the corresponding column. \\(0\\) indicates indifference and, the higher the value, the greater the preference for that person).  \\(\\Mu\\) is already created, design an algorithm that solves the problem optimally.",
      "choices": ["Exponential", "Polynomial", "Neither of the two"],
      "solution": 0
    },
    {
      "title": "Backtracking seeks to obtain the solution to an optimization problem through the following strategy:",
      "choices": [
        "Generate all combinations of the solution and select the one that optimizes the objective function",
        "Generate all feasible solutions and select the one that optimizes the objective function",
        "Generate a feasible solution using an optimal criterion"
      ],
      "solution": 1
    },
    {
      "title": "Given a graph G that represents the towns of the province of Alicante with more than 20,000 inhabitants along with all the connecting roads between them. ",
      "choices": [
        "You may not find a solution even if it exists",
        "A feasible solution",
        "The optimal solution"
      ],
      "solution": 1
    },
    {
      "title": "If we apply a greedy algorithm that does not guarantee us the optimal solution to a problem then...",
      "choices": [
        "If the problem has an optimal solution, the greedy scheme guarantees that it will be found.",
        "We will obtain a feasible solution",
        "You may not find a solution even if it exists"
      ],
      "solution": 2
    },
    {
      "title": "The greedy method is used to solve selection and optimization problems in which the aim is to find:",
      "choices": [
        "The two previous answers are correct",
        "All solutions that satisfy some constraints",
        "A solution that satisfies some constraints and optimizes a certain objective function"
      ],
      "solution": 2
    },
    {
      "title": "If we apply a backtracking scheme that does not guarantee the optimal solution to a problem, then",
      "choices": [
        "We will obtain a feasible solution",
        "You may not find a solution even if it exists",
        "None of the above"
      ],
      "solution": 2
    },
    {
      "title": "The branching and pruning strategy generates possible solutions to the problem by:",
      "choices": [
        "A deep traversal of the tree representing the solution space",
        "A width path that represents the solution space",
        "A tour guided by estimates of the best branches of the tree that represents the solution space"
      ],
      "solution": 2
    },
    {
      "title": "Given the recursive backtracking problem, each recursive call generates how many new recursive calls?:\n \\(\\Nu\\).  \\(\\Mu\\) with \\(\\Nu\\) rows, where each student has written in their corresponding row an integer (between \\(-1\\) and \\(\\Nu-1\\) that indicates said priority (a value \\(-1\\) indicates that you do not want or cannot be with the person in the corresponding column. \\(0\\) indicates indifference and, the higher the value, the greater the preference for that person).  \\(\\Mu\\) is already created, design an algorithm that solves the problem optimally.",
      "choices": ["One or two", "One or none", "None of the above"],
      "solution": 2
    },
    {
      "title": "Which of these statements is false?",
      "choices": [
        "The worst-case complexity of Backtracking and branching and pruning solutions to the same problem is the same",
        "For the same problem, branching and pruning always explores a number of nodes less than or equal to backtracking",
        "Backtracking inspects the entire solution space of a problem while Branching and Pruning does not."
      ],
      "solution": 2
    },
    {
      "title": "If to solve the same problem we use a backtracking algorithm and modify it minimally to turn it into a branch and pruning algorithm, what do we really change?",
      "choices": [
        "We change the function we give to the pessimistic bound",
        "Checking feasible solutions: branching and pruning is not necessary since it only generates feasible nodes",
        "We make better use of optimistic levels"
      ],
      "solution": 2
    },
    {
      "title": "Backtracking generates possible solutions to the problem:",
      "choices": [
        "Through the depth traversal of the tree that represents the solution space",
        "By traversing the width of the tree that represents the solution space",
        "None of the above"
      ],
      "solution": 0
    },
    {
      "title": "In a problem solved by backtracking, the set of values ​​that the components of the solution tuple can take must be:",
      "choices": ["Infinite", "Continuous", "Finite"],
      "solution": 2
    },
    {
      "title": "When recursive decomposition of a problem results in subproblems of similar size, which scheme promises to be most appropriate?",
      "choices": [
        "Dynamic programming",
        "Divide and conquer, as long as it is guaranteed that the subproblems are not the same size",
        "The voracious method"
      ],
      "solution": 0
    },
    {
      "title": "Using dimension functions in branching and pruning...",
      "choices": [
        "Can reduce the number of problem instances that belong to the worst case",
        "It guarantees that the algorithm will be more efficient in any instance of the problem",
        "Transform complexities that were previously exponential into polynomials"
      ],
      "solution": 0
    },
    {
      "title": "If an optimization problem is for a function that takes continuous values",
      "choices": [
        "Iterative dynamic programming is always much more efficient than recursive dynamic programming in terms of memory usage",
        "The memory usage of iterative dynamic programming and recursive dynamic programming is the same regardless of whether the domain is discrete or continuous.",
        "Recursive dynamic programming can be much more efficient than iterative dynamic programming in terms of memory usage"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(f(n)\\in\\Omicron(n^3)\\), can it happen that \\(f(n)\\in\\Omicron(n^2)\\)?",
      "choices": [
        "Not because \\(n^3\\) No \\(\\in\\Omicron(n^2)\\)",
        "It is perfectly possible, since \\(\\Omicron(n^2)\\sube\\Omicron(n^3)\\)",
        "Only for low values ​​of \\(n\\)"
      ],
      "solution": 1
    },
    {
      "title": "Let the following recurrence relation be\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nYeah \\(T(n)\\in\\Omicron(n^2)\\)In which of these three cases can we find ourselves?",
      "choices": ["\\(g(n)=1\\)", "\\(g(n)=n^2\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "The naive (but correct) recursive solution to an optimization problem calls the function with the same parameters more than once. ",
      "choices": [
        "The efficiency of the algorithm can be improved by storing in a table the value returned for each set of parameters from each call when it occurs for the first time.",
        "The efficiency of the algorithm can be improved by converting the recursive algorithm directly into iterative without changing its basic operation",
        "The efficiency of the algorithm can be improved by defining in advance the order in which the solutions to the subproblems should be calculated and filling out a table in that order."
      ],
      "solution": 1
    },
    {
      "title": "A size problem \\(n\\) can be transformed into time \\(\\Omicron(n^2)\\) in another size \\(n-1\\). ",
      "choices": [
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "When a greedy algorithm is used to address the solution of a discrete selection optimization problem (i.e., a problem for which the solution is to find a subset of the set of elements that optimizes a given function), which of these three things are impossible to happen?",
      "choices": [
        "That the solution is not optimal",
        "That the algorithm does not find any solution",
        "That the decision already made previously regarding the selection of an element be reconsidered in view of the decision that must be made at the current moment"
      ],
      "solution": 2
    },
    {
      "title": "One of these three problems does not have an efficient solution that follows the dynamic programming scheme",
      "choices": [
        "The discreet backpack problem",
        "The problem of the towers of Hanoi",
        "The problem of cutting a tube in length \\(n\\) into integer length segments between 1 and \\(n\\) so that the price is maximized according to a table that gives the price for each length"
      ],
      "solution": 1
    },
    {
      "title": "Which of these three optimization problems does not have, or is not known to have, a greedy solution that is optimal?",
      "choices": [
        "The discreet backpack problem",
        "The minimum cost coverage tree of a connected network",
        "The problem of the continuous backpack or with fractionation"
      ],
      "solution": 0
    },
    {
      "title": "Which of the following algorithms would provide a pessimistic bound for the problem of finding the shortest path between two cities (the graph is assumed to be connected)",
      "choices": [
        "Calculate the geometric distance (in a straight line) between the city of origin and destination",
        "For all cities that are reachable in one step from the starting city, add the distance to that city and the geometric distance to the destination city",
        "Calculate the distance traveled moving randomly through the graph until reaching (by chance) the destination city"
      ],
      "solution": 2
    },
    {
      "title": "Given any optimization problem, does the backtracking strategy guarantee the optimal solution?",
      "choices": [
        "Yes, as long as the decision domain is discrete or discretizable and pruning mechanisms based on the best solution so far are used.",
        "Yes, since this method analyzes all the possibilities",
        "It is a necessary condition that the domain of decisions be discrete or discretizable and that the number of decisions to be made is limited."
      ],
      "solution": 2
    },
    {
      "title": "For which of these optimization problems is there a greedy solution?",
      "choices": [
        "The minimum covering tree for an undirected graph with weights",
        "The discreet backpack problem",
        "The problem of minimum cost allocation \\(n\\) tasks to workers when the cost of assigning the task \\(i\\) to the worker \\(j\\), \\(C_{'{'}ij{'}'}\\) is tabulated in a matrix"
      ],
      "solution": 0
    },
    {
      "title": "Time complexity at best",
      "choices": [
        "It is the time it takes the algorithm to solve the size or smallest size problem that can be presented.",
        "It is a function of the size or size of the problem that has to be defined for all possible values ​​of this",
        "The other two options are true"
      ],
      "solution": 1
    },
    {
      "title": "Does the use of a “divide and conquer” strategy guarantee the existence of a polynomial time complexity solution to any problem?",
      "choices": [
        "Yes, but as long as the joint time complexity of the problem decomposition operations and the combination of solutions is polynomial",
        "No",
        "Yes, in any case"
      ],
      "solution": 1
    },
    {
      "title": "Decide which of these three is the pessimistic bound closest to the optimal value of the discrete backpack:",
      "choices": [
        "The discrete backpack value obtained using a greedy algorithm based on the specific value of the objects",
        "The value of a backpack that contains all the objects even if it exceeds the maximum weight allowed",
        "The value of the corresponding continuous backpack"
      ],
      "solution": 0
    },
    {
      "title": "By solving the traveling salesman problem by backtracking, which of these optimistic bounds can we expect to improve the search tree?",
      "choices": [
        "The rest of the problem is solved using a greedy algorithm that adds each time to the path the vertex closest to the last added one.",
        "The remaining edges are ordered from shortest to greatest distance and the sum of the k shortest edges is calculated, where k is the number of jumps we have left to take.",
        "K is multiplied by the distance of the shortest edge that remains to be considered, where k is the number of jumps that remain to be taken."
      ],
      "solution": 1
    },
    {
      "title": "You want to find the shortest path between two cities. ",
      "choices": [
        "The new algorithm does not guarantee that it will be faster for all possible problem instances.",
        "This strategy does not ensure that the shortest path is obtained.",
        "The new algorithm will always be faster"
      ],
      "solution": 0
    },
    {
      "title": "In branching and pruning algorithms:",
      "choices": [
        "An optimistic bound is not necessarily an insurmountable value; ",
        "An optimistic limit is necessarily an achievable value; ",
        "A pessimistic bound is the maximum value that can be reached by any feasible node that is not optimal."
      ],
      "solution": 0
    },
    {
      "title": "The best-case complexity of a branch and pruning algorithm",
      "choices": [
        "It is always exponential with the number of decisions to make",
        "It is usually polynomial with the number of alternatives for each decision",
        "It can be polynomial with the number of decisions to make"
      ],
      "solution": 2
    },
    {
      "title": "The value obtained with the greedy method for the discrete knapsack problem is...",
      "choices": [
        "An upper bound for the optimal value",
        "A lower bound for the optimal value, but which never coincides with this",
        "A lower bound for the optimal value that can sometimes be equal to this"
      ],
      "solution": 2
    },
    {
      "title": "In the scheme, the order in which the different values ​​are assigned to the components of the vector that the solution will contain will go back.",
      "choices": [
        "The other two options are true",
        "May be relevant if pruning mechanisms based on optimistic estimates are used",
        "It is irrelevant if pruning mechanisms based on the best solution so far are not used"
      ],
      "solution": 0
    },
    {
      "title": "The best known solution to the continuous knapsack problem follows the scheme",
      "choices": ["Divide and conquer", "Voracious", "Branching and pruning"],
      "solution": 1
    },
    {
      "title": "Let A be a square matrix \\(n\\times n\\). ",
      "choices": [
        "If a solution to the problem is constructed based on the branching and pruning scheme, a good choice of optimistic and pessimistic bounds could avoid the exploration of all possible permutations.",
        "The time complexity of the best possible solution to the problem is \\(\\Omicron(n^2)\\)",
        "The time complexity of the best possible solution to the problem is \\(\\Omicron(n!)\\)"
      ],
      "solution": 1
    },
    {
      "title": "On a grid you want to draw the outline of a square of \\(n\\) side boxes. ",
      "choices": [
        "\\(\\Omicron(\\sqrt{'{'}n{'}'})\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Given an optimization problem, the greedy method...",
      "choices": [
        "You always get the optimal solution",
        "You always get a feasible solution",
        "Guarantees the optimal solution only for certain problems"
      ],
      "solution": 2
    },
    {
      "title": "Tell which of these three algorithms is not a \"divide and conquer\" algorithm:",
      "choices": ["Quicksort", "Mergesort", "Prim's algorithm"],
      "solution": 2
    },
    {
      "title": "When solving the discrete backpack problem using the backtracking strategy, could it take less time to find the optimal solution if you first try putting each object in before not putting it in?",
      "choices": [
        "No, since in any case all feasible solutions must be explored",
        "Yes, but only if optimistic bounds are used to prune the search tree",
        "Yes, whether optimistic bounds are used to prune the search tree or not"
      ],
      "solution": 1
    },
    {
      "title": "Given the following functions, we want to reduce the time complexity of the function \\(g\\) using iterative dynamic programming. <pre><code>// Precondición: {'{'} 0 <= i < v.size(); i < j <= v.size() {'}'}\nunsigned f(const vector<unsigned> &v, unsigned i, unsigned j) {'{'}\n\tif(i == j+1)\n\t\treturn v[i];\n\tunsigned sum = 0;\n\tfor(unsigned k = 0; k < j-i; k++)\n\t\tsum += f(v, i, i+k+1) + f(v, i+k+1, j);\n\treturn sum;\n{'}'}\n\nunsigned g(const vector<unsigned> &v) {'{'}\n\treturn f(v, v.begin(), v.end());\n{'}'}</code></pre>",
      "choices": ["Quadratic", "Exponential", "cubic"],
      "solution": 0
    },
    {
      "title": "In an optimization problem, if the decision domain is an infinite set,",
      "choices": [
        "It is likely that through dynamic programming an efficient algorithm will be obtained to solve it.",
        "A greedy strategy may be the only alternative",
        "We can apply the backwards scheme whenever it is a countable infinite set."
      ],
      "solution": 1
    },
    {
      "title": "If to solve the same problem we use a backtracking algorithm and modify it minimally to turn it into a branch and pruning algorithm, what do we really change?",
      "choices": [
        "The algorithm can take better advantage of optimistic bounds",
        "We change the function we give to the pessimistic bound",
        "Checking feasible solutions: branching and pruning is not necessary since it only generates feasible nodes"
      ],
      "solution": 0
    },
    {
      "title": "Which of these problems has an efficient solution using dynamic programming?",
      "choices": [
        "The discreet backpack without additional restrictions",
        "The problem of change",
        "The task assignment problem"
      ],
      "solution": 1
    },
    {
      "title": "The following program solves the problem of cutting a tube of length \\(n\\) into integer length segments between 1 and \\(n\\) so that the price is maximized according to a table that gives the price for each length, but a piece is missing. <pre><code>void fill(price r[]) {'{'}\n\tfor (index i=0; i <= n; i++) r[i] = -1;\n{'}'}\n\nprice cutrod(price p[], r[], length n) {'{'}\nprice q;\nif (r[n]>=0) return r[n];\nif (n==0) q=0;\nelse {'{'}\n\tq=-1;\n\tfor (index i=1; i<=n; i++)\n\tq=max(q,p[i]+cutrod(XXXXXXX));\n{'}'}\nr[n]=q;\nreturn q;\n{'}'}</code></pre>",
      "choices": ["p,r.n-r[n]", "p,r-1,1", "p,r,n-i"],
      "solution": 2
    },
    {
      "title": "In branching and pruning algorithms, is the value of a pessimistic bound greater than the value of an optimistic bound? ",
      "choices": [
        "No, it's never like that",
        "In general yes, if it is a maximization problem, although sometimes both values ​​can coincide",
        "In general yes, if it is a minimization problem, although sometimes both values ​​can coincide"
      ],
      "solution": 2
    },
    {
      "title": "One of these three situations is not possible:",
      "choices": [
        "\\(f(n)\\in\\Omicron(n)\\) and \\(f(n)\\in\\Omega(1)\\)",
        "\\(f(n)\\in\\Omega(n^2)\\) and \\(f(n)\\in\\Omicron(n)\\)",
        "\\(f(n)\\in\\Omicron(n)\\) and \\(f(n)\\in\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "The improvement that dynamic programming generally provides over the naive solution is achieved thanks to the fact that",
      "choices": [
        "In the naive solution, a relatively large number of distinct subproblems are rarely solved.",
        "The number of times subproblems are solved has nothing to do with the efficiency of problems solved using dynamic programming.",
        "In the naive solution, a relatively small number of different subproblems are often solved."
      ],
      "solution": 2
    },
    {
      "title": "The version of Quicksort that uses the element of the vector that occupies the first position as a pivot...",
      "choices": [
        "It behaves better when the vector is already sorted",
        "Does not present best and worst case for instances of the same size",
        "It behaves worse when the vector is already sorted"
      ],
      "solution": 2
    },
    {
      "title": "In the scheme going back, the pruning mechanisms based on the best solution so far...",
      "choices": [
        "The other two options are true",
        "They guarantee that the entire space of possible solutions will never be explored.",
        "They can eliminate partial solutions that are feasible"
      ],
      "solution": 2
    },
    {
      "title": "A recursive algorithm based on the divide and conquer scheme...",
      "choices": [
        "It will never have exponential complexity.",
        "The previous two are true.",
        "It will be more efficient the more equitable the division into subproblems."
      ],
      "solution": 2
    },
    {
      "title": "You want to order different numbers between 1 and \\(n\\).  \\(n\\) booleans that are first initialized to false. ",
      "choices": [
        "Yes, since the mergesort is \\(\\Omicron(n\\log(n))\\) and this is \\(\\Omicron(n)\\)",
        "No, since this algorithm has to go through the vector of booleans several times",
        "Only if \\(d\\log(d)>kn\\) (where \\(k\\) is a constant that depends on the implementation)"
      ],
      "solution": 2
    },
    {
      "title": "In branching and pruning, does it make sense to use the optimistic bound of the nodes as a criterion for ordering the list of live nodes?",
      "choices": [
        "No, the optimistic bound is only used to determine if an n-tuple is promising.",
        "Yes, although it is not a guarantee that it is a good search strategy",
        "Yes, if the list of live nodes is sorted, it must always be done according to the optimistic bound criterion"
      ],
      "solution": 1
    },
    {
      "title": "In the scheme going back, the pruning mechanisms based on the best solution so far:",
      "choices": [
        "They can eliminate vectors that represent possible feasible solutions",
        "They guarantee that not the entire space of possible solutions will be explored",
        "The other two options are both true"
      ],
      "solution": 0
    },
    {
      "title": "We want to obtain all the permutations of a list composed of \\(n\\) items. ",
      "choices": [
        "Divide and conquer, since the division into sublists could be done in constant time",
        "Going back, it is the most efficient scheme for this problem",
        "Branching and pruning, since with good elevation functions it is more efficient than going back"
      ],
      "solution": 1
    },
    {
      "title": "In the absence of optimistic and pessimistic levels, the backtracking strategy...",
      "choices": [
        "Does not traverse the entire tree if there is a way to discard subtrees that represent infeasible solution sets",
        "It must always go through the entire tree",
        "Cannot be used to solve optimization problems"
      ],
      "solution": 0
    },
    {
      "title": "The voracious scheme...",
      "choices": [
        "Guarantees to find a solution to any problem, although it may not be optimal",
        "You may not find a solution but if you do it is guaranteed to be optimal",
        "The other two options are both false"
      ],
      "solution": 2
    },
    {
      "title": "A recursive algorithm based on the divide and conquer scheme",
      "choices": [
        "The other two options are both true",
        "It reaches its maximum efficiency when the size problem \\(n\\) is divided into size problems \\(\\frac{'{'}n{'}'}{'{'}a{'}'}\\)",
        "It will never have an exponential asymptotic time cost (0 time complexity)"
      ],
      "solution": 1
    },
    {
      "title": "When the decomposition of a problem results in subproblems of similar size to the original, many of which are repeated, which scheme is a priori more appropriate?",
      "choices": [
        "Dynamic programming",
        "Divide and conquer",
        "Branching and pruning"
      ],
      "solution": 0
    },
    {
      "title": "Given the three-move maze problem, can a dynamic programming scheme be applied to obtain an exit path?",
      "choices": [
        "No, to ensure that an exit path is found, exhaustive search methods such as backtracking or branching and pruning must be applied.",
        "Yes, if you exist with this scheme you can always find an exit path",
        "No, with this scheme you can know the total number of different paths that lead to the exit but you cannot know the composition of any of them."
      ],
      "solution": 1
    },
    {
      "title": "We want to solve the problem of the nth power (\\(x^n\\)), assuming that \\(n\\) is even and the following recurrence will be used:\n\\(pot(x, n) = pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'}) * pot(x, \\frac{'{'}n{'}'}{'{'}2{'}'})\\) Which scheme turns out to be more efficient in terms of time cost?",
      "choices": [
        "In this case, both dynamic programming and divide and conquer turn out to be equivalent in terms of time complexity.",
        "Dynamic programming",
        "Divide and conquer"
      ],
      "solution": 1
    },
    {
      "title": "Decide which of these three is the optimistic bound closest to the optimal value of the discrete backpack:",
      "choices": [
        "The value of a backpack that contains all the objects even if it exceeds the maximum weight allowed",
        "The value of the corresponding continuous backpack",
        "The discrete backpack value obtained using a greedy algorithm based on the specific value of the objects"
      ],
      "solution": 1
    },
    {
      "title": "One of the laboratory practices consisted of the empirical calculation of the average time complexity of the Quicksort vector sorting algorithm, taking the element of the vector that occupies the central position as sentinel. ",
      "choices": ["\\(n^2\\)", "\\(n\\log(n)\\)", "\\(n\\log^2(n)\\)"],
      "solution": 1
    },
    {
      "title": "What is deduced from \\(f(n)\\) and \\(g(n)\\) if it is fulfilled \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=k\\)?",
      "choices": [
        "\\(g(n)\\in\\Omicron(f(n))\\) but \\(f(n)\\notin\\Omicron(g(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) and \\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\) but \\(g(n)\\notin\\Omicron(f(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "Given the maze problem with three movements, we want to know the number of different paths from the initial square \\((1, 1)\\) up to the box \\((n, m)\\) and for this a divide and conquer scheme is applied. ",
      "choices": [
        "\\(nc(n, m) = nc(n - 1, m) + nc(n, m - 1) + nc(n - 1, m - 1)\\)",
        "\\(nc(n, m) = nc(n - 1, m) + nc(m - 1, n) + nc(n - 1, m - 1)\\)",
        "Neither of the other two recurrences corresponds to a divide and conquer scheme"
      ],
      "solution": 0
    },
    {
      "title": "Let the following recurrence relation be:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nYeah \\(T(n)\\in\\Omicron(n)\\)In which of these three cases can we find ourselves?",
      "choices": [
        "\\(g(n)=\\sqrt{'{'}n{'}'}\\)",
        "\\(g(n)=\\log(n)\\)",
        "The other two options are both true"
      ],
      "solution": 2
    },
    {
      "title": "The scheme of going back...",
      "choices": [
        "Guarantees that you find the optimal solution to any discrete selection problem",
        "The other two options are both true",
        "It can be applied to any type of problem, although the time cost is high."
      ],
      "solution": 0
    },
    {
      "title": "What happens if the pessimistic bound of a node corresponds to a solution that is not feasible?",
      "choices": [
        "That the algorithm would be slower because more nodes would be explored than necessary",
        "Nothing special, the pessimistic limits do not have to correspond to feasible solutions",
        "That the algorithm would be incorrect because a node that leads to the optimal solution could be discarded"
      ],
      "solution": 2
    },
    {
      "title": "Given the maze problem with three movements, we want to know the number of different paths from the initial box (1, 1) to the box (n, m) and for this a dynamic programming scheme is applied. ",
      "choices": [
        "Improvement is not guaranteed since the recursive version with memoization could be worse than the one obtained from the divide and conquer scheme.",
        "From a quadratic complexity that would be obtained with the naive one, it would be reduced to linear with the memoization one.",
        "From an exponential complexity that would be obtained with the naive one, it would be reduced to polynomial with the memoization one."
      ],
      "solution": 2
    },
    {
      "title": "Given the maze problem with three movements, the aim is to know the length of the shortest exit path. ",
      "choices": [
        "Which in reality is not a voracious algorithm because the selection criterion is not",
        "Which is a voracious algorithm but with no guarantee of solving the problem",
        "That in reality it is not a voracious algorithm because the decisions made should not be reconsidered"
      ],
      "solution": 0
    },
    {
      "title": "Given the following function:<pre><code>int exa(vector<int> &v) {'{'}\n\tint j, i=1, n=v.size();\n\n\tif (n>1) do {'{'}\n\t\tint x = v[i];\n\t\tfor(j=i; j>0 && v[j-1] > x; j++)\n\t\t\tv[j]=v[j-1];\n\t\tv[j]=x;\n\t\ti++;\n\t{'}'} while(i<n);\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "Time complexity at best is \\(\\Omega(n)\\)",
        "Time complexity at best is \\(\\Omega(1)\\)",
        "The exact time complexity is \\(\\Theta(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Which search strategy is a priori most appropriate in a backtracking scheme?",
      "choices": [
        "Explore the nodes with the best optimistic bound first.",
        "Explore the nodes that are most complete first",
        "Search strategies cannot be defined in the backtracking scheme."
      ],
      "solution": 2
    },
    {
      "title": "Given the Towers of Hanoi problem solved by divide and conquer, which of the following recurrence relations best expresses its time complexity for the general case, being \\(n\\) the number of disks?",
      "choices": [
        "\\(T(n)=T(n-1)+n\\)",
        "\\(T(n)=2T(n-1)+1\\)",
        "\\(T(n)=2T(n-1)+n\\)"
      ],
      "solution": 1
    },
    {
      "title": "If the time cost of an algorithm is \\(T(n)\\), which of the following situations is impossible?",
      "choices": [
        "\\(T(n)\\in\\Omicron(n)\\) and \\(T(n)\\in\\Theta(n)\\)",
        "\\(T(n)\\in\\Theta(n)\\) and \\(T(n)\\in\\Omega(n^2)\\)",
        "\\(T(n)\\in\\Omega(n)\\) and \\(T(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "A tube of \\(n\\) centimeters long can be cut into segments of 1 centimeter, 2 centimeters, etc. ",
      "choices": [
        "A vector of booleans",
        "A table that indicates, for each position where it is going to be cut, each of the possible accumulated values",
        "A pair of integers indicating the cuts made and the accumulated value"
      ],
      "solution": 0
    },
    {
      "title": "What would be the time complexity of the following function after applying dynamic programming?<pre><code>double f(int n, int m) {'{'}\n\tif(n == 0) return 1;\n\treturn m * f(n-1,m) * f(n-2,m);\n{'}'}</code></pre>",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\times m)\\)",
        "\\(\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Given the following function: <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\tif (n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j;i<n;i++)\n\t\t\t\tsum+=v[i];\n\t\t\tif(j==0) sum=100;\n\t\t{'}'}\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>",
      "choices": [
        "Time complexity at best is \\(\\Omega(n)\\)",
        "The worst case time complexity is \\(\\Omega(1)\\)",
        "The worst case time complexity is \\(\\Omega(n\\log(n))\\)"
      ],
      "solution": 0
    },
    {
      "title": "The asymptotic time cost of inserting an element into an ordered vector so that it remains ordered is:",
      "choices": [
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omega(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Given a maximization problem solved using a branch-and-prune scheme, what happens if the optimistic bound turns out to be an excessively high value?",
      "choices": [
        "That fewer nodes than necessary could be explored",
        "You could prune the node that leads to the optimal solution",
        "That you could explore more nodes than necessary"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(f\\in\\Omega(g1)\\) and \\(f\\in\\Omega(g2)\\) so:",
      "choices": [
        "\\(f\\in\\Omega(g1*g2)\\)",
        "\\(f\\notin\\Omega(\\min(g1*g2))\\)",
        "\\(f\\in\\Omega(g1+g2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "What complexity is obtained from the recurrence relation \\(T(n)=8T(\\frac{'{'}n{'}'}{'{'}2{'}'})+n^3\\) with \\(T(1)=\\Omicron(1)\\)?",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(n^3\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "In the traveling salesman problem we want to list all the feasible solutions.",
      "choices": [
        "The most important thing is to get an appropriate pessimistic limit",
        "The order in which partial solutions are explored is not relevant; ",
        "The most appropriate would be to use a branching and pruning technique since the order in which the partial solutions are explored is very important."
      ],
      "solution": 1
    },
    {
      "title": "Given the following function where \\(\\max(a,b)\\in\\Theta(1)\\):<pre><code>float exa(vector<float> &v, vector<int> &p, int P, int i) {'{'}\n\tfloat a, b;\n\tif (i>=0) {'{'}\n\t\tif (p[i] <= P)\n\t\t\ta = v[i]*exa(v,p,P-p[i],i-1);\n\t\telse a=0;\n\t\tb=exa(v,p,P,i-1);\n\t\treturn max(a,b);\n\t{'}'}\n\treturn 0;\n{'}'}</code></pre>",
      "choices": [
        "Time complexity at best is \\(\\Omega(n^2)\\)",
        "The worst case time complexity is \\(\\Omicron(n^2)\\)",
        "Time complexity at best is \\(\\Omicron(2^n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "In the branching and pruning scheme, which structure is the most appropriate if we want to perform a level exploration?",
      "choices": ["priority queue", "Line", "Stack"],
      "solution": 1
    },
    {
      "title": "Given the following function:<pre><code>int exa(string &cad, int pri, int ult) {'{'}\n\tif(pri>=ult)\n\t\treturn 1;\n\telse\n\t\tif (cad[pri]==cad[ult])\n\t\t\treturn exa(cad, pri+1, ult-1);\n\t\telse\n\t\t\treturn 0;\n{'}'}</code></pre>What is its asymptotic time complexity?",
      "choices": [
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Given the three-move maze problem, which of the following strategies would provide an optimistic bound for branching and pruning?",
      "choices": [
        "Assume that from now on all the spaces in the maze are accessible",
        "Assume that no more movements are going to be made",
        "The other two strategies are both valid"
      ],
      "solution": 2
    },
    {
      "title": "Of the following expressions, either two are true and one is false, or two are false and one is true. ",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(\\Omicron(2^{'{'}\\log(n){'}'}\\sub\\Omicron(n^2))\\)",
        "\\(\\Theta(n)\\sub\\Theta(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "What does the average between the asymptotic time cost in the worst case and the asymptotic time cost in the best case give us?",
      "choices": [
        "The average time cost",
        "The asymptotic time cost in the average case",
        "Nothing of interest"
      ],
      "solution": 2
    },
    {
      "title": "You want to sort a linked list of \\(n\\) elements using the Mergesort algorithm. ",
      "choices": [
        "\\(\\Theta(n^2)\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "Neither of the other two options is true"
      ],
      "solution": 1
    },
    {
      "title": "Given the maze problem with three movements, we want to know the number of different paths from the initial box (1,1) to the box (n, m) and for this the dynamic programming scheme is applied to obtain the most efficient algorithm. possible in terms of temporal and spatial complexity. ",
      "choices": [
        "Temporary \\(\\Theta(n\\times m)\\) and spatial \\(\\Theta(n\\times m)\\)",
        "Temporary \\(\\Theta(\\max{n}{m})\\) and spatial \\(\\Theta(\\max{n}{m})\\)",
        "Temporary \\(\\Theta(n\\times m)\\) and spatial \\(\\Theta(\\min{'{'}n{'}'}{'{'}m{'}'})\\)"
      ],
      "solution": 2
    },
    {
      "title": "Indicate which of the following statements is true.",
      "choices": [
        "Pessimistic limits are not compatible with a backtracking scheme",
        "In a backwards scheme, pessimistic limits do not make sense if the aim is to obtain all feasible solutions.",
        "The backtracking scheme is not compatible with the joint use of pessimistic and optimistic bounds."
      ],
      "solution": 1
    },
    {
      "title": "Given a minimization problem solved using a branch-and-prune scheme, what property does an optimistic bound satisfy?",
      "choices": [
        "It is always greater than or equal to the best possible solution reached",
        "Ensures savings in testing all feasible solutions",
        "The other two options are both false"
      ],
      "solution": 2
    },
    {
      "title": "Given the following function <pre><code>int exa(vector<int> &v) {'{'}\n\tint i, sum=0, n=v.size();\n\n\t if(n>0) {'{'}\n\t\tint j=n;\n\t\twhile (sum<100) {'{'}\n\t\t\tj=j/2;\n\t\t\tsum=0;\n\t\t\tfor(i=j; i<n; i++)\n\t\t\t\tsum=v[i];\n\t\t\tif (j==0) sum=100;\n\t\t{'}'};\n\t\treturn j;\n\t{'}'}\n\telse return -1;\n{'}'}</code></pre>Mark the correct answer:",
      "choices": [
        "The exact time complexity is \\(\\Theta(n\\log(n))\\)",
        "Time complexity at best is \\(\\Omega(n)\\)",
        "Time complexity at best is \\(\\Omega(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Can the time cost of a recursive algorithm be reduced by storing the results returned by recursive calls?",
      "choices": [
        "No, you can only reduce the cost by converting the recursive algorithm to iterative",
        "Yes, if function calls with the same arguments are repeated",
        "No, this does not reduce the time cost since recursive calls must be made anyway"
      ],
      "solution": 1
    },
    {
      "title": "Of the following expressions, either two are true and one is false, or two are false and one is true. ",
      "choices": [
        "\\(\\Theta(f)=\\Omicron(f)\\cap\\Omega(f)\\)",
        "\\(\\Omega(f)=\\Theta(f)\\cap\\Omicron(f)\\)",
        "\\(\\Omicron(f)=\\Omega(f)\\cap\\Theta(f)\\)"
      ],
      "solution": 0
    },
    {
      "title": "The Quicksort algorithm divides the problem into two subproblems. ",
      "choices": [
        "\\(\\Omega(n)\\) and \\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "The time complexity of the backtracking solution to the discrete knapsack problem is:",
      "choices": [
        "Exponential in the worst case",
        "Quadratic in the worst case",
        "Exponential in any case"
      ],
      "solution": 0
    },
    {
      "title": "In the graph coloring problem (minimum number of colors necessary to color all the vertices of a graph so that no two adjacent vertices remain with the same color) solved by branching and pruning, an optimistic bound is the result of assuming that:",
      "choices": [
        "As many colors different from those already used will be used as there are vertices left to color.",
        "Only one more color will be necessary",
        "Colors other than those already used will not be used."
      ],
      "solution": 2
    },
    {
      "title": "The Quicksort version that uses the vector element that occupies the central position as a pivot",
      "choices": [
        "Does not present best and worst case for instances of the same size",
        "It behaves worse when the vector is already sorted",
        "It behaves better when the vector is sorted"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) and \\(k\\ne0\\) Which of these three statements is false?",
      "choices": [
        "\\(f(n)\\in\\Omicron(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "We have a set of \\(n\\) positive integers and we want to find the subset of size \\(m\\) minimum sum",
      "choices": [
        "A greedy technique would give an optimal solution",
        "The most appropriate would be to use a branch and pruning technique, although in the worst case the asymptotic time cost (0 time complexity) would be exponential",
        "To find the solution you would have to try all possible combinations of \\(m\\) whole, so the branching and pruning technique does not contribute anything with respect to going back"
      ],
      "solution": 0
    },
    {
      "title": "Which algorithm is asymptotically faster, Quicksort or Mergesort?",
      "choices": [
        "They are both equally fast, since the asymptotic time cost of both is \\(\\Omicron(n\\log(n))\\)",
        "As its name suggests, Quicksort",
        "Mergesort is always faster or equal (except for a constant) than Quicksort"
      ],
      "solution": 0
    },
    {
      "title": "Be \\(f(n)\\) the solution of the recurrence relation \\(f(n)=2f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\) Indicate which of these three expressions is true:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Which of these statements is true?",
      "choices": [
        "Memoization prevents a recursive algorithm from repeatedly solving the same problem",
        "The advantage of the iterative dynamic programming solution to the discrete knapsack problem is that unnecessary calculations are never performed.",
        "Iterative dynamic programming algorithms use memoization to avoid solving the same subproblems that arise again."
      ],
      "solution": 0
    },
    {
      "title": "Be \\(g(n)= \\sum_{'{'}i=0{'}'}^{'{'}K{'}'}a_in^i\\). ",
      "choices": [
        "\\(g(n)\\in\\Omega(n^k)\\)",
        "The other two statements are false.",
        "\\(g(n)\\in\\Theta(n^k)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Indicate which of these three expressions is false:",
      "choices": [
        "\\(\\Theta(n)\\cap\\Theta(n^2)\\)",
        "\\(\\Theta(n)\\cap\\Omicron(n)\\)",
        "\\(\\Theta(\\frac{'{'}n{'}'}{'{'}2{'}'})=\\Theta(n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Indicates the asymptotic time cost (or time complexity), as a function of n, of the following program: <pre><code>s=0; for(i=0; i<n; i++) for(j=i; j<n; j++) s+=n*i*j;</code></pre>",
      "choices": [
        "Is \\(\\Theta(n^2)\\)",
        "Is \\(\\Theta(n)\\)",
        "Is \\(\\Omicron(n^2)\\) but not \\(\\Omega(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Does it belong \\(3n^2\\) \\(\\Omicron(n^3)\\)?",
      "choices": ["No", "Yeah", "Only for c = 1 and n = 5"],
      "solution": 1
    },
    {
      "title": "Backtracking algorithms that make use of optimistic bounds generate possible solutions to the problem by...",
      "choices": [
        "A tour guided by estimates of the best branches of the tree that represent the solution space",
        "A guided walk through a priority queue from which the nodes representing the most promising subtrees of the solution space are first extracted",
        "A deep traversal of the tree representing the solution space"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}g(n){'}'})=0\\)",
      "choices": [
        "\\(f(n)\\in\\Theta(g(n))\\)",
        "\\(g(n)\\in\\Omicron(f(n))\\)",
        "\\(f(n)\\in\\Omicron(g(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(f\\in\\Theta(g1)\\) and \\(f\\in\\Theta(g2)\\)",
      "choices": [
        "\\(f\\in\\Theta(g1*g2)\\)",
        "\\(f\\in\\Theta(g1+g2)\\)",
        "\\(f\\notin\\Theta(\\max{g1,g2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "We want to reduce the time complexity of the following function by using dynamic programming. <pre><code>unsigned g(unsigned n, unsigned r) {'{'}\n\tif (r==0 || r==n)\n\t\treturn 1;\n\treturn g(n-1, r-1) + g(n-1, r);\n{'}'}</code></pre>",
      "choices": [
        "Can be reduced to linear",
        "Quadratic",
        "The function does not meet the necessary requirements to be able to apply dynamic programming"
      ],
      "solution": 1
    },
    {
      "title": "Which of these statements is false?",
      "choices": [
        "There are optimization problems in which the greedy method only obtains the optimal solution for some instances and a suboptimal solution for many other instances.",
        "All optimization problems have a greedy solution that is optimal whatever the instance to be solved.",
        "There are optimization problems for which the optimal solution can always be obtained using a greedy strategy."
      ],
      "solution": 1
    },
    {
      "title": "Given the recurrence relation:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(where \\(p\\) and \\(a\\) are integers greater than 1 and \\(g(n)=n^k\\), what has to happen for it to be fulfilled? \\(T(n)\\in\\Theta(n^k)\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p < a^k\\)", "\\(p=a^k\\)"],
      "solution": 1
    },
    {
      "title": "What is the main difference between a backtracking solution and a branch and pruning solution for the knapsack problem?",
      "choices": [
        "The order of exploration of the solutions",
        "The asymptotic cost in the worst case",
        "The fact that the branching and pruning solution can start with a greedy suboptimal solution and the one backtracking does not"
      ],
      "solution": 0
    },
    {
      "title": "Time complexity (or asymptotic time cost) at best...",
      "choices": [
        "It is a function of the size, or size of the problem, which has to be defined for all possible values ​​of this",
        "S is the time it takes the algorithm to solve the smallest size that can be presented.",
        "The previous two are true"
      ],
      "solution": 0
    },
    {
      "title": "Given an optimization problem, when can the backtracking method be applied?",
      "choices": [
        "It is a necessary (although not sufficient) condition that the decision domain be discrete or discretizable.",
        "It is a necessary and sufficient condition that the domain of decisions be discrete or discretizable.",
        "It is not only a necessary condition that the domain of decisions be discrete to discretizable; "
      ],
      "solution": 0
    },
    {
      "title": "The following recurrence relation expresses the complexity of a recursive algorithm, where g(n) is a polynomial function:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nSay which of the following statements is true:",
      "choices": [
        "Yeah \\(g(n)\\in\\Theta(n)\\) The recurrence ratio represents the best-case time complexity of the Quicksort sorting algorithm.",
        "Yeah \\(g(n)\\in\\Theta(n)\\) recurrence ratio represents the worst-case time complexity of the Quicksort sorting algorithm",
        "Yeah \\(g(n)\\in\\Theta(1)\\) The recurrence ratio represents the best-case time complexity of the Quicksort sorting algorithm."
      ],
      "solution": 0
    },
    {
      "title": "A recursive algorithm based on the divide and conquer scheme...",
      "choices": [
        "It will never have exponential complexity",
        "It will be more efficient the more equitable the division into subproblems.",
        "The other options are true"
      ],
      "solution": 1
    },
    {
      "title": "The time cost of an algorithm fits the following recurrence equation:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &n=0 \\\\ n+\\sum_{'{'}j=0{'}'}^{'{'}n-1{'}'}T(j) &n>1\\end{'{'}cases{'}'}\\)\n\nWhat asymptotic time cost (or time complexity) will the algorithm have?",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Study the recurrence relationship:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ \\rho T(\\frac{'{'}n{'}'}{'{'}q{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(where \\(p\\) and \\(q\\) are integers greater than 1). ",
      "choices": [
        "Dynamic programming",
        "Divide and conquer",
        "Branching and pruning"
      ],
      "solution": 1
    },
    {
      "title": "We take the Mergesort algorithm and instead of dividing the vector into two parts, we divide it into three. ",
      "choices": [
        "\\(\\Theta(\\log n)\\)",
        "\\(\\Theta(n)\\)",
        "Neither of the other two options is true"
      ],
      "solution": 1
    },
    {
      "title": "One of these three problems does not have a trivial and efficient solution that follows the greedy scheme",
      "choices": [
        "The backpack problem continues",
        "The problem of the discreet backpack without limitation on the maximum backpack load",
        "The problem of change"
      ],
      "solution": 2
    },
    {
      "title": "What is meant by “problem size”?",
      "choices": [
        "The maximum value that any instance of that problem can take",
        "The number of parameters that make up the problem",
        "The amount of memory space needed to code an instance of that problem"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(\\lim\\limits_{'{'}n\\rarr\\infin{'}'}(\\frac{'{'}f(n){'}'}{'{'}n^2{'}'})=k\\) and \\(k\\neq0\\), which of these three statements is true?",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Omega(n^3)\\)",
        "\\(f(n)\\in\\Theta(n^3)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Recurrence relations...",
      "choices": [
        "They serve to reduce the temporary cost of a solution when it is prohibitive",
        "They recursively express the time cost of an algorithm",
        "They appear only when the solution is of the divide and conquer type"
      ],
      "solution": 2
    },
    {
      "title": "The Quicksort and Mergesort sorting algorithms have in common:",
      "choices": [
        "that run on time \\(\\Omicron(n)\\)",
        "Who apply the divide and conquer strategy",
        "Which sort the vector without using additional space"
      ],
      "solution": 1
    },
    {
      "title": "Which of these three expressions is true?",
      "choices": [
        "\\(\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sube\\Omicron(2^n)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log(n){'}'})\\sub\\Omicron(2^n)\\)"
      ],
      "solution": 0
    },
    {
      "title": "The time cost of the insertion sort algorithm is",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n^2)\\)",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Have \\(n\\) different powdered substances and we want to generate all the different ways of mixing them with a total weight that does not exceed one gram, since our scale only counts up to 0.1 grams of precision. ",
      "choices": [
        "You can't because decisions are not discrete values.",
        "Yes you can without problems.",
        "You can't because of the infinite number of combinations."
      ],
      "solution": 1
    },
    {
      "title": "What is the best-case time complexity of the following function?<pre><code>void examen(vector<int> &v) {'{'}\n\tint i=0,j,x,n=v.size();\n\tbool permuta = 1;\n\twhile(n>0 && permuta) {'{'}\n\t\ti=i+1;\n\t\tpermuta=0;\n\t\tfor(j=n-1; j>=i; j--)\n\t\t\tif(v[j] < v[j-1]) {'{'}\n\t\t\t\tx=v[j];\n\t\t\t\tpermuta=1;\n\t\t\t\tv[j]=v[j-1];\n\t\t\t\tv[j-1]=x;\n\t\t\t{'}'}\n\t{'}'}\n{'}'}</code></pre>",
      "choices": [
        "This function has no better case",
        "\\(\\Theta(n)\\)",
        "\\(\\Theta(1)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Which of these statements is false?",
      "choices": [
        "Iterative dynamic programming algorithms use memoization to avoid solving the same subproblems that arise again.",
        "Iterative dynamic programming solution to the discrete knapsack problem performs unnecessary calculations",
        "Memoization prevents a naive recursive algorithm from repeatedly solving the same problem"
      ],
      "solution": 0
    },
    {
      "title": "Let the following recurrence relation be\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ 2T(\\frac{'{'}n{'}'}{'{'}2{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\nYeah \\(T(n)\\in\\Omicron(n)\\)In which of these three cases can we find ourselves?",
      "choices": ["\\(g(n)=n^2\\)", "\\(g(n)=1\\)", "\\(g(n)=n\\)"],
      "solution": 1
    },
    {
      "title": "Of the following expressions, either two are true and one is false, or two are false and one is true. ",
      "choices": [
        "\\(\\Omicron(n^2)\\sub\\Omicron(2^{'{'}\\log_2(n){'}'})\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(4^{\\log_2(n)})\\sube\\Omicron(n^2)\\sub\\Omicron(2^n)\\)",
        "\\(\\Omicron(2^{\\log_2(n)})\\sub\\Omicron(n^2)\\sub\\Omicron(n!)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Yeah \\(f\\in\\Theta(g_1)\\) and \\(f\\in\\Theta(g_2)\\)",
      "choices": [
        "\\(f^2\\in\\Theta(g_1\\cdot g_2)\\)",
        "The other two options are both true",
        "\\(f\\in\\Theta(\\max{g_1,g_2})\\)"
      ],
      "solution": 1
    },
    {
      "title": "The best-case complexity of a branch and pruning algorithm",
      "choices": [
        "It is always exponential with the number of decisions to make",
        "It can be polynomial with the number of decisions to make",
        "It is usually polynomial with the number of alternatives for each decision"
      ],
      "solution": 1
    },
    {
      "title": "The problem of the minimum composite function consists of finding, from a set of given functions, the minimum sequence of compositions of these that allows transforming a number \\(\\) in another m. ",
      "choices": [
        "Using a vector of booleans",
        "Using a vector of reals",
        "This problem cannot be solved using branching and pruning without setting an upper bound on the total number of function applications."
      ],
      "solution": 2
    },
    {
      "title": "The function \\(\\gamma\\) of a positive half-integer number (a number is half-integer if subtracting 0.5 makes it an integer) is defined as<pre><code>double gamma(double n) {'{'}\n\tif(n == 0.5)\n\t\treturn sqrt(PI);\n\treturn n * gamma(n-1);\n{'}'}</code></pre>Can it be calculated using iterative dynamic programming?",
      "choices": [
        "No, since the warehouse index would be a real number and not an integer",
        "Yes, but the time complexity does not improve",
        "No, since we could not store the intermediate results in the warehouse"
      ],
      "solution": 1
    },
    {
      "title": "Which of these expressions is false?",
      "choices": [
        "\\(n+n\\log(n)\\in\\Omega(n)\\)",
        "\\(2n^2+3n+1\\in\\Omicron(n^3)\\)",
        "\\(n+n\\log(n)\\in\\Theta(n)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Given the recurrence relation:\n\n\\(T(n)=\\begin{'{'}cases{'}'}1 &\\text{'{'}si {'}'} n\\leq 1 \\\\ pT(\\frac{'{'}n{'}'}{'{'}a{'}'})+g(n) &\\text{'{'}en otro caso{'}'}\\end{'{'}cases{'}'}\\)\n\n(where \\(p\\) and \\(a\\) are integers greater than 1 and \\(g(n)=n^k\\)), what has to happen for it to be fulfilled? \\(T(n)\\in\\Theta(n^k\\log(n))\\)?",
      "choices": ["\\(p>a^k\\)", "\\(p=a^k\\)", "\\(p < a^k\\)"],
      "solution": 1
    },
    {
      "title": "When faced with an optimization problem solved through backtracking, can it happen that the use of pessimistic and optimistic bounds is useless, even harmful?",
      "choices": [
        "Depending on the type of bound, the pessimistic bounds may not discard any nodes but the use of optimistic bounds guarantees the reduction of the search space",
        "No, both optimistic and pessimistic bounds guarantee the reduction of the solution space and therefore the efficiency of the algorithm.",
        "Yes, since it is possible that despite using these dimensions no node will be discarded"
      ],
      "solution": 2
    },
    {
      "title": "Say which of these asymptotic time cost results is false:",
      "choices": [
        "The binary search in an ordered vector requires in the worst case a time in \\(\\Omicron(\\log(n))\\)",
        "Sorting a vector using the Quicksort algorithm requires, in the worst case, time \\(\\Omega(n^2)\\)",
        "The sorting of a vector using the Mergesort algorithm requires in the worst case a time in \\(\\Omega(n^2)\\)"
      ],
      "solution": 2
    },
    {
      "title": "A problem can be solved by Divide and Conquer as long as:",
      "choices": [
        "Comply with the optimality principle",
        "Satisfy the reduction theorem",
        "None of the above"
      ],
      "solution": 0
    },
    {
      "title": "With what programming scheme do we obtain algorithms that calculate the editing distance between two chains?",
      "choices": ["Dynamic Programming", "Divide and Conquer", "Both"],
      "solution": 0
    },
    {
      "title": "What programming scheme is appropriate to solve the binary search problem?",
      "choices": ["Divide and Conquer", "Dynamic Programming", "Neither"],
      "solution": 0
    },
    {
      "title": "When will we use dynamic programming instead of divide and conquer?",
      "choices": [
        "When space cost is reduced",
        "When efficiency increases",
        "When efficiency increases"
      ],
      "solution": 1
    },
    {
      "title": "Yeah \\(n\\) is the number of elements of the vector, the cost of the Mergesort algorithm is:",
      "choices": [
        "\\(\\Omicron(n^2)\\) and \\(\\Omega(n\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)",
        "\\(\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Given the binary search algorithm, suppose that instead of splitting the list of elements into two halves of equal size, we split it into two parts of sizes 1/3 and 2/3. ",
      "choices": [
        "It is smaller than the original",
        "It is larger than the original",
        "It is the same as the original"
      ],
      "solution": 1
    },
    {
      "title": "For an optimization problem to be solved using dynamic programming, it is necessary that:",
      "choices": [
        "Comply with the optimality principle",
        "Satisfy the reduction theorem",
        "Comply with the previous two"
      ],
      "solution": 0
    },
    {
      "title": "The Fibonacci number series is defined as follows:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\nWhich implementation among the following has the lowest cost?",
      "choices": [
        "Divide and conquer",
        "Dynamic programming",
        "Both have the same asymptotic cost"
      ],
      "solution": 1
    },
    {
      "title": "In dynamic programming, where will we store the values ​​of the solved problems?",
      "choices": [
        "In a two-dimensional vector",
        "It depends on the problem",
        "In a one-dimensional vector"
      ],
      "solution": 1
    },
    {
      "title": "What programming scheme is appropriate to solve the kth minimum problem on a vector?",
      "choices": ["Dynamic programming", "Divide and conquer", "Neither"],
      "solution": 1
    },
    {
      "title": "What algorithmic scheme does the Quicksort sorting algorithm use?",
      "choices": ["Dynamic Programming", "Divide and Conquer", "Backtracking"],
      "solution": 1
    },
    {
      "title": "Given the recursive solution to the problem of finding the kth minimum of a vector. ",
      "choices": ["two or none", "One or two", "One or none"],
      "solution": 2
    },
    {
      "title": "If we apply dynamic programming to a problem that also has a solution by divide and conquer, we can ensure that:",
      "choices": [
        "The temporal cost is reduced and the spatial cost increases with respect to the D&V solution.",
        "The temporal cost increases and the spatial cost is reduced with respect to the D&V solution.",
        "None of the above"
      ],
      "solution": 2
    },
    {
      "title": "When faced with a problem that presents a recursive solution we can always apply:",
      "choices": [
        "Divide and conquer",
        "Dynamic Programming",
        "Any of the two above"
      ],
      "solution": 0
    },
    {
      "title": "The Fibonacci number series is defined as follows:\n\n\\(fib(n)=\\begin{'{'}cases{'}'}1 & n\\leq 1 \\\\ fib(n-1)+fib(n-2) & n>1 \\end{'{'}cases{'}'}\\)\n\nTo implement this function we can use...",
      "choices": [
        "Divide and conquer",
        "Dynamic programming",
        "Any of the two above"
      ],
      "solution": 2
    },
    {
      "title": "The solution to the problem of finding the kth minimum of a vector implements the following strategy:",
      "choices": [
        "Does not sort any elements of the vector",
        "Partially sort the vector",
        "Completely sort the vector"
      ],
      "solution": 1
    },
    {
      "title": "In which of the following cases cannot the Divide and Conquer scheme be applied:",
      "choices": [
        "When the subproblems are of very different sizes",
        "When the problem does not satisfy the optimality principle",
        "It can be applied in both cases"
      ],
      "solution": 2
    },
    {
      "title": "Dynamic programming, to solve a problem, applies the strategy:",
      "choices": [
        "Smaller problems are solved and, by combining the solutions, solutions to successively larger problems are obtained until reaching the original problem.",
        "The problem to be solved is decomposed into smaller subproblems, which are solved independently to finally combine the solutions of the subproblems to obtain the solution of the original problem.",
        "None of the above"
      ],
      "solution": 0
    },
    {
      "title": "Let us suppose the knapsack problem solved by dynamic programming and particularized to \\(n\\) elements and a maximum transportable weight of \\(P\\). ",
      "choices": [
        "Yeah",
        "No",
        "It depends on the values ​​of \\(n\\) and \\(P\\)"
      ],
      "solution": 1
    },
    {
      "title": "We have two length chains \\(m\\) and \\(n\\). ",
      "choices": [
        "\\((m-1)\\times(n-1)\\)",
        "\\(m\\times n\\)",
        "\\((m+1)\\times(n+1)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(n\\) is the number of elements of a vector. ",
      "choices": [
        "\\(\\Omega(n)\\) and \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(n)\\) and \\(\\Omicron(n^2)\\)",
        "Neither of the two"
      ],
      "solution": 1
    },
    {
      "title": "Yeah \\(n\\) is the number of elements of a vector. ",
      "choices": [
        "\\(\\Omicron(n^3)\\)",
        "\\(\\Omicron(n)\\)",
        "None of the above"
      ],
      "solution": 0
    },
    {
      "title": "Given a recursive solution to a problem, how can we avoid solving the same subproblems many times?",
      "choices": [
        "Solve the subproblems from largest to smallest and save the result in a table, initializing it with the small problems",
        "Solve the subproblems from largest to smallest and save your result in a table, initializing it with the largest problems",
        "Solve the subproblems from smallest to largest and save your result in a table, initializing it with the small problems"
      ],
      "solution": 2
    },
    {
      "title": "An optimization problem whose solution can be expressed by a sequence of decisions complies with the optimality principle if, given an optimal sequence:",
      "choices": [
        "There is at least one subsequence of that solution that corresponds to the optimal solution of its associated subproblem.",
        "There is a subsequence of that solution that corresponds to the optimal solution of its associated subproblem",
        "Any subsequence of that solution corresponds to the optimal solution of its associated subproblem."
      ],
      "solution": 2
    },
    {
      "title": "Yeah \\(n\\) is the number of elements of a vector, the lowest cost solution to the binary search problem has the following complexity:",
      "choices": [
        "\\(\\Omega(\\log(n))\\) and \\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omega(1)\\) and \\(\\Omicron(\\log(n))\\)",
        "\\(\\Theta(n\\log(n))\\)"
      ],
      "solution": 1
    },
    {
      "title": "What is the appropriate programming scheme to solve the kth minimum problem on a vector?",
      "choices": [
        "Dynamic Programming",
        "Divide and Conquer",
        "Neither one of the two."
      ],
      "solution": 1
    },
    {
      "title": "Can the backpack problem be solved optimally using the divide and conquer strategy?",
      "choices": [
        "Only in the case of the backpack with division",
        "Only for the case of the backpack without fractionation",
        "Yes, it can be applied for both cases"
      ],
      "solution": 1
    },
    {
      "title": "A vector of integers of size \\(n\\) organized as a heap has time complexity in the best case of deleting the first element and rearranging it from:",
      "choices": [
        "Neither of the other two options is correct",
        "Constants with vector size",
        "\\(\\Omicron(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "Say which of these asymptotic time cost results is false:",
      "choices": [
        "Sorting a vector using the Quicksort algorithm requires, in the worst case, time \\(\\Omega(n^2)\\)",
        "The sorting of a vector using the Mergesort algorithm requires in the worst case a time in \\(\\Omega(n^2)\\)",
        "The binary search in an ordered vector requires in the worst case a time in \\(\\log(n)\\)"
      ],
      "solution": 1
    },
    {
      "title": "The Quicksort version that uses the element of the vector that occupies the first position as a pivot",
      "choices": [
        "It behaves worse when the vector is already sorted",
        "It behaves better when the vector is already sorted",
        "The fact that the vector was previously ordered or not does not influence the time complexity of this algorithm."
      ],
      "solution": 0
    },
    {
      "title": "Of the following expressions, either two are true and one false, or two are false and one true. ",
      "choices": [
        "\\(\\Theta(n^2)\\sub\\Theta(n^3)\\)",
        "\\(\\Omega(n^2)\\sub\\Omega(n^3)\\)",
        "\\(\\Omicron(n^2)\\sub\\Omicron(n^3)\\)"
      ],
      "solution": 2
    },
    {
      "title": "Be \\(f(n)\\) the solution of the recurrence relation \\(f(n)=2*f(\\frac{'{'}n{'}'}{'{'}2{'}'})+n; f(1)\\). ",
      "choices": [
        "\\(f(n)\\in\\Theta(n)\\)",
        "\\(f(n)\\in\\Theta(n\\log(n))\\)",
        "\\(f(n)\\in\\Theta(n^2)\\)"
      ],
      "solution": 1
    },
    {
      "title": "A vector of size is available \\(n\\) whose elements are organized in advance forming a heap. ",
      "choices": [
        "\\(\\Omicron(\\log(n))\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n\\log(n))\\)"
      ],
      "solution": 2
    },
    {
      "title": "Indicates the complexity, as a function of n, of the following fragment:<pre><code>int a = 0;\nfor(int i = 0; i < n; i++)\n\tfor(int j = i; j > 0; j/=2)\n\t\ta += A[i][j];</code></pre>",
      "choices": [
        "\\(\\Omicron(n\\log(n))\\)",
        "\\(\\Omicron(n)\\)",
        "\\(\\Omicron(n^2)\\)"
      ],
      "solution": 0
    },
    {
      "title": "Let f(n) be the solution of the recurrence relation... \\(f(n)=2f(n-1)+1; f(1)=1\\)\nIndicate which of these three expressions is true:",
      "choices": [
        "\\(f(n)\\in\\Theta(n^2)\\)",
        "\\(f(n)\\in\\Theta(2^n)\\)",
        "\\(f(n)\\in\\Theta(n)\\)"
      ],
      "solution": 1
    }
  ]
}
